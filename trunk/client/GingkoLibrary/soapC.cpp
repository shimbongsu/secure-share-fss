/* soapC.cpp
   Generated by gSOAP 2.7.13 from GingkoWebService.h
   Copyright(C) 2000-2009, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.7.13 2009-11-12 07:22:20 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	soap->header = soap_new_SOAP_ENV__Header(soap, -1);
		soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns1__soapPackStatusEnum:
		return soap_in_ns1__soapPackStatusEnum(soap, NULL, NULL, "ns1:soapPackStatusEnum");
	case SOAP_TYPE_std__wstring:
		return soap_in_std__wstring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ns1__gingkoUserListPack:
		return soap_in_ns1__gingkoUserListPack(soap, NULL, NULL, "ns1:gingkoUserListPack");
	case SOAP_TYPE_ns1__searchUsersResponse:
		return soap_in_ns1__searchUsersResponse(soap, NULL, NULL, "ns1:searchUsersResponse");
	case SOAP_TYPE_ns1__searchUsers:
		return soap_in_ns1__searchUsers(soap, NULL, NULL, "ns1:searchUsers");
	case SOAP_TYPE_ns1__registerThisUnitResponse:
		return soap_in_ns1__registerThisUnitResponse(soap, NULL, NULL, "ns1:registerThisUnitResponse");
	case SOAP_TYPE_ns1__registerThisUnit:
		return soap_in_ns1__registerThisUnit(soap, NULL, NULL, "ns1:registerThisUnit");
	case SOAP_TYPE_ns1__companyUnit:
		return soap_in_ns1__companyUnit(soap, NULL, NULL, "ns1:companyUnit");
	case SOAP_TYPE_ns1__gingkoUnitPack:
		return soap_in_ns1__gingkoUnitPack(soap, NULL, NULL, "ns1:gingkoUnitPack");
	case SOAP_TYPE_ns1__findGingkoUnitInfoResponse:
		return soap_in_ns1__findGingkoUnitInfoResponse(soap, NULL, NULL, "ns1:findGingkoUnitInfoResponse");
	case SOAP_TYPE_ns1__findGingkoUnitInfo:
		return soap_in_ns1__findGingkoUnitInfo(soap, NULL, NULL, "ns1:findGingkoUnitInfo");
	case SOAP_TYPE_ns1__findDigitalPermission:
		return soap_in_ns1__findDigitalPermission(soap, NULL, NULL, "ns1:findDigitalPermission");
	case SOAP_TYPE_ns1__createDigitalInfo:
		return soap_in_ns1__createDigitalInfo(soap, NULL, NULL, "ns1:createDigitalInfo");
	case SOAP_TYPE_ns1__findDigitalInfoResponse:
		return soap_in_ns1__findDigitalInfoResponse(soap, NULL, NULL, "ns1:findDigitalInfoResponse");
	case SOAP_TYPE_ns1__findAssignedPermissionResponse:
		return soap_in_ns1__findAssignedPermissionResponse(soap, NULL, NULL, "ns1:findAssignedPermissionResponse");
	case SOAP_TYPE_ns1__deleteDigitalInfoResponse:
		return soap_in_ns1__deleteDigitalInfoResponse(soap, NULL, NULL, "ns1:deleteDigitalInfoResponse");
	case SOAP_TYPE_ns1__gingkoPermissionListPack:
		return soap_in_ns1__gingkoPermissionListPack(soap, NULL, NULL, "ns1:gingkoPermissionListPack");
	case SOAP_TYPE_ns1__findDigitalPermissionResponse:
		return soap_in_ns1__findDigitalPermissionResponse(soap, NULL, NULL, "ns1:findDigitalPermissionResponse");
	case SOAP_TYPE_ns1__updateDigitalInfoResponse:
		return soap_in_ns1__updateDigitalInfoResponse(soap, NULL, NULL, "ns1:updateDigitalInfoResponse");
	case SOAP_TYPE_ns1__deleteDigitalInfo:
		return soap_in_ns1__deleteDigitalInfo(soap, NULL, NULL, "ns1:deleteDigitalInfo");
	case SOAP_TYPE_ns1__digitalContent:
		return soap_in_ns1__digitalContent(soap, NULL, NULL, "ns1:digitalContent");
	case SOAP_TYPE_ns1__gingkoDigitalPack:
		return soap_in_ns1__gingkoDigitalPack(soap, NULL, NULL, "ns1:gingkoDigitalPack");
	case SOAP_TYPE_ns1__createDigitalInfoResponse:
		return soap_in_ns1__createDigitalInfoResponse(soap, NULL, NULL, "ns1:createDigitalInfoResponse");
	case SOAP_TYPE_ns1__findAssignedPermission:
		return soap_in_ns1__findAssignedPermission(soap, NULL, NULL, "ns1:findAssignedPermission");
	case SOAP_TYPE_ns1__updateDigitalInfo:
		return soap_in_ns1__updateDigitalInfo(soap, NULL, NULL, "ns1:updateDigitalInfo");
	case SOAP_TYPE_ns1__findDigitalInfo:
		return soap_in_ns1__findDigitalInfo(soap, NULL, NULL, "ns1:findDigitalInfo");
	case SOAP_TYPE_ns1__bindingGingkoUserResponse:
		return soap_in_ns1__bindingGingkoUserResponse(soap, NULL, NULL, "ns1:bindingGingkoUserResponse");
	case SOAP_TYPE_ns1__findUserByLoginIdResponse:
		return soap_in_ns1__findUserByLoginIdResponse(soap, NULL, NULL, "ns1:findUserByLoginIdResponse");
	case SOAP_TYPE_ns1__findUserByLoginId:
		return soap_in_ns1__findUserByLoginId(soap, NULL, NULL, "ns1:findUserByLoginId");
	case SOAP_TYPE_ns1__findUserByGingkoIdResponse:
		return soap_in_ns1__findUserByGingkoIdResponse(soap, NULL, NULL, "ns1:findUserByGingkoIdResponse");
	case SOAP_TYPE_ns1__findUserByGingkoId:
		return soap_in_ns1__findUserByGingkoId(soap, NULL, NULL, "ns1:findUserByGingkoId");
	case SOAP_TYPE_ns1__changePasswordResponse:
		return soap_in_ns1__changePasswordResponse(soap, NULL, NULL, "ns1:changePasswordResponse");
	case SOAP_TYPE_ns1__changePassword:
		return soap_in_ns1__changePassword(soap, NULL, NULL, "ns1:changePassword");
	case SOAP_TYPE_ns1__bindingGingkoUser:
		return soap_in_ns1__bindingGingkoUser(soap, NULL, NULL, "ns1:bindingGingkoUser");
	case SOAP_TYPE_ns1__requestPermissionResponse:
		return soap_in_ns1__requestPermissionResponse(soap, NULL, NULL, "ns1:requestPermissionResponse");
	case SOAP_TYPE_ns1__requestPermission:
		return soap_in_ns1__requestPermission(soap, NULL, NULL, "ns1:requestPermission");
	case SOAP_TYPE_ns1__gingkoPermission:
		return soap_in_ns1__gingkoPermission(soap, NULL, NULL, "ns1:gingkoPermission");
	case SOAP_TYPE_ns1__gingkoPermissionPack:
		return soap_in_ns1__gingkoPermissionPack(soap, NULL, NULL, "ns1:gingkoPermissionPack");
	case SOAP_TYPE_ns1__assignPermissionResponse:
		return soap_in_ns1__assignPermissionResponse(soap, NULL, NULL, "ns1:assignPermissionResponse");
	case SOAP_TYPE_ns1__assignPermission:
		return soap_in_ns1__assignPermission(soap, NULL, NULL, "ns1:assignPermission");
	case SOAP_TYPE_ns1__checkTokenResponse:
		return soap_in_ns1__checkTokenResponse(soap, NULL, NULL, "ns1:checkTokenResponse");
	case SOAP_TYPE_ns1__checkToken:
		return soap_in_ns1__checkToken(soap, NULL, NULL, "ns1:checkToken");
	case SOAP_TYPE_ns1__stringPack:
		return soap_in_ns1__stringPack(soap, NULL, NULL, "ns1:stringPack");
	case SOAP_TYPE_ns1__newGingkoIdResponse:
		return soap_in_ns1__newGingkoIdResponse(soap, NULL, NULL, "ns1:newGingkoIdResponse");
	case SOAP_TYPE_ns1__newGingkoId:
		return soap_in_ns1__newGingkoId(soap, NULL, NULL, "ns1:newGingkoId");
	case SOAP_TYPE_ns1__gingkoVersionPack:
		return soap_in_ns1__gingkoVersionPack(soap, NULL, NULL, "ns1:gingkoVersionPack");
	case SOAP_TYPE_ns1__gingkoVersionResponse:
		return soap_in_ns1__gingkoVersionResponse(soap, NULL, NULL, "ns1:gingkoVersionResponse");
	case SOAP_TYPE_ns1__gingkoVersion:
		return soap_in_ns1__gingkoVersion(soap, NULL, NULL, "ns1:gingkoVersion");
	case SOAP_TYPE_ns1__userLoginResponse:
		return soap_in_ns1__userLoginResponse(soap, NULL, NULL, "ns1:userLoginResponse");
	case SOAP_TYPE_ns1__userLogin:
		return soap_in_ns1__userLogin(soap, NULL, NULL, "ns1:userLogin");
	case SOAP_TYPE_ns1__gingkoUser:
		return soap_in_ns1__gingkoUser(soap, NULL, NULL, "ns1:gingkoUser");
	case SOAP_TYPE_ns1__gingkoUserPack:
		return soap_in_ns1__gingkoUserPack(soap, NULL, NULL, "ns1:gingkoUserPack");
	case SOAP_TYPE_ns1__registerUserResponse:
		return soap_in_ns1__registerUserResponse(soap, NULL, NULL, "ns1:registerUserResponse");
	case SOAP_TYPE_ns1__registerUser:
		return soap_in_ns1__registerUser(soap, NULL, NULL, "ns1:registerUser");
	case SOAP_TYPE_PointerTons1__createDigitalInfoResponse:
		return soap_in_PointerTons1__createDigitalInfoResponse(soap, NULL, NULL, "ns1:createDigitalInfoResponse");
	case SOAP_TYPE_PointerTons1__createDigitalInfo:
		return soap_in_PointerTons1__createDigitalInfo(soap, NULL, NULL, "ns1:createDigitalInfo");
	case SOAP_TYPE_PointerTons1__updateDigitalInfoResponse:
		return soap_in_PointerTons1__updateDigitalInfoResponse(soap, NULL, NULL, "ns1:updateDigitalInfoResponse");
	case SOAP_TYPE_PointerTons1__updateDigitalInfo:
		return soap_in_PointerTons1__updateDigitalInfo(soap, NULL, NULL, "ns1:updateDigitalInfo");
	case SOAP_TYPE_PointerTons1__findDigitalPermissionResponse:
		return soap_in_PointerTons1__findDigitalPermissionResponse(soap, NULL, NULL, "ns1:findDigitalPermissionResponse");
	case SOAP_TYPE_PointerTons1__findDigitalPermission:
		return soap_in_PointerTons1__findDigitalPermission(soap, NULL, NULL, "ns1:findDigitalPermission");
	case SOAP_TYPE_PointerTons1__assignPermissionResponse:
		return soap_in_PointerTons1__assignPermissionResponse(soap, NULL, NULL, "ns1:assignPermissionResponse");
	case SOAP_TYPE_PointerTons1__assignPermission:
		return soap_in_PointerTons1__assignPermission(soap, NULL, NULL, "ns1:assignPermission");
	case SOAP_TYPE_PointerTons1__findAssignedPermissionResponse:
		return soap_in_PointerTons1__findAssignedPermissionResponse(soap, NULL, NULL, "ns1:findAssignedPermissionResponse");
	case SOAP_TYPE_PointerTons1__findAssignedPermission:
		return soap_in_PointerTons1__findAssignedPermission(soap, NULL, NULL, "ns1:findAssignedPermission");
	case SOAP_TYPE_PointerTons1__findDigitalInfoResponse:
		return soap_in_PointerTons1__findDigitalInfoResponse(soap, NULL, NULL, "ns1:findDigitalInfoResponse");
	case SOAP_TYPE_PointerTons1__findDigitalInfo:
		return soap_in_PointerTons1__findDigitalInfo(soap, NULL, NULL, "ns1:findDigitalInfo");
	case SOAP_TYPE_PointerTons1__deleteDigitalInfoResponse:
		return soap_in_PointerTons1__deleteDigitalInfoResponse(soap, NULL, NULL, "ns1:deleteDigitalInfoResponse");
	case SOAP_TYPE_PointerTons1__deleteDigitalInfo:
		return soap_in_PointerTons1__deleteDigitalInfo(soap, NULL, NULL, "ns1:deleteDigitalInfo");
	case SOAP_TYPE_PointerTons1__requestPermissionResponse:
		return soap_in_PointerTons1__requestPermissionResponse(soap, NULL, NULL, "ns1:requestPermissionResponse");
	case SOAP_TYPE_PointerTons1__requestPermission:
		return soap_in_PointerTons1__requestPermission(soap, NULL, NULL, "ns1:requestPermission");
	case SOAP_TYPE_PointerTons1__changePasswordResponse:
		return soap_in_PointerTons1__changePasswordResponse(soap, NULL, NULL, "ns1:changePasswordResponse");
	case SOAP_TYPE_PointerTons1__changePassword:
		return soap_in_PointerTons1__changePassword(soap, NULL, NULL, "ns1:changePassword");
	case SOAP_TYPE_PointerTons1__findUserByGingkoIdResponse:
		return soap_in_PointerTons1__findUserByGingkoIdResponse(soap, NULL, NULL, "ns1:findUserByGingkoIdResponse");
	case SOAP_TYPE_PointerTons1__findUserByGingkoId:
		return soap_in_PointerTons1__findUserByGingkoId(soap, NULL, NULL, "ns1:findUserByGingkoId");
	case SOAP_TYPE_PointerTons1__searchUsersResponse:
		return soap_in_PointerTons1__searchUsersResponse(soap, NULL, NULL, "ns1:searchUsersResponse");
	case SOAP_TYPE_PointerTons1__searchUsers:
		return soap_in_PointerTons1__searchUsers(soap, NULL, NULL, "ns1:searchUsers");
	case SOAP_TYPE_PointerTons1__findUserByLoginIdResponse:
		return soap_in_PointerTons1__findUserByLoginIdResponse(soap, NULL, NULL, "ns1:findUserByLoginIdResponse");
	case SOAP_TYPE_PointerTons1__findUserByLoginId:
		return soap_in_PointerTons1__findUserByLoginId(soap, NULL, NULL, "ns1:findUserByLoginId");
	case SOAP_TYPE_PointerTons1__bindingGingkoUserResponse:
		return soap_in_PointerTons1__bindingGingkoUserResponse(soap, NULL, NULL, "ns1:bindingGingkoUserResponse");
	case SOAP_TYPE_PointerTons1__bindingGingkoUser:
		return soap_in_PointerTons1__bindingGingkoUser(soap, NULL, NULL, "ns1:bindingGingkoUser");
	case SOAP_TYPE_PointerTons1__findGingkoUnitInfoResponse:
		return soap_in_PointerTons1__findGingkoUnitInfoResponse(soap, NULL, NULL, "ns1:findGingkoUnitInfoResponse");
	case SOAP_TYPE_PointerTons1__findGingkoUnitInfo:
		return soap_in_PointerTons1__findGingkoUnitInfo(soap, NULL, NULL, "ns1:findGingkoUnitInfo");
	case SOAP_TYPE_PointerTons1__registerThisUnitResponse:
		return soap_in_PointerTons1__registerThisUnitResponse(soap, NULL, NULL, "ns1:registerThisUnitResponse");
	case SOAP_TYPE_PointerTons1__registerThisUnit:
		return soap_in_PointerTons1__registerThisUnit(soap, NULL, NULL, "ns1:registerThisUnit");
	case SOAP_TYPE_PointerTons1__checkTokenResponse:
		return soap_in_PointerTons1__checkTokenResponse(soap, NULL, NULL, "ns1:checkTokenResponse");
	case SOAP_TYPE_PointerTons1__checkToken:
		return soap_in_PointerTons1__checkToken(soap, NULL, NULL, "ns1:checkToken");
	case SOAP_TYPE_PointerTons1__newGingkoIdResponse:
		return soap_in_PointerTons1__newGingkoIdResponse(soap, NULL, NULL, "ns1:newGingkoIdResponse");
	case SOAP_TYPE_PointerTons1__newGingkoId:
		return soap_in_PointerTons1__newGingkoId(soap, NULL, NULL, "ns1:newGingkoId");
	case SOAP_TYPE_PointerTons1__gingkoVersionResponse:
		return soap_in_PointerTons1__gingkoVersionResponse(soap, NULL, NULL, "ns1:gingkoVersionResponse");
	case SOAP_TYPE_PointerTons1__gingkoVersion:
		return soap_in_PointerTons1__gingkoVersion(soap, NULL, NULL, "ns1:gingkoVersion");
	case SOAP_TYPE_PointerTons1__userLoginResponse:
		return soap_in_PointerTons1__userLoginResponse(soap, NULL, NULL, "ns1:userLoginResponse");
	case SOAP_TYPE_PointerTons1__userLogin:
		return soap_in_PointerTons1__userLogin(soap, NULL, NULL, "ns1:userLogin");
	case SOAP_TYPE_PointerTons1__registerUserResponse:
		return soap_in_PointerTons1__registerUserResponse(soap, NULL, NULL, "ns1:registerUserResponse");
	case SOAP_TYPE_PointerTons1__registerUser:
		return soap_in_PointerTons1__registerUser(soap, NULL, NULL, "ns1:registerUser");
	case SOAP_TYPE_PointerTons1__gingkoUserListPack:
		return soap_in_PointerTons1__gingkoUserListPack(soap, NULL, NULL, "ns1:gingkoUserListPack");
	case SOAP_TYPE_PointerTons1__companyUnit:
		return soap_in_PointerTons1__companyUnit(soap, NULL, NULL, "ns1:companyUnit");
	case SOAP_TYPE_PointerTons1__gingkoUnitPack:
		return soap_in_PointerTons1__gingkoUnitPack(soap, NULL, NULL, "ns1:gingkoUnitPack");
	case SOAP_TYPE_PointerTons1__gingkoPermissionListPack:
		return soap_in_PointerTons1__gingkoPermissionListPack(soap, NULL, NULL, "ns1:gingkoPermissionListPack");
	case SOAP_TYPE_PointerTons1__digitalContent:
		return soap_in_PointerTons1__digitalContent(soap, NULL, NULL, "ns1:digitalContent");
	case SOAP_TYPE_PointerTons1__gingkoDigitalPack:
		return soap_in_PointerTons1__gingkoDigitalPack(soap, NULL, NULL, "ns1:gingkoDigitalPack");
	case SOAP_TYPE_PointerTons1__gingkoPermission:
		return soap_in_PointerTons1__gingkoPermission(soap, NULL, NULL, "ns1:gingkoPermission");
	case SOAP_TYPE_PointerTons1__gingkoPermissionPack:
		return soap_in_PointerTons1__gingkoPermissionPack(soap, NULL, NULL, "ns1:gingkoPermissionPack");
	case SOAP_TYPE_PointerTons1__stringPack:
		return soap_in_PointerTons1__stringPack(soap, NULL, NULL, "ns1:stringPack");
	case SOAP_TYPE_PointerTons1__gingkoVersionPack:
		return soap_in_PointerTons1__gingkoVersionPack(soap, NULL, NULL, "ns1:gingkoVersionPack");
	case SOAP_TYPE_PointerTotime:
		return soap_in_PointerTotime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerTons1__soapPackStatusEnum:
		return soap_in_PointerTons1__soapPackStatusEnum(soap, NULL, NULL, "ns1:soapPackStatusEnum");
	case SOAP_TYPE_PointerTons1__gingkoUser:
		return soap_in_PointerTons1__gingkoUser(soap, NULL, NULL, "ns1:gingkoUser");
	case SOAP_TYPE_PointerTons1__gingkoUserPack:
		return soap_in_PointerTons1__gingkoUserPack(soap, NULL, NULL, "ns1:gingkoUserPack");
	case SOAP_TYPE_PointerTostd__wstring:
		return soap_in_PointerTostd__wstring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__wstring;
			return soap_in_std__wstring(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:gingkoUserListPack"))
		{	*type = SOAP_TYPE_ns1__gingkoUserListPack;
			return soap_in_ns1__gingkoUserListPack(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:searchUsersResponse"))
		{	*type = SOAP_TYPE_ns1__searchUsersResponse;
			return soap_in_ns1__searchUsersResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:searchUsers"))
		{	*type = SOAP_TYPE_ns1__searchUsers;
			return soap_in_ns1__searchUsers(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:registerThisUnitResponse"))
		{	*type = SOAP_TYPE_ns1__registerThisUnitResponse;
			return soap_in_ns1__registerThisUnitResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:registerThisUnit"))
		{	*type = SOAP_TYPE_ns1__registerThisUnit;
			return soap_in_ns1__registerThisUnit(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:companyUnit"))
		{	*type = SOAP_TYPE_ns1__companyUnit;
			return soap_in_ns1__companyUnit(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:gingkoUnitPack"))
		{	*type = SOAP_TYPE_ns1__gingkoUnitPack;
			return soap_in_ns1__gingkoUnitPack(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findGingkoUnitInfoResponse"))
		{	*type = SOAP_TYPE_ns1__findGingkoUnitInfoResponse;
			return soap_in_ns1__findGingkoUnitInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findGingkoUnitInfo"))
		{	*type = SOAP_TYPE_ns1__findGingkoUnitInfo;
			return soap_in_ns1__findGingkoUnitInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findDigitalPermission"))
		{	*type = SOAP_TYPE_ns1__findDigitalPermission;
			return soap_in_ns1__findDigitalPermission(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:createDigitalInfo"))
		{	*type = SOAP_TYPE_ns1__createDigitalInfo;
			return soap_in_ns1__createDigitalInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findDigitalInfoResponse"))
		{	*type = SOAP_TYPE_ns1__findDigitalInfoResponse;
			return soap_in_ns1__findDigitalInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findAssignedPermissionResponse"))
		{	*type = SOAP_TYPE_ns1__findAssignedPermissionResponse;
			return soap_in_ns1__findAssignedPermissionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteDigitalInfoResponse"))
		{	*type = SOAP_TYPE_ns1__deleteDigitalInfoResponse;
			return soap_in_ns1__deleteDigitalInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:gingkoPermissionListPack"))
		{	*type = SOAP_TYPE_ns1__gingkoPermissionListPack;
			return soap_in_ns1__gingkoPermissionListPack(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findDigitalPermissionResponse"))
		{	*type = SOAP_TYPE_ns1__findDigitalPermissionResponse;
			return soap_in_ns1__findDigitalPermissionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateDigitalInfoResponse"))
		{	*type = SOAP_TYPE_ns1__updateDigitalInfoResponse;
			return soap_in_ns1__updateDigitalInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteDigitalInfo"))
		{	*type = SOAP_TYPE_ns1__deleteDigitalInfo;
			return soap_in_ns1__deleteDigitalInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:digitalContent"))
		{	*type = SOAP_TYPE_ns1__digitalContent;
			return soap_in_ns1__digitalContent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:gingkoDigitalPack"))
		{	*type = SOAP_TYPE_ns1__gingkoDigitalPack;
			return soap_in_ns1__gingkoDigitalPack(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:createDigitalInfoResponse"))
		{	*type = SOAP_TYPE_ns1__createDigitalInfoResponse;
			return soap_in_ns1__createDigitalInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findAssignedPermission"))
		{	*type = SOAP_TYPE_ns1__findAssignedPermission;
			return soap_in_ns1__findAssignedPermission(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateDigitalInfo"))
		{	*type = SOAP_TYPE_ns1__updateDigitalInfo;
			return soap_in_ns1__updateDigitalInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findDigitalInfo"))
		{	*type = SOAP_TYPE_ns1__findDigitalInfo;
			return soap_in_ns1__findDigitalInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:bindingGingkoUserResponse"))
		{	*type = SOAP_TYPE_ns1__bindingGingkoUserResponse;
			return soap_in_ns1__bindingGingkoUserResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findUserByLoginIdResponse"))
		{	*type = SOAP_TYPE_ns1__findUserByLoginIdResponse;
			return soap_in_ns1__findUserByLoginIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findUserByLoginId"))
		{	*type = SOAP_TYPE_ns1__findUserByLoginId;
			return soap_in_ns1__findUserByLoginId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findUserByGingkoIdResponse"))
		{	*type = SOAP_TYPE_ns1__findUserByGingkoIdResponse;
			return soap_in_ns1__findUserByGingkoIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findUserByGingkoId"))
		{	*type = SOAP_TYPE_ns1__findUserByGingkoId;
			return soap_in_ns1__findUserByGingkoId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:changePasswordResponse"))
		{	*type = SOAP_TYPE_ns1__changePasswordResponse;
			return soap_in_ns1__changePasswordResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:changePassword"))
		{	*type = SOAP_TYPE_ns1__changePassword;
			return soap_in_ns1__changePassword(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:bindingGingkoUser"))
		{	*type = SOAP_TYPE_ns1__bindingGingkoUser;
			return soap_in_ns1__bindingGingkoUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:requestPermissionResponse"))
		{	*type = SOAP_TYPE_ns1__requestPermissionResponse;
			return soap_in_ns1__requestPermissionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:requestPermission"))
		{	*type = SOAP_TYPE_ns1__requestPermission;
			return soap_in_ns1__requestPermission(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:gingkoPermission"))
		{	*type = SOAP_TYPE_ns1__gingkoPermission;
			return soap_in_ns1__gingkoPermission(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:gingkoPermissionPack"))
		{	*type = SOAP_TYPE_ns1__gingkoPermissionPack;
			return soap_in_ns1__gingkoPermissionPack(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:assignPermissionResponse"))
		{	*type = SOAP_TYPE_ns1__assignPermissionResponse;
			return soap_in_ns1__assignPermissionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:assignPermission"))
		{	*type = SOAP_TYPE_ns1__assignPermission;
			return soap_in_ns1__assignPermission(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:checkTokenResponse"))
		{	*type = SOAP_TYPE_ns1__checkTokenResponse;
			return soap_in_ns1__checkTokenResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:checkToken"))
		{	*type = SOAP_TYPE_ns1__checkToken;
			return soap_in_ns1__checkToken(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:stringPack"))
		{	*type = SOAP_TYPE_ns1__stringPack;
			return soap_in_ns1__stringPack(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:newGingkoIdResponse"))
		{	*type = SOAP_TYPE_ns1__newGingkoIdResponse;
			return soap_in_ns1__newGingkoIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:newGingkoId"))
		{	*type = SOAP_TYPE_ns1__newGingkoId;
			return soap_in_ns1__newGingkoId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:gingkoVersionPack"))
		{	*type = SOAP_TYPE_ns1__gingkoVersionPack;
			return soap_in_ns1__gingkoVersionPack(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:gingkoVersionResponse"))
		{	*type = SOAP_TYPE_ns1__gingkoVersionResponse;
			return soap_in_ns1__gingkoVersionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:gingkoVersion"))
		{	*type = SOAP_TYPE_ns1__gingkoVersion;
			return soap_in_ns1__gingkoVersion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:userLoginResponse"))
		{	*type = SOAP_TYPE_ns1__userLoginResponse;
			return soap_in_ns1__userLoginResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:userLogin"))
		{	*type = SOAP_TYPE_ns1__userLogin;
			return soap_in_ns1__userLogin(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:gingkoUser"))
		{	*type = SOAP_TYPE_ns1__gingkoUser;
			return soap_in_ns1__gingkoUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:gingkoUserPack"))
		{	*type = SOAP_TYPE_ns1__gingkoUserPack;
			return soap_in_ns1__gingkoUserPack(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:registerUserResponse"))
		{	*type = SOAP_TYPE_ns1__registerUserResponse;
			return soap_in_ns1__registerUserResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:registerUser"))
		{	*type = SOAP_TYPE_ns1__registerUser;
			return soap_in_ns1__registerUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:soapPackStatusEnum"))
		{	*type = SOAP_TYPE_ns1__soapPackStatusEnum;
			return soap_in_ns1__soapPackStatusEnum(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_ns1__soapPackStatusEnum:
		return soap_out_ns1__soapPackStatusEnum(soap, tag, id, (const enum ns1__soapPackStatusEnum *)ptr, "ns1:soapPackStatusEnum");
	case SOAP_TYPE_std__wstring:
		return soap_out_std__wstring(soap, tag, id, (const std::wstring *)ptr, "xsd:string");
	case SOAP_TYPE_ns1__gingkoUserListPack:
		return ((ns1__gingkoUserListPack *)ptr)->soap_out(soap, tag, id, "ns1:gingkoUserListPack");
	case SOAP_TYPE_ns1__searchUsersResponse:
		return ((ns1__searchUsersResponse *)ptr)->soap_out(soap, tag, id, "ns1:searchUsersResponse");
	case SOAP_TYPE_ns1__searchUsers:
		return ((ns1__searchUsers *)ptr)->soap_out(soap, tag, id, "ns1:searchUsers");
	case SOAP_TYPE_ns1__registerThisUnitResponse:
		return ((ns1__registerThisUnitResponse *)ptr)->soap_out(soap, tag, id, "ns1:registerThisUnitResponse");
	case SOAP_TYPE_ns1__registerThisUnit:
		return ((ns1__registerThisUnit *)ptr)->soap_out(soap, tag, id, "ns1:registerThisUnit");
	case SOAP_TYPE_ns1__companyUnit:
		return ((ns1__companyUnit *)ptr)->soap_out(soap, tag, id, "ns1:companyUnit");
	case SOAP_TYPE_ns1__gingkoUnitPack:
		return ((ns1__gingkoUnitPack *)ptr)->soap_out(soap, tag, id, "ns1:gingkoUnitPack");
	case SOAP_TYPE_ns1__findGingkoUnitInfoResponse:
		return ((ns1__findGingkoUnitInfoResponse *)ptr)->soap_out(soap, tag, id, "ns1:findGingkoUnitInfoResponse");
	case SOAP_TYPE_ns1__findGingkoUnitInfo:
		return ((ns1__findGingkoUnitInfo *)ptr)->soap_out(soap, tag, id, "ns1:findGingkoUnitInfo");
	case SOAP_TYPE_ns1__findDigitalPermission:
		return ((ns1__findDigitalPermission *)ptr)->soap_out(soap, tag, id, "ns1:findDigitalPermission");
	case SOAP_TYPE_ns1__createDigitalInfo:
		return ((ns1__createDigitalInfo *)ptr)->soap_out(soap, tag, id, "ns1:createDigitalInfo");
	case SOAP_TYPE_ns1__findDigitalInfoResponse:
		return ((ns1__findDigitalInfoResponse *)ptr)->soap_out(soap, tag, id, "ns1:findDigitalInfoResponse");
	case SOAP_TYPE_ns1__findAssignedPermissionResponse:
		return ((ns1__findAssignedPermissionResponse *)ptr)->soap_out(soap, tag, id, "ns1:findAssignedPermissionResponse");
	case SOAP_TYPE_ns1__deleteDigitalInfoResponse:
		return ((ns1__deleteDigitalInfoResponse *)ptr)->soap_out(soap, tag, id, "ns1:deleteDigitalInfoResponse");
	case SOAP_TYPE_ns1__gingkoPermissionListPack:
		return ((ns1__gingkoPermissionListPack *)ptr)->soap_out(soap, tag, id, "ns1:gingkoPermissionListPack");
	case SOAP_TYPE_ns1__findDigitalPermissionResponse:
		return ((ns1__findDigitalPermissionResponse *)ptr)->soap_out(soap, tag, id, "ns1:findDigitalPermissionResponse");
	case SOAP_TYPE_ns1__updateDigitalInfoResponse:
		return ((ns1__updateDigitalInfoResponse *)ptr)->soap_out(soap, tag, id, "ns1:updateDigitalInfoResponse");
	case SOAP_TYPE_ns1__deleteDigitalInfo:
		return ((ns1__deleteDigitalInfo *)ptr)->soap_out(soap, tag, id, "ns1:deleteDigitalInfo");
	case SOAP_TYPE_ns1__digitalContent:
		return ((ns1__digitalContent *)ptr)->soap_out(soap, tag, id, "ns1:digitalContent");
	case SOAP_TYPE_ns1__gingkoDigitalPack:
		return ((ns1__gingkoDigitalPack *)ptr)->soap_out(soap, tag, id, "ns1:gingkoDigitalPack");
	case SOAP_TYPE_ns1__createDigitalInfoResponse:
		return ((ns1__createDigitalInfoResponse *)ptr)->soap_out(soap, tag, id, "ns1:createDigitalInfoResponse");
	case SOAP_TYPE_ns1__findAssignedPermission:
		return ((ns1__findAssignedPermission *)ptr)->soap_out(soap, tag, id, "ns1:findAssignedPermission");
	case SOAP_TYPE_ns1__updateDigitalInfo:
		return ((ns1__updateDigitalInfo *)ptr)->soap_out(soap, tag, id, "ns1:updateDigitalInfo");
	case SOAP_TYPE_ns1__findDigitalInfo:
		return ((ns1__findDigitalInfo *)ptr)->soap_out(soap, tag, id, "ns1:findDigitalInfo");
	case SOAP_TYPE_ns1__bindingGingkoUserResponse:
		return ((ns1__bindingGingkoUserResponse *)ptr)->soap_out(soap, tag, id, "ns1:bindingGingkoUserResponse");
	case SOAP_TYPE_ns1__findUserByLoginIdResponse:
		return ((ns1__findUserByLoginIdResponse *)ptr)->soap_out(soap, tag, id, "ns1:findUserByLoginIdResponse");
	case SOAP_TYPE_ns1__findUserByLoginId:
		return ((ns1__findUserByLoginId *)ptr)->soap_out(soap, tag, id, "ns1:findUserByLoginId");
	case SOAP_TYPE_ns1__findUserByGingkoIdResponse:
		return ((ns1__findUserByGingkoIdResponse *)ptr)->soap_out(soap, tag, id, "ns1:findUserByGingkoIdResponse");
	case SOAP_TYPE_ns1__findUserByGingkoId:
		return ((ns1__findUserByGingkoId *)ptr)->soap_out(soap, tag, id, "ns1:findUserByGingkoId");
	case SOAP_TYPE_ns1__changePasswordResponse:
		return ((ns1__changePasswordResponse *)ptr)->soap_out(soap, tag, id, "ns1:changePasswordResponse");
	case SOAP_TYPE_ns1__changePassword:
		return ((ns1__changePassword *)ptr)->soap_out(soap, tag, id, "ns1:changePassword");
	case SOAP_TYPE_ns1__bindingGingkoUser:
		return ((ns1__bindingGingkoUser *)ptr)->soap_out(soap, tag, id, "ns1:bindingGingkoUser");
	case SOAP_TYPE_ns1__requestPermissionResponse:
		return ((ns1__requestPermissionResponse *)ptr)->soap_out(soap, tag, id, "ns1:requestPermissionResponse");
	case SOAP_TYPE_ns1__requestPermission:
		return ((ns1__requestPermission *)ptr)->soap_out(soap, tag, id, "ns1:requestPermission");
	case SOAP_TYPE_ns1__gingkoPermission:
		return ((ns1__gingkoPermission *)ptr)->soap_out(soap, tag, id, "ns1:gingkoPermission");
	case SOAP_TYPE_ns1__gingkoPermissionPack:
		return ((ns1__gingkoPermissionPack *)ptr)->soap_out(soap, tag, id, "ns1:gingkoPermissionPack");
	case SOAP_TYPE_ns1__assignPermissionResponse:
		return ((ns1__assignPermissionResponse *)ptr)->soap_out(soap, tag, id, "ns1:assignPermissionResponse");
	case SOAP_TYPE_ns1__assignPermission:
		return ((ns1__assignPermission *)ptr)->soap_out(soap, tag, id, "ns1:assignPermission");
	case SOAP_TYPE_ns1__checkTokenResponse:
		return ((ns1__checkTokenResponse *)ptr)->soap_out(soap, tag, id, "ns1:checkTokenResponse");
	case SOAP_TYPE_ns1__checkToken:
		return ((ns1__checkToken *)ptr)->soap_out(soap, tag, id, "ns1:checkToken");
	case SOAP_TYPE_ns1__stringPack:
		return ((ns1__stringPack *)ptr)->soap_out(soap, tag, id, "ns1:stringPack");
	case SOAP_TYPE_ns1__newGingkoIdResponse:
		return ((ns1__newGingkoIdResponse *)ptr)->soap_out(soap, tag, id, "ns1:newGingkoIdResponse");
	case SOAP_TYPE_ns1__newGingkoId:
		return ((ns1__newGingkoId *)ptr)->soap_out(soap, tag, id, "ns1:newGingkoId");
	case SOAP_TYPE_ns1__gingkoVersionPack:
		return ((ns1__gingkoVersionPack *)ptr)->soap_out(soap, tag, id, "ns1:gingkoVersionPack");
	case SOAP_TYPE_ns1__gingkoVersionResponse:
		return ((ns1__gingkoVersionResponse *)ptr)->soap_out(soap, tag, id, "ns1:gingkoVersionResponse");
	case SOAP_TYPE_ns1__gingkoVersion:
		return ((ns1__gingkoVersion *)ptr)->soap_out(soap, tag, id, "ns1:gingkoVersion");
	case SOAP_TYPE_ns1__userLoginResponse:
		return ((ns1__userLoginResponse *)ptr)->soap_out(soap, tag, id, "ns1:userLoginResponse");
	case SOAP_TYPE_ns1__userLogin:
		return ((ns1__userLogin *)ptr)->soap_out(soap, tag, id, "ns1:userLogin");
	case SOAP_TYPE_ns1__gingkoUser:
		return ((ns1__gingkoUser *)ptr)->soap_out(soap, tag, id, "ns1:gingkoUser");
	case SOAP_TYPE_ns1__gingkoUserPack:
		return ((ns1__gingkoUserPack *)ptr)->soap_out(soap, tag, id, "ns1:gingkoUserPack");
	case SOAP_TYPE_ns1__registerUserResponse:
		return ((ns1__registerUserResponse *)ptr)->soap_out(soap, tag, id, "ns1:registerUserResponse");
	case SOAP_TYPE_ns1__registerUser:
		return ((ns1__registerUser *)ptr)->soap_out(soap, tag, id, "ns1:registerUser");
	case SOAP_TYPE_PointerTons1__createDigitalInfoResponse:
		return soap_out_PointerTons1__createDigitalInfoResponse(soap, tag, id, (ns1__createDigitalInfoResponse *const*)ptr, "ns1:createDigitalInfoResponse");
	case SOAP_TYPE_PointerTons1__createDigitalInfo:
		return soap_out_PointerTons1__createDigitalInfo(soap, tag, id, (ns1__createDigitalInfo *const*)ptr, "ns1:createDigitalInfo");
	case SOAP_TYPE_PointerTons1__updateDigitalInfoResponse:
		return soap_out_PointerTons1__updateDigitalInfoResponse(soap, tag, id, (ns1__updateDigitalInfoResponse *const*)ptr, "ns1:updateDigitalInfoResponse");
	case SOAP_TYPE_PointerTons1__updateDigitalInfo:
		return soap_out_PointerTons1__updateDigitalInfo(soap, tag, id, (ns1__updateDigitalInfo *const*)ptr, "ns1:updateDigitalInfo");
	case SOAP_TYPE_PointerTons1__findDigitalPermissionResponse:
		return soap_out_PointerTons1__findDigitalPermissionResponse(soap, tag, id, (ns1__findDigitalPermissionResponse *const*)ptr, "ns1:findDigitalPermissionResponse");
	case SOAP_TYPE_PointerTons1__findDigitalPermission:
		return soap_out_PointerTons1__findDigitalPermission(soap, tag, id, (ns1__findDigitalPermission *const*)ptr, "ns1:findDigitalPermission");
	case SOAP_TYPE_PointerTons1__assignPermissionResponse:
		return soap_out_PointerTons1__assignPermissionResponse(soap, tag, id, (ns1__assignPermissionResponse *const*)ptr, "ns1:assignPermissionResponse");
	case SOAP_TYPE_PointerTons1__assignPermission:
		return soap_out_PointerTons1__assignPermission(soap, tag, id, (ns1__assignPermission *const*)ptr, "ns1:assignPermission");
	case SOAP_TYPE_PointerTons1__findAssignedPermissionResponse:
		return soap_out_PointerTons1__findAssignedPermissionResponse(soap, tag, id, (ns1__findAssignedPermissionResponse *const*)ptr, "ns1:findAssignedPermissionResponse");
	case SOAP_TYPE_PointerTons1__findAssignedPermission:
		return soap_out_PointerTons1__findAssignedPermission(soap, tag, id, (ns1__findAssignedPermission *const*)ptr, "ns1:findAssignedPermission");
	case SOAP_TYPE_PointerTons1__findDigitalInfoResponse:
		return soap_out_PointerTons1__findDigitalInfoResponse(soap, tag, id, (ns1__findDigitalInfoResponse *const*)ptr, "ns1:findDigitalInfoResponse");
	case SOAP_TYPE_PointerTons1__findDigitalInfo:
		return soap_out_PointerTons1__findDigitalInfo(soap, tag, id, (ns1__findDigitalInfo *const*)ptr, "ns1:findDigitalInfo");
	case SOAP_TYPE_PointerTons1__deleteDigitalInfoResponse:
		return soap_out_PointerTons1__deleteDigitalInfoResponse(soap, tag, id, (ns1__deleteDigitalInfoResponse *const*)ptr, "ns1:deleteDigitalInfoResponse");
	case SOAP_TYPE_PointerTons1__deleteDigitalInfo:
		return soap_out_PointerTons1__deleteDigitalInfo(soap, tag, id, (ns1__deleteDigitalInfo *const*)ptr, "ns1:deleteDigitalInfo");
	case SOAP_TYPE_PointerTons1__requestPermissionResponse:
		return soap_out_PointerTons1__requestPermissionResponse(soap, tag, id, (ns1__requestPermissionResponse *const*)ptr, "ns1:requestPermissionResponse");
	case SOAP_TYPE_PointerTons1__requestPermission:
		return soap_out_PointerTons1__requestPermission(soap, tag, id, (ns1__requestPermission *const*)ptr, "ns1:requestPermission");
	case SOAP_TYPE_PointerTons1__changePasswordResponse:
		return soap_out_PointerTons1__changePasswordResponse(soap, tag, id, (ns1__changePasswordResponse *const*)ptr, "ns1:changePasswordResponse");
	case SOAP_TYPE_PointerTons1__changePassword:
		return soap_out_PointerTons1__changePassword(soap, tag, id, (ns1__changePassword *const*)ptr, "ns1:changePassword");
	case SOAP_TYPE_PointerTons1__findUserByGingkoIdResponse:
		return soap_out_PointerTons1__findUserByGingkoIdResponse(soap, tag, id, (ns1__findUserByGingkoIdResponse *const*)ptr, "ns1:findUserByGingkoIdResponse");
	case SOAP_TYPE_PointerTons1__findUserByGingkoId:
		return soap_out_PointerTons1__findUserByGingkoId(soap, tag, id, (ns1__findUserByGingkoId *const*)ptr, "ns1:findUserByGingkoId");
	case SOAP_TYPE_PointerTons1__searchUsersResponse:
		return soap_out_PointerTons1__searchUsersResponse(soap, tag, id, (ns1__searchUsersResponse *const*)ptr, "ns1:searchUsersResponse");
	case SOAP_TYPE_PointerTons1__searchUsers:
		return soap_out_PointerTons1__searchUsers(soap, tag, id, (ns1__searchUsers *const*)ptr, "ns1:searchUsers");
	case SOAP_TYPE_PointerTons1__findUserByLoginIdResponse:
		return soap_out_PointerTons1__findUserByLoginIdResponse(soap, tag, id, (ns1__findUserByLoginIdResponse *const*)ptr, "ns1:findUserByLoginIdResponse");
	case SOAP_TYPE_PointerTons1__findUserByLoginId:
		return soap_out_PointerTons1__findUserByLoginId(soap, tag, id, (ns1__findUserByLoginId *const*)ptr, "ns1:findUserByLoginId");
	case SOAP_TYPE_PointerTons1__bindingGingkoUserResponse:
		return soap_out_PointerTons1__bindingGingkoUserResponse(soap, tag, id, (ns1__bindingGingkoUserResponse *const*)ptr, "ns1:bindingGingkoUserResponse");
	case SOAP_TYPE_PointerTons1__bindingGingkoUser:
		return soap_out_PointerTons1__bindingGingkoUser(soap, tag, id, (ns1__bindingGingkoUser *const*)ptr, "ns1:bindingGingkoUser");
	case SOAP_TYPE_PointerTons1__findGingkoUnitInfoResponse:
		return soap_out_PointerTons1__findGingkoUnitInfoResponse(soap, tag, id, (ns1__findGingkoUnitInfoResponse *const*)ptr, "ns1:findGingkoUnitInfoResponse");
	case SOAP_TYPE_PointerTons1__findGingkoUnitInfo:
		return soap_out_PointerTons1__findGingkoUnitInfo(soap, tag, id, (ns1__findGingkoUnitInfo *const*)ptr, "ns1:findGingkoUnitInfo");
	case SOAP_TYPE_PointerTons1__registerThisUnitResponse:
		return soap_out_PointerTons1__registerThisUnitResponse(soap, tag, id, (ns1__registerThisUnitResponse *const*)ptr, "ns1:registerThisUnitResponse");
	case SOAP_TYPE_PointerTons1__registerThisUnit:
		return soap_out_PointerTons1__registerThisUnit(soap, tag, id, (ns1__registerThisUnit *const*)ptr, "ns1:registerThisUnit");
	case SOAP_TYPE_PointerTons1__checkTokenResponse:
		return soap_out_PointerTons1__checkTokenResponse(soap, tag, id, (ns1__checkTokenResponse *const*)ptr, "ns1:checkTokenResponse");
	case SOAP_TYPE_PointerTons1__checkToken:
		return soap_out_PointerTons1__checkToken(soap, tag, id, (ns1__checkToken *const*)ptr, "ns1:checkToken");
	case SOAP_TYPE_PointerTons1__newGingkoIdResponse:
		return soap_out_PointerTons1__newGingkoIdResponse(soap, tag, id, (ns1__newGingkoIdResponse *const*)ptr, "ns1:newGingkoIdResponse");
	case SOAP_TYPE_PointerTons1__newGingkoId:
		return soap_out_PointerTons1__newGingkoId(soap, tag, id, (ns1__newGingkoId *const*)ptr, "ns1:newGingkoId");
	case SOAP_TYPE_PointerTons1__gingkoVersionResponse:
		return soap_out_PointerTons1__gingkoVersionResponse(soap, tag, id, (ns1__gingkoVersionResponse *const*)ptr, "ns1:gingkoVersionResponse");
	case SOAP_TYPE_PointerTons1__gingkoVersion:
		return soap_out_PointerTons1__gingkoVersion(soap, tag, id, (ns1__gingkoVersion *const*)ptr, "ns1:gingkoVersion");
	case SOAP_TYPE_PointerTons1__userLoginResponse:
		return soap_out_PointerTons1__userLoginResponse(soap, tag, id, (ns1__userLoginResponse *const*)ptr, "ns1:userLoginResponse");
	case SOAP_TYPE_PointerTons1__userLogin:
		return soap_out_PointerTons1__userLogin(soap, tag, id, (ns1__userLogin *const*)ptr, "ns1:userLogin");
	case SOAP_TYPE_PointerTons1__registerUserResponse:
		return soap_out_PointerTons1__registerUserResponse(soap, tag, id, (ns1__registerUserResponse *const*)ptr, "ns1:registerUserResponse");
	case SOAP_TYPE_PointerTons1__registerUser:
		return soap_out_PointerTons1__registerUser(soap, tag, id, (ns1__registerUser *const*)ptr, "ns1:registerUser");
	case SOAP_TYPE_PointerTons1__gingkoUserListPack:
		return soap_out_PointerTons1__gingkoUserListPack(soap, tag, id, (ns1__gingkoUserListPack *const*)ptr, "ns1:gingkoUserListPack");
	case SOAP_TYPE_PointerTons1__companyUnit:
		return soap_out_PointerTons1__companyUnit(soap, tag, id, (ns1__companyUnit *const*)ptr, "ns1:companyUnit");
	case SOAP_TYPE_PointerTons1__gingkoUnitPack:
		return soap_out_PointerTons1__gingkoUnitPack(soap, tag, id, (ns1__gingkoUnitPack *const*)ptr, "ns1:gingkoUnitPack");
	case SOAP_TYPE_PointerTons1__gingkoPermissionListPack:
		return soap_out_PointerTons1__gingkoPermissionListPack(soap, tag, id, (ns1__gingkoPermissionListPack *const*)ptr, "ns1:gingkoPermissionListPack");
	case SOAP_TYPE_PointerTons1__digitalContent:
		return soap_out_PointerTons1__digitalContent(soap, tag, id, (ns1__digitalContent *const*)ptr, "ns1:digitalContent");
	case SOAP_TYPE_PointerTons1__gingkoDigitalPack:
		return soap_out_PointerTons1__gingkoDigitalPack(soap, tag, id, (ns1__gingkoDigitalPack *const*)ptr, "ns1:gingkoDigitalPack");
	case SOAP_TYPE_PointerTons1__gingkoPermission:
		return soap_out_PointerTons1__gingkoPermission(soap, tag, id, (ns1__gingkoPermission *const*)ptr, "ns1:gingkoPermission");
	case SOAP_TYPE_PointerTons1__gingkoPermissionPack:
		return soap_out_PointerTons1__gingkoPermissionPack(soap, tag, id, (ns1__gingkoPermissionPack *const*)ptr, "ns1:gingkoPermissionPack");
	case SOAP_TYPE_PointerTons1__stringPack:
		return soap_out_PointerTons1__stringPack(soap, tag, id, (ns1__stringPack *const*)ptr, "ns1:stringPack");
	case SOAP_TYPE_PointerTons1__gingkoVersionPack:
		return soap_out_PointerTons1__gingkoVersionPack(soap, tag, id, (ns1__gingkoVersionPack *const*)ptr, "ns1:gingkoVersionPack");
	case SOAP_TYPE_PointerTotime:
		return soap_out_PointerTotime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerTons1__soapPackStatusEnum:
		return soap_out_PointerTons1__soapPackStatusEnum(soap, tag, id, (enum ns1__soapPackStatusEnum *const*)ptr, "ns1:soapPackStatusEnum");
	case SOAP_TYPE_PointerTons1__gingkoUser:
		return soap_out_PointerTons1__gingkoUser(soap, tag, id, (ns1__gingkoUser *const*)ptr, "ns1:gingkoUser");
	case SOAP_TYPE_PointerTons1__gingkoUserPack:
		return soap_out_PointerTons1__gingkoUserPack(soap, tag, id, (ns1__gingkoUserPack *const*)ptr, "ns1:gingkoUserPack");
	case SOAP_TYPE_PointerTostd__wstring:
		return soap_out_PointerTostd__wstring(soap, tag, id, (std::wstring *const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_std__wstring:
		soap_serialize_std__wstring(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_ns1__gingkoUserListPack:
		((ns1__gingkoUserListPack *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__searchUsersResponse:
		((ns1__searchUsersResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__searchUsers:
		((ns1__searchUsers *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__registerThisUnitResponse:
		((ns1__registerThisUnitResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__registerThisUnit:
		((ns1__registerThisUnit *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__companyUnit:
		((ns1__companyUnit *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__gingkoUnitPack:
		((ns1__gingkoUnitPack *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__findGingkoUnitInfoResponse:
		((ns1__findGingkoUnitInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__findGingkoUnitInfo:
		((ns1__findGingkoUnitInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__findDigitalPermission:
		((ns1__findDigitalPermission *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__createDigitalInfo:
		((ns1__createDigitalInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__findDigitalInfoResponse:
		((ns1__findDigitalInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__findAssignedPermissionResponse:
		((ns1__findAssignedPermissionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__deleteDigitalInfoResponse:
		((ns1__deleteDigitalInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__gingkoPermissionListPack:
		((ns1__gingkoPermissionListPack *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__findDigitalPermissionResponse:
		((ns1__findDigitalPermissionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__updateDigitalInfoResponse:
		((ns1__updateDigitalInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__deleteDigitalInfo:
		((ns1__deleteDigitalInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__digitalContent:
		((ns1__digitalContent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__gingkoDigitalPack:
		((ns1__gingkoDigitalPack *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__createDigitalInfoResponse:
		((ns1__createDigitalInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__findAssignedPermission:
		((ns1__findAssignedPermission *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__updateDigitalInfo:
		((ns1__updateDigitalInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__findDigitalInfo:
		((ns1__findDigitalInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__bindingGingkoUserResponse:
		((ns1__bindingGingkoUserResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__findUserByLoginIdResponse:
		((ns1__findUserByLoginIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__findUserByLoginId:
		((ns1__findUserByLoginId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__findUserByGingkoIdResponse:
		((ns1__findUserByGingkoIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__findUserByGingkoId:
		((ns1__findUserByGingkoId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__changePasswordResponse:
		((ns1__changePasswordResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__changePassword:
		((ns1__changePassword *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__bindingGingkoUser:
		((ns1__bindingGingkoUser *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__requestPermissionResponse:
		((ns1__requestPermissionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__requestPermission:
		((ns1__requestPermission *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__gingkoPermission:
		((ns1__gingkoPermission *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__gingkoPermissionPack:
		((ns1__gingkoPermissionPack *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__assignPermissionResponse:
		((ns1__assignPermissionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__assignPermission:
		((ns1__assignPermission *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__checkTokenResponse:
		((ns1__checkTokenResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__checkToken:
		((ns1__checkToken *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__stringPack:
		((ns1__stringPack *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__newGingkoIdResponse:
		((ns1__newGingkoIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__newGingkoId:
		((ns1__newGingkoId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__gingkoVersionPack:
		((ns1__gingkoVersionPack *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__gingkoVersionResponse:
		((ns1__gingkoVersionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__gingkoVersion:
		((ns1__gingkoVersion *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__userLoginResponse:
		((ns1__userLoginResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__userLogin:
		((ns1__userLogin *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__gingkoUser:
		((ns1__gingkoUser *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__gingkoUserPack:
		((ns1__gingkoUserPack *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__registerUserResponse:
		((ns1__registerUserResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__registerUser:
		((ns1__registerUser *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns1__createDigitalInfo:
		soap_serialize___ns1__createDigitalInfo(soap, (const struct __ns1__createDigitalInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__updateDigitalInfo:
		soap_serialize___ns1__updateDigitalInfo(soap, (const struct __ns1__updateDigitalInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__findDigitalPermission:
		soap_serialize___ns1__findDigitalPermission(soap, (const struct __ns1__findDigitalPermission *)ptr);
		break;
	case SOAP_TYPE___ns1__assignPermission:
		soap_serialize___ns1__assignPermission(soap, (const struct __ns1__assignPermission *)ptr);
		break;
	case SOAP_TYPE___ns1__findAssignedPermission:
		soap_serialize___ns1__findAssignedPermission(soap, (const struct __ns1__findAssignedPermission *)ptr);
		break;
	case SOAP_TYPE___ns1__findDigitalInfo:
		soap_serialize___ns1__findDigitalInfo(soap, (const struct __ns1__findDigitalInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__deleteDigitalInfo:
		soap_serialize___ns1__deleteDigitalInfo(soap, (const struct __ns1__deleteDigitalInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__requestPermission:
		soap_serialize___ns1__requestPermission(soap, (const struct __ns1__requestPermission *)ptr);
		break;
	case SOAP_TYPE___ns1__changePassword:
		soap_serialize___ns1__changePassword(soap, (const struct __ns1__changePassword *)ptr);
		break;
	case SOAP_TYPE___ns1__findUserByGingkoId:
		soap_serialize___ns1__findUserByGingkoId(soap, (const struct __ns1__findUserByGingkoId *)ptr);
		break;
	case SOAP_TYPE___ns1__searchUsers:
		soap_serialize___ns1__searchUsers(soap, (const struct __ns1__searchUsers *)ptr);
		break;
	case SOAP_TYPE___ns1__findUserByLoginId:
		soap_serialize___ns1__findUserByLoginId(soap, (const struct __ns1__findUserByLoginId *)ptr);
		break;
	case SOAP_TYPE___ns1__bindingGingkoUser:
		soap_serialize___ns1__bindingGingkoUser(soap, (const struct __ns1__bindingGingkoUser *)ptr);
		break;
	case SOAP_TYPE___ns1__findGingkoUnitInfo:
		soap_serialize___ns1__findGingkoUnitInfo(soap, (const struct __ns1__findGingkoUnitInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__registerThisUnit:
		soap_serialize___ns1__registerThisUnit(soap, (const struct __ns1__registerThisUnit *)ptr);
		break;
	case SOAP_TYPE___ns1__checkToken:
		soap_serialize___ns1__checkToken(soap, (const struct __ns1__checkToken *)ptr);
		break;
	case SOAP_TYPE___ns1__newGingkoId:
		soap_serialize___ns1__newGingkoId(soap, (const struct __ns1__newGingkoId *)ptr);
		break;
	case SOAP_TYPE___ns1__gingkoVersion:
		soap_serialize___ns1__gingkoVersion(soap, (const struct __ns1__gingkoVersion *)ptr);
		break;
	case SOAP_TYPE___ns1__userLogin:
		soap_serialize___ns1__userLogin(soap, (const struct __ns1__userLogin *)ptr);
		break;
	case SOAP_TYPE___ns1__registerUser:
		soap_serialize___ns1__registerUser(soap, (const struct __ns1__registerUser *)ptr);
		break;
	case SOAP_TYPE_PointerTons1__createDigitalInfoResponse:
		soap_serialize_PointerTons1__createDigitalInfoResponse(soap, (ns1__createDigitalInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__createDigitalInfo:
		soap_serialize_PointerTons1__createDigitalInfo(soap, (ns1__createDigitalInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__updateDigitalInfoResponse:
		soap_serialize_PointerTons1__updateDigitalInfoResponse(soap, (ns1__updateDigitalInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__updateDigitalInfo:
		soap_serialize_PointerTons1__updateDigitalInfo(soap, (ns1__updateDigitalInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__findDigitalPermissionResponse:
		soap_serialize_PointerTons1__findDigitalPermissionResponse(soap, (ns1__findDigitalPermissionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__findDigitalPermission:
		soap_serialize_PointerTons1__findDigitalPermission(soap, (ns1__findDigitalPermission *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__assignPermissionResponse:
		soap_serialize_PointerTons1__assignPermissionResponse(soap, (ns1__assignPermissionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__assignPermission:
		soap_serialize_PointerTons1__assignPermission(soap, (ns1__assignPermission *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__findAssignedPermissionResponse:
		soap_serialize_PointerTons1__findAssignedPermissionResponse(soap, (ns1__findAssignedPermissionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__findAssignedPermission:
		soap_serialize_PointerTons1__findAssignedPermission(soap, (ns1__findAssignedPermission *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__findDigitalInfoResponse:
		soap_serialize_PointerTons1__findDigitalInfoResponse(soap, (ns1__findDigitalInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__findDigitalInfo:
		soap_serialize_PointerTons1__findDigitalInfo(soap, (ns1__findDigitalInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__deleteDigitalInfoResponse:
		soap_serialize_PointerTons1__deleteDigitalInfoResponse(soap, (ns1__deleteDigitalInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__deleteDigitalInfo:
		soap_serialize_PointerTons1__deleteDigitalInfo(soap, (ns1__deleteDigitalInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__requestPermissionResponse:
		soap_serialize_PointerTons1__requestPermissionResponse(soap, (ns1__requestPermissionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__requestPermission:
		soap_serialize_PointerTons1__requestPermission(soap, (ns1__requestPermission *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__changePasswordResponse:
		soap_serialize_PointerTons1__changePasswordResponse(soap, (ns1__changePasswordResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__changePassword:
		soap_serialize_PointerTons1__changePassword(soap, (ns1__changePassword *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__findUserByGingkoIdResponse:
		soap_serialize_PointerTons1__findUserByGingkoIdResponse(soap, (ns1__findUserByGingkoIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__findUserByGingkoId:
		soap_serialize_PointerTons1__findUserByGingkoId(soap, (ns1__findUserByGingkoId *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__searchUsersResponse:
		soap_serialize_PointerTons1__searchUsersResponse(soap, (ns1__searchUsersResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__searchUsers:
		soap_serialize_PointerTons1__searchUsers(soap, (ns1__searchUsers *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__findUserByLoginIdResponse:
		soap_serialize_PointerTons1__findUserByLoginIdResponse(soap, (ns1__findUserByLoginIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__findUserByLoginId:
		soap_serialize_PointerTons1__findUserByLoginId(soap, (ns1__findUserByLoginId *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__bindingGingkoUserResponse:
		soap_serialize_PointerTons1__bindingGingkoUserResponse(soap, (ns1__bindingGingkoUserResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__bindingGingkoUser:
		soap_serialize_PointerTons1__bindingGingkoUser(soap, (ns1__bindingGingkoUser *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__findGingkoUnitInfoResponse:
		soap_serialize_PointerTons1__findGingkoUnitInfoResponse(soap, (ns1__findGingkoUnitInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__findGingkoUnitInfo:
		soap_serialize_PointerTons1__findGingkoUnitInfo(soap, (ns1__findGingkoUnitInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__registerThisUnitResponse:
		soap_serialize_PointerTons1__registerThisUnitResponse(soap, (ns1__registerThisUnitResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__registerThisUnit:
		soap_serialize_PointerTons1__registerThisUnit(soap, (ns1__registerThisUnit *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__checkTokenResponse:
		soap_serialize_PointerTons1__checkTokenResponse(soap, (ns1__checkTokenResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__checkToken:
		soap_serialize_PointerTons1__checkToken(soap, (ns1__checkToken *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__newGingkoIdResponse:
		soap_serialize_PointerTons1__newGingkoIdResponse(soap, (ns1__newGingkoIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__newGingkoId:
		soap_serialize_PointerTons1__newGingkoId(soap, (ns1__newGingkoId *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__gingkoVersionResponse:
		soap_serialize_PointerTons1__gingkoVersionResponse(soap, (ns1__gingkoVersionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__gingkoVersion:
		soap_serialize_PointerTons1__gingkoVersion(soap, (ns1__gingkoVersion *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__userLoginResponse:
		soap_serialize_PointerTons1__userLoginResponse(soap, (ns1__userLoginResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__userLogin:
		soap_serialize_PointerTons1__userLogin(soap, (ns1__userLogin *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__registerUserResponse:
		soap_serialize_PointerTons1__registerUserResponse(soap, (ns1__registerUserResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__registerUser:
		soap_serialize_PointerTons1__registerUser(soap, (ns1__registerUser *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__gingkoUserListPack:
		soap_serialize_PointerTons1__gingkoUserListPack(soap, (ns1__gingkoUserListPack *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__companyUnit:
		soap_serialize_PointerTons1__companyUnit(soap, (ns1__companyUnit *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__gingkoUnitPack:
		soap_serialize_PointerTons1__gingkoUnitPack(soap, (ns1__gingkoUnitPack *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__gingkoPermissionListPack:
		soap_serialize_PointerTons1__gingkoPermissionListPack(soap, (ns1__gingkoPermissionListPack *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__digitalContent:
		soap_serialize_PointerTons1__digitalContent(soap, (ns1__digitalContent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__gingkoDigitalPack:
		soap_serialize_PointerTons1__gingkoDigitalPack(soap, (ns1__gingkoDigitalPack *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__gingkoPermission:
		soap_serialize_PointerTons1__gingkoPermission(soap, (ns1__gingkoPermission *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__gingkoPermissionPack:
		soap_serialize_PointerTons1__gingkoPermissionPack(soap, (ns1__gingkoPermissionPack *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__stringPack:
		soap_serialize_PointerTons1__stringPack(soap, (ns1__stringPack *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__gingkoVersionPack:
		soap_serialize_PointerTons1__gingkoVersionPack(soap, (ns1__gingkoVersionPack *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotime:
		soap_serialize_PointerTotime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__soapPackStatusEnum:
		soap_serialize_PointerTons1__soapPackStatusEnum(soap, (enum ns1__soapPackStatusEnum *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__gingkoUser:
		soap_serialize_PointerTons1__gingkoUser(soap, (ns1__gingkoUser *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__gingkoUserPack:
		soap_serialize_PointerTons1__gingkoUserPack(soap, (ns1__gingkoUserPack *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__wstring:
		soap_serialize_PointerTostd__wstring(soap, (std::wstring *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_std__wstring:
		return (void*)soap_instantiate_std__wstring(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__registerUser:
		return (void*)soap_instantiate_ns1__registerUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__registerUserResponse:
		return (void*)soap_instantiate_ns1__registerUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__gingkoUserPack:
		return (void*)soap_instantiate_ns1__gingkoUserPack(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__gingkoUser:
		return (void*)soap_instantiate_ns1__gingkoUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__userLogin:
		return (void*)soap_instantiate_ns1__userLogin(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__userLoginResponse:
		return (void*)soap_instantiate_ns1__userLoginResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__gingkoVersion:
		return (void*)soap_instantiate_ns1__gingkoVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__gingkoVersionResponse:
		return (void*)soap_instantiate_ns1__gingkoVersionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__gingkoVersionPack:
		return (void*)soap_instantiate_ns1__gingkoVersionPack(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__newGingkoId:
		return (void*)soap_instantiate_ns1__newGingkoId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__newGingkoIdResponse:
		return (void*)soap_instantiate_ns1__newGingkoIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__stringPack:
		return (void*)soap_instantiate_ns1__stringPack(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__checkToken:
		return (void*)soap_instantiate_ns1__checkToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__checkTokenResponse:
		return (void*)soap_instantiate_ns1__checkTokenResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__assignPermission:
		return (void*)soap_instantiate_ns1__assignPermission(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__assignPermissionResponse:
		return (void*)soap_instantiate_ns1__assignPermissionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__gingkoPermissionPack:
		return (void*)soap_instantiate_ns1__gingkoPermissionPack(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__gingkoPermission:
		return (void*)soap_instantiate_ns1__gingkoPermission(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__requestPermission:
		return (void*)soap_instantiate_ns1__requestPermission(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__requestPermissionResponse:
		return (void*)soap_instantiate_ns1__requestPermissionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__bindingGingkoUser:
		return (void*)soap_instantiate_ns1__bindingGingkoUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__changePassword:
		return (void*)soap_instantiate_ns1__changePassword(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__changePasswordResponse:
		return (void*)soap_instantiate_ns1__changePasswordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__findUserByGingkoId:
		return (void*)soap_instantiate_ns1__findUserByGingkoId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__findUserByGingkoIdResponse:
		return (void*)soap_instantiate_ns1__findUserByGingkoIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__findUserByLoginId:
		return (void*)soap_instantiate_ns1__findUserByLoginId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__findUserByLoginIdResponse:
		return (void*)soap_instantiate_ns1__findUserByLoginIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__bindingGingkoUserResponse:
		return (void*)soap_instantiate_ns1__bindingGingkoUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__findDigitalInfo:
		return (void*)soap_instantiate_ns1__findDigitalInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__updateDigitalInfo:
		return (void*)soap_instantiate_ns1__updateDigitalInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__findAssignedPermission:
		return (void*)soap_instantiate_ns1__findAssignedPermission(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__createDigitalInfoResponse:
		return (void*)soap_instantiate_ns1__createDigitalInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__gingkoDigitalPack:
		return (void*)soap_instantiate_ns1__gingkoDigitalPack(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__digitalContent:
		return (void*)soap_instantiate_ns1__digitalContent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteDigitalInfo:
		return (void*)soap_instantiate_ns1__deleteDigitalInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__updateDigitalInfoResponse:
		return (void*)soap_instantiate_ns1__updateDigitalInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__findDigitalPermissionResponse:
		return (void*)soap_instantiate_ns1__findDigitalPermissionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__gingkoPermissionListPack:
		return (void*)soap_instantiate_ns1__gingkoPermissionListPack(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteDigitalInfoResponse:
		return (void*)soap_instantiate_ns1__deleteDigitalInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__findAssignedPermissionResponse:
		return (void*)soap_instantiate_ns1__findAssignedPermissionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__findDigitalInfoResponse:
		return (void*)soap_instantiate_ns1__findDigitalInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__createDigitalInfo:
		return (void*)soap_instantiate_ns1__createDigitalInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__findDigitalPermission:
		return (void*)soap_instantiate_ns1__findDigitalPermission(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__findGingkoUnitInfo:
		return (void*)soap_instantiate_ns1__findGingkoUnitInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__findGingkoUnitInfoResponse:
		return (void*)soap_instantiate_ns1__findGingkoUnitInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__gingkoUnitPack:
		return (void*)soap_instantiate_ns1__gingkoUnitPack(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__companyUnit:
		return (void*)soap_instantiate_ns1__companyUnit(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__registerThisUnit:
		return (void*)soap_instantiate_ns1__registerThisUnit(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__registerThisUnitResponse:
		return (void*)soap_instantiate_ns1__registerThisUnitResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__searchUsers:
		return (void*)soap_instantiate_ns1__searchUsers(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__searchUsersResponse:
		return (void*)soap_instantiate_ns1__searchUsersResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__gingkoUserListPack:
		return (void*)soap_instantiate_ns1__gingkoUserListPack(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__registerUser:
		return (void*)soap_instantiate___ns1__registerUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__userLogin:
		return (void*)soap_instantiate___ns1__userLogin(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__gingkoVersion:
		return (void*)soap_instantiate___ns1__gingkoVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__newGingkoId:
		return (void*)soap_instantiate___ns1__newGingkoId(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__checkToken:
		return (void*)soap_instantiate___ns1__checkToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__registerThisUnit:
		return (void*)soap_instantiate___ns1__registerThisUnit(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__findGingkoUnitInfo:
		return (void*)soap_instantiate___ns1__findGingkoUnitInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__bindingGingkoUser:
		return (void*)soap_instantiate___ns1__bindingGingkoUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__findUserByLoginId:
		return (void*)soap_instantiate___ns1__findUserByLoginId(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__searchUsers:
		return (void*)soap_instantiate___ns1__searchUsers(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__findUserByGingkoId:
		return (void*)soap_instantiate___ns1__findUserByGingkoId(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__changePassword:
		return (void*)soap_instantiate___ns1__changePassword(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__requestPermission:
		return (void*)soap_instantiate___ns1__requestPermission(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__deleteDigitalInfo:
		return (void*)soap_instantiate___ns1__deleteDigitalInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__findDigitalInfo:
		return (void*)soap_instantiate___ns1__findDigitalInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__findAssignedPermission:
		return (void*)soap_instantiate___ns1__findAssignedPermission(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__assignPermission:
		return (void*)soap_instantiate___ns1__assignPermission(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__findDigitalPermission:
		return (void*)soap_instantiate___ns1__findDigitalPermission(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__updateDigitalInfo:
		return (void*)soap_instantiate___ns1__updateDigitalInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__createDigitalInfo:
		return (void*)soap_instantiate___ns1__createDigitalInfo(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__gingkoUser:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__gingkoUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__gingkoPermission:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__gingkoPermission(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__wstring:
		if (p->size < 0)
			delete (std::wstring*)p->ptr;
		else
			delete[] (std::wstring*)p->ptr;
		break;
	case SOAP_TYPE_ns1__registerUser:
		if (p->size < 0)
			delete (ns1__registerUser*)p->ptr;
		else
			delete[] (ns1__registerUser*)p->ptr;
		break;
	case SOAP_TYPE_ns1__registerUserResponse:
		if (p->size < 0)
			delete (ns1__registerUserResponse*)p->ptr;
		else
			delete[] (ns1__registerUserResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__gingkoUserPack:
		if (p->size < 0)
			delete (ns1__gingkoUserPack*)p->ptr;
		else
			delete[] (ns1__gingkoUserPack*)p->ptr;
		break;
	case SOAP_TYPE_ns1__gingkoUser:
		if (p->size < 0)
			delete (ns1__gingkoUser*)p->ptr;
		else
			delete[] (ns1__gingkoUser*)p->ptr;
		break;
	case SOAP_TYPE_ns1__userLogin:
		if (p->size < 0)
			delete (ns1__userLogin*)p->ptr;
		else
			delete[] (ns1__userLogin*)p->ptr;
		break;
	case SOAP_TYPE_ns1__userLoginResponse:
		if (p->size < 0)
			delete (ns1__userLoginResponse*)p->ptr;
		else
			delete[] (ns1__userLoginResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__gingkoVersion:
		if (p->size < 0)
			delete (ns1__gingkoVersion*)p->ptr;
		else
			delete[] (ns1__gingkoVersion*)p->ptr;
		break;
	case SOAP_TYPE_ns1__gingkoVersionResponse:
		if (p->size < 0)
			delete (ns1__gingkoVersionResponse*)p->ptr;
		else
			delete[] (ns1__gingkoVersionResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__gingkoVersionPack:
		if (p->size < 0)
			delete (ns1__gingkoVersionPack*)p->ptr;
		else
			delete[] (ns1__gingkoVersionPack*)p->ptr;
		break;
	case SOAP_TYPE_ns1__newGingkoId:
		if (p->size < 0)
			delete (ns1__newGingkoId*)p->ptr;
		else
			delete[] (ns1__newGingkoId*)p->ptr;
		break;
	case SOAP_TYPE_ns1__newGingkoIdResponse:
		if (p->size < 0)
			delete (ns1__newGingkoIdResponse*)p->ptr;
		else
			delete[] (ns1__newGingkoIdResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__stringPack:
		if (p->size < 0)
			delete (ns1__stringPack*)p->ptr;
		else
			delete[] (ns1__stringPack*)p->ptr;
		break;
	case SOAP_TYPE_ns1__checkToken:
		if (p->size < 0)
			delete (ns1__checkToken*)p->ptr;
		else
			delete[] (ns1__checkToken*)p->ptr;
		break;
	case SOAP_TYPE_ns1__checkTokenResponse:
		if (p->size < 0)
			delete (ns1__checkTokenResponse*)p->ptr;
		else
			delete[] (ns1__checkTokenResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__assignPermission:
		if (p->size < 0)
			delete (ns1__assignPermission*)p->ptr;
		else
			delete[] (ns1__assignPermission*)p->ptr;
		break;
	case SOAP_TYPE_ns1__assignPermissionResponse:
		if (p->size < 0)
			delete (ns1__assignPermissionResponse*)p->ptr;
		else
			delete[] (ns1__assignPermissionResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__gingkoPermissionPack:
		if (p->size < 0)
			delete (ns1__gingkoPermissionPack*)p->ptr;
		else
			delete[] (ns1__gingkoPermissionPack*)p->ptr;
		break;
	case SOAP_TYPE_ns1__gingkoPermission:
		if (p->size < 0)
			delete (ns1__gingkoPermission*)p->ptr;
		else
			delete[] (ns1__gingkoPermission*)p->ptr;
		break;
	case SOAP_TYPE_ns1__requestPermission:
		if (p->size < 0)
			delete (ns1__requestPermission*)p->ptr;
		else
			delete[] (ns1__requestPermission*)p->ptr;
		break;
	case SOAP_TYPE_ns1__requestPermissionResponse:
		if (p->size < 0)
			delete (ns1__requestPermissionResponse*)p->ptr;
		else
			delete[] (ns1__requestPermissionResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__bindingGingkoUser:
		if (p->size < 0)
			delete (ns1__bindingGingkoUser*)p->ptr;
		else
			delete[] (ns1__bindingGingkoUser*)p->ptr;
		break;
	case SOAP_TYPE_ns1__changePassword:
		if (p->size < 0)
			delete (ns1__changePassword*)p->ptr;
		else
			delete[] (ns1__changePassword*)p->ptr;
		break;
	case SOAP_TYPE_ns1__changePasswordResponse:
		if (p->size < 0)
			delete (ns1__changePasswordResponse*)p->ptr;
		else
			delete[] (ns1__changePasswordResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__findUserByGingkoId:
		if (p->size < 0)
			delete (ns1__findUserByGingkoId*)p->ptr;
		else
			delete[] (ns1__findUserByGingkoId*)p->ptr;
		break;
	case SOAP_TYPE_ns1__findUserByGingkoIdResponse:
		if (p->size < 0)
			delete (ns1__findUserByGingkoIdResponse*)p->ptr;
		else
			delete[] (ns1__findUserByGingkoIdResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__findUserByLoginId:
		if (p->size < 0)
			delete (ns1__findUserByLoginId*)p->ptr;
		else
			delete[] (ns1__findUserByLoginId*)p->ptr;
		break;
	case SOAP_TYPE_ns1__findUserByLoginIdResponse:
		if (p->size < 0)
			delete (ns1__findUserByLoginIdResponse*)p->ptr;
		else
			delete[] (ns1__findUserByLoginIdResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__bindingGingkoUserResponse:
		if (p->size < 0)
			delete (ns1__bindingGingkoUserResponse*)p->ptr;
		else
			delete[] (ns1__bindingGingkoUserResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__findDigitalInfo:
		if (p->size < 0)
			delete (ns1__findDigitalInfo*)p->ptr;
		else
			delete[] (ns1__findDigitalInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns1__updateDigitalInfo:
		if (p->size < 0)
			delete (ns1__updateDigitalInfo*)p->ptr;
		else
			delete[] (ns1__updateDigitalInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns1__findAssignedPermission:
		if (p->size < 0)
			delete (ns1__findAssignedPermission*)p->ptr;
		else
			delete[] (ns1__findAssignedPermission*)p->ptr;
		break;
	case SOAP_TYPE_ns1__createDigitalInfoResponse:
		if (p->size < 0)
			delete (ns1__createDigitalInfoResponse*)p->ptr;
		else
			delete[] (ns1__createDigitalInfoResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__gingkoDigitalPack:
		if (p->size < 0)
			delete (ns1__gingkoDigitalPack*)p->ptr;
		else
			delete[] (ns1__gingkoDigitalPack*)p->ptr;
		break;
	case SOAP_TYPE_ns1__digitalContent:
		if (p->size < 0)
			delete (ns1__digitalContent*)p->ptr;
		else
			delete[] (ns1__digitalContent*)p->ptr;
		break;
	case SOAP_TYPE_ns1__deleteDigitalInfo:
		if (p->size < 0)
			delete (ns1__deleteDigitalInfo*)p->ptr;
		else
			delete[] (ns1__deleteDigitalInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns1__updateDigitalInfoResponse:
		if (p->size < 0)
			delete (ns1__updateDigitalInfoResponse*)p->ptr;
		else
			delete[] (ns1__updateDigitalInfoResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__findDigitalPermissionResponse:
		if (p->size < 0)
			delete (ns1__findDigitalPermissionResponse*)p->ptr;
		else
			delete[] (ns1__findDigitalPermissionResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__gingkoPermissionListPack:
		if (p->size < 0)
			delete (ns1__gingkoPermissionListPack*)p->ptr;
		else
			delete[] (ns1__gingkoPermissionListPack*)p->ptr;
		break;
	case SOAP_TYPE_ns1__deleteDigitalInfoResponse:
		if (p->size < 0)
			delete (ns1__deleteDigitalInfoResponse*)p->ptr;
		else
			delete[] (ns1__deleteDigitalInfoResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__findAssignedPermissionResponse:
		if (p->size < 0)
			delete (ns1__findAssignedPermissionResponse*)p->ptr;
		else
			delete[] (ns1__findAssignedPermissionResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__findDigitalInfoResponse:
		if (p->size < 0)
			delete (ns1__findDigitalInfoResponse*)p->ptr;
		else
			delete[] (ns1__findDigitalInfoResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__createDigitalInfo:
		if (p->size < 0)
			delete (ns1__createDigitalInfo*)p->ptr;
		else
			delete[] (ns1__createDigitalInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns1__findDigitalPermission:
		if (p->size < 0)
			delete (ns1__findDigitalPermission*)p->ptr;
		else
			delete[] (ns1__findDigitalPermission*)p->ptr;
		break;
	case SOAP_TYPE_ns1__findGingkoUnitInfo:
		if (p->size < 0)
			delete (ns1__findGingkoUnitInfo*)p->ptr;
		else
			delete[] (ns1__findGingkoUnitInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns1__findGingkoUnitInfoResponse:
		if (p->size < 0)
			delete (ns1__findGingkoUnitInfoResponse*)p->ptr;
		else
			delete[] (ns1__findGingkoUnitInfoResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__gingkoUnitPack:
		if (p->size < 0)
			delete (ns1__gingkoUnitPack*)p->ptr;
		else
			delete[] (ns1__gingkoUnitPack*)p->ptr;
		break;
	case SOAP_TYPE_ns1__companyUnit:
		if (p->size < 0)
			delete (ns1__companyUnit*)p->ptr;
		else
			delete[] (ns1__companyUnit*)p->ptr;
		break;
	case SOAP_TYPE_ns1__registerThisUnit:
		if (p->size < 0)
			delete (ns1__registerThisUnit*)p->ptr;
		else
			delete[] (ns1__registerThisUnit*)p->ptr;
		break;
	case SOAP_TYPE_ns1__registerThisUnitResponse:
		if (p->size < 0)
			delete (ns1__registerThisUnitResponse*)p->ptr;
		else
			delete[] (ns1__registerThisUnitResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__searchUsers:
		if (p->size < 0)
			delete (ns1__searchUsers*)p->ptr;
		else
			delete[] (ns1__searchUsers*)p->ptr;
		break;
	case SOAP_TYPE_ns1__searchUsersResponse:
		if (p->size < 0)
			delete (ns1__searchUsersResponse*)p->ptr;
		else
			delete[] (ns1__searchUsersResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__gingkoUserListPack:
		if (p->size < 0)
			delete (ns1__gingkoUserListPack*)p->ptr;
		else
			delete[] (ns1__gingkoUserListPack*)p->ptr;
		break;
	case SOAP_TYPE___ns1__registerUser:
		if (p->size < 0)
			delete (struct __ns1__registerUser*)p->ptr;
		else
			delete[] (struct __ns1__registerUser*)p->ptr;
		break;
	case SOAP_TYPE___ns1__userLogin:
		if (p->size < 0)
			delete (struct __ns1__userLogin*)p->ptr;
		else
			delete[] (struct __ns1__userLogin*)p->ptr;
		break;
	case SOAP_TYPE___ns1__gingkoVersion:
		if (p->size < 0)
			delete (struct __ns1__gingkoVersion*)p->ptr;
		else
			delete[] (struct __ns1__gingkoVersion*)p->ptr;
		break;
	case SOAP_TYPE___ns1__newGingkoId:
		if (p->size < 0)
			delete (struct __ns1__newGingkoId*)p->ptr;
		else
			delete[] (struct __ns1__newGingkoId*)p->ptr;
		break;
	case SOAP_TYPE___ns1__checkToken:
		if (p->size < 0)
			delete (struct __ns1__checkToken*)p->ptr;
		else
			delete[] (struct __ns1__checkToken*)p->ptr;
		break;
	case SOAP_TYPE___ns1__registerThisUnit:
		if (p->size < 0)
			delete (struct __ns1__registerThisUnit*)p->ptr;
		else
			delete[] (struct __ns1__registerThisUnit*)p->ptr;
		break;
	case SOAP_TYPE___ns1__findGingkoUnitInfo:
		if (p->size < 0)
			delete (struct __ns1__findGingkoUnitInfo*)p->ptr;
		else
			delete[] (struct __ns1__findGingkoUnitInfo*)p->ptr;
		break;
	case SOAP_TYPE___ns1__bindingGingkoUser:
		if (p->size < 0)
			delete (struct __ns1__bindingGingkoUser*)p->ptr;
		else
			delete[] (struct __ns1__bindingGingkoUser*)p->ptr;
		break;
	case SOAP_TYPE___ns1__findUserByLoginId:
		if (p->size < 0)
			delete (struct __ns1__findUserByLoginId*)p->ptr;
		else
			delete[] (struct __ns1__findUserByLoginId*)p->ptr;
		break;
	case SOAP_TYPE___ns1__searchUsers:
		if (p->size < 0)
			delete (struct __ns1__searchUsers*)p->ptr;
		else
			delete[] (struct __ns1__searchUsers*)p->ptr;
		break;
	case SOAP_TYPE___ns1__findUserByGingkoId:
		if (p->size < 0)
			delete (struct __ns1__findUserByGingkoId*)p->ptr;
		else
			delete[] (struct __ns1__findUserByGingkoId*)p->ptr;
		break;
	case SOAP_TYPE___ns1__changePassword:
		if (p->size < 0)
			delete (struct __ns1__changePassword*)p->ptr;
		else
			delete[] (struct __ns1__changePassword*)p->ptr;
		break;
	case SOAP_TYPE___ns1__requestPermission:
		if (p->size < 0)
			delete (struct __ns1__requestPermission*)p->ptr;
		else
			delete[] (struct __ns1__requestPermission*)p->ptr;
		break;
	case SOAP_TYPE___ns1__deleteDigitalInfo:
		if (p->size < 0)
			delete (struct __ns1__deleteDigitalInfo*)p->ptr;
		else
			delete[] (struct __ns1__deleteDigitalInfo*)p->ptr;
		break;
	case SOAP_TYPE___ns1__findDigitalInfo:
		if (p->size < 0)
			delete (struct __ns1__findDigitalInfo*)p->ptr;
		else
			delete[] (struct __ns1__findDigitalInfo*)p->ptr;
		break;
	case SOAP_TYPE___ns1__findAssignedPermission:
		if (p->size < 0)
			delete (struct __ns1__findAssignedPermission*)p->ptr;
		else
			delete[] (struct __ns1__findAssignedPermission*)p->ptr;
		break;
	case SOAP_TYPE___ns1__assignPermission:
		if (p->size < 0)
			delete (struct __ns1__assignPermission*)p->ptr;
		else
			delete[] (struct __ns1__assignPermission*)p->ptr;
		break;
	case SOAP_TYPE___ns1__findDigitalPermission:
		if (p->size < 0)
			delete (struct __ns1__findDigitalPermission*)p->ptr;
		else
			delete[] (struct __ns1__findDigitalPermission*)p->ptr;
		break;
	case SOAP_TYPE___ns1__updateDigitalInfo:
		if (p->size < 0)
			delete (struct __ns1__updateDigitalInfo*)p->ptr;
		else
			delete[] (struct __ns1__updateDigitalInfo*)p->ptr;
		break;
	case SOAP_TYPE___ns1__createDigitalInfo:
		if (p->size < 0)
			delete (struct __ns1__createDigitalInfo*)p->ptr;
		else
			delete[] (struct __ns1__createDigitalInfo*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			delete (struct SOAP_ENV__Header*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Header*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			delete (struct SOAP_ENV__Code*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Code*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			delete (struct SOAP_ENV__Detail*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Detail*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			delete (struct SOAP_ENV__Reason*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Reason*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			delete (struct SOAP_ENV__Fault*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Fault*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__gingkoUser:
		if (p->size < 0)
			delete (std::vector<ns1__gingkoUser * >*)p->ptr;
		else
			delete[] (std::vector<ns1__gingkoUser * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__gingkoPermission:
		if (p->size < 0)
			delete (std::vector<ns1__gingkoPermission * >*)p->ptr;
		else
			delete[] (std::vector<ns1__gingkoPermission * >*)p->ptr;
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__gingkoUser:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__gingkoUser * >*)p)[len] = *(ns1__gingkoUser **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__gingkoPermission:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__gingkoPermission * >*)p)[len] = *(ns1__gingkoPermission **)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{	time_t *p;
	p = soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{	return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__soapPackStatusEnum(struct soap *soap, enum ns1__soapPackStatusEnum *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__soapPackStatusEnum
	*a = SOAP_DEFAULT_ns1__soapPackStatusEnum;
#else
	*a = (enum ns1__soapPackStatusEnum)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__soapPackStatusEnum(struct soap *soap, const enum ns1__soapPackStatusEnum *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__soapPackStatusEnum);
	if (soap_out_ns1__soapPackStatusEnum(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__soapPackStatusEnum[] =
{	{ (long)ns1__soapPackStatusEnum__SUCCESS, "SUCCESS" },
	{ (long)ns1__soapPackStatusEnum__NOTFOUND, "NOTFOUND" },
	{ (long)ns1__soapPackStatusEnum__DISABLED, "DISABLED" },
	{ (long)ns1__soapPackStatusEnum__EXISTING, "EXISTING" },
	{ (long)ns1__soapPackStatusEnum__NOTAVAILABLE, "NOTAVAILABLE" },
	{ (long)ns1__soapPackStatusEnum__DELETED, "DELETED" },
	{ (long)ns1__soapPackStatusEnum__ERROR, "ERROR" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__soapPackStatusEnum2s(struct soap *soap, enum ns1__soapPackStatusEnum n)
{	const char *s = soap_code_str(soap_codes_ns1__soapPackStatusEnum, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__soapPackStatusEnum(struct soap *soap, const char *tag, int id, const enum ns1__soapPackStatusEnum *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__soapPackStatusEnum), type) || soap_send(soap, soap_ns1__soapPackStatusEnum2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__soapPackStatusEnum * SOAP_FMAC4 soap_get_ns1__soapPackStatusEnum(struct soap *soap, enum ns1__soapPackStatusEnum *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__soapPackStatusEnum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__soapPackStatusEnum(struct soap *soap, const char *s, enum ns1__soapPackStatusEnum *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__soapPackStatusEnum, s);
	if (map)
		*a = (enum ns1__soapPackStatusEnum)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 6)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__soapPackStatusEnum)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__soapPackStatusEnum * SOAP_FMAC4 soap_in_ns1__soapPackStatusEnum(struct soap *soap, const char *tag, enum ns1__soapPackStatusEnum *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__soapPackStatusEnum *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__soapPackStatusEnum, sizeof(enum ns1__soapPackStatusEnum), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__soapPackStatusEnum(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__soapPackStatusEnum *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__soapPackStatusEnum, 0, sizeof(enum ns1__soapPackStatusEnum), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__wstring(struct soap *soap, std::wstring *p)
{	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__wstring(struct soap *soap, const std::wstring *p)
{	(void)soap; (void)p; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__wstring(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__wstring);
	if (soap_out_std__wstring(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__wstring(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__wstring), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_std__wstring(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__wstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::wstring * SOAP_FMAC2 soap_in_std__wstring(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__wstring, sizeof(std::wstring), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_wstring_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__wstring, sizeof(std::wstring), soap->type, soap->arrayType), 0, SOAP_TYPE_std__wstring, 0, sizeof(std::wstring), 0, soap_copy_std__wstring);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_instantiate_std__wstring(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__wstring(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__wstring, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::wstring;
		if (size)
			*size = sizeof(std::wstring);
	}
	else
	{	cp->ptr = (void*)new std::wstring[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::wstring);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::wstring*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__wstring(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::wstring %p -> %p\n", q, p));
	*(std::wstring*)p = *(std::wstring*)q;
}

void ns1__gingkoUserListPack::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__gingkoUser(soap, &this->ns1__gingkoUserListPack::users);
	this->ns1__gingkoUserListPack::message = NULL;
	this->ns1__gingkoUserListPack::status = NULL;
	soap_default_int(soap, &this->ns1__gingkoUserListPack::count);
	/* transient soap skipped */
}

void ns1__gingkoUserListPack::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__gingkoUser(soap, &this->ns1__gingkoUserListPack::users);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__gingkoUserListPack::message);
	soap_serialize_PointerTons1__soapPackStatusEnum(soap, &this->ns1__gingkoUserListPack::status);
	/* transient soap skipped */
}

int ns1__gingkoUserListPack::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__gingkoUserListPack);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__gingkoUserListPack::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__gingkoUserListPack(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__gingkoUserListPack(struct soap *soap, const char *tag, int id, const ns1__gingkoUserListPack *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__gingkoUserListPack), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__gingkoUser(soap, "users", -1, &(a->ns1__gingkoUserListPack::users), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "message", -1, &(a->ns1__gingkoUserListPack::message), ""))
		return soap->error;
	if (soap_out_PointerTons1__soapPackStatusEnum(soap, "status", -1, &(a->ns1__gingkoUserListPack::status), ""))
		return soap->error;
	if (soap_out_int(soap, "count", -1, &(a->ns1__gingkoUserListPack::count), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__gingkoUserListPack::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__gingkoUserListPack(soap, this, tag, type);
}

SOAP_FMAC3 ns1__gingkoUserListPack * SOAP_FMAC4 soap_get_ns1__gingkoUserListPack(struct soap *soap, ns1__gingkoUserListPack *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__gingkoUserListPack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__gingkoUserListPack::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__gingkoUserListPack(soap, tag, this, type);
}

SOAP_FMAC3 ns1__gingkoUserListPack * SOAP_FMAC4 soap_in_ns1__gingkoUserListPack(struct soap *soap, const char *tag, ns1__gingkoUserListPack *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__gingkoUserListPack *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__gingkoUserListPack, sizeof(ns1__gingkoUserListPack), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__gingkoUserListPack)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__gingkoUserListPack *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_count1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__gingkoUser(soap, "users", &(a->ns1__gingkoUserListPack::users), "ns1:gingkoUser"))
					continue;
			if (soap_flag_message1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "message", &(a->ns1__gingkoUserListPack::message), "xsd:string"))
				{	soap_flag_message1--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__soapPackStatusEnum(soap, "status", &(a->ns1__gingkoUserListPack::status), "ns1:soapPackStatusEnum"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_count1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "count", &(a->ns1__gingkoUserListPack::count), "xsd:int"))
				{	soap_flag_count1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__gingkoUserListPack *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__gingkoUserListPack, 0, sizeof(ns1__gingkoUserListPack), 0, soap_copy_ns1__gingkoUserListPack);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_count1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__gingkoUserListPack * SOAP_FMAC4 soap_instantiate_ns1__gingkoUserListPack(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__gingkoUserListPack(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__gingkoUserListPack, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__gingkoUserListPack;
		if (size)
			*size = sizeof(ns1__gingkoUserListPack);
		((ns1__gingkoUserListPack*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__gingkoUserListPack[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__gingkoUserListPack);
		for (int i = 0; i < n; i++)
			((ns1__gingkoUserListPack*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__gingkoUserListPack*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__gingkoUserListPack(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__gingkoUserListPack %p -> %p\n", q, p));
	*(ns1__gingkoUserListPack*)p = *(ns1__gingkoUserListPack*)q;
}

void ns1__searchUsersResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__searchUsersResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__searchUsersResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__gingkoUserListPack(soap, &this->ns1__searchUsersResponse::return_);
	/* transient soap skipped */
}

int ns1__searchUsersResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__searchUsersResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__searchUsersResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__searchUsersResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__searchUsersResponse(struct soap *soap, const char *tag, int id, const ns1__searchUsersResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__searchUsersResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__gingkoUserListPack(soap, "return", -1, &(a->ns1__searchUsersResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__searchUsersResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__searchUsersResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__searchUsersResponse * SOAP_FMAC4 soap_get_ns1__searchUsersResponse(struct soap *soap, ns1__searchUsersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__searchUsersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__searchUsersResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__searchUsersResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__searchUsersResponse * SOAP_FMAC4 soap_in_ns1__searchUsersResponse(struct soap *soap, const char *tag, ns1__searchUsersResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__searchUsersResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__searchUsersResponse, sizeof(ns1__searchUsersResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__searchUsersResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__searchUsersResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__gingkoUserListPack(soap, "return", &(a->ns1__searchUsersResponse::return_), "ns1:gingkoUserListPack"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__searchUsersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__searchUsersResponse, 0, sizeof(ns1__searchUsersResponse), 0, soap_copy_ns1__searchUsersResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__searchUsersResponse * SOAP_FMAC4 soap_instantiate_ns1__searchUsersResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__searchUsersResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__searchUsersResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__searchUsersResponse;
		if (size)
			*size = sizeof(ns1__searchUsersResponse);
		((ns1__searchUsersResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__searchUsersResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__searchUsersResponse);
		for (int i = 0; i < n; i++)
			((ns1__searchUsersResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__searchUsersResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__searchUsersResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__searchUsersResponse %p -> %p\n", q, p));
	*(ns1__searchUsersResponse*)p = *(ns1__searchUsersResponse*)q;
}

void ns1__searchUsers::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__searchUsers::theName = NULL;
	/* transient soap skipped */
}

void ns1__searchUsers::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__searchUsers::theName);
	/* transient soap skipped */
}

int ns1__searchUsers::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__searchUsers);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__searchUsers::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__searchUsers(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__searchUsers(struct soap *soap, const char *tag, int id, const ns1__searchUsers *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__searchUsers), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "theName", -1, &(a->ns1__searchUsers::theName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__searchUsers::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__searchUsers(soap, this, tag, type);
}

SOAP_FMAC3 ns1__searchUsers * SOAP_FMAC4 soap_get_ns1__searchUsers(struct soap *soap, ns1__searchUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__searchUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__searchUsers::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__searchUsers(soap, tag, this, type);
}

SOAP_FMAC3 ns1__searchUsers * SOAP_FMAC4 soap_in_ns1__searchUsers(struct soap *soap, const char *tag, ns1__searchUsers *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__searchUsers *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__searchUsers, sizeof(ns1__searchUsers), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__searchUsers)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__searchUsers *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_theName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_theName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "theName", &(a->ns1__searchUsers::theName), "xsd:string"))
				{	soap_flag_theName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__searchUsers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__searchUsers, 0, sizeof(ns1__searchUsers), 0, soap_copy_ns1__searchUsers);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__searchUsers * SOAP_FMAC4 soap_instantiate_ns1__searchUsers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__searchUsers(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__searchUsers, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__searchUsers;
		if (size)
			*size = sizeof(ns1__searchUsers);
		((ns1__searchUsers*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__searchUsers[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__searchUsers);
		for (int i = 0; i < n; i++)
			((ns1__searchUsers*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__searchUsers*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__searchUsers(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__searchUsers %p -> %p\n", q, p));
	*(ns1__searchUsers*)p = *(ns1__searchUsers*)q;
}

void ns1__registerThisUnitResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__registerThisUnitResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__registerThisUnitResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__gingkoUnitPack(soap, &this->ns1__registerThisUnitResponse::return_);
	/* transient soap skipped */
}

int ns1__registerThisUnitResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__registerThisUnitResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__registerThisUnitResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__registerThisUnitResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__registerThisUnitResponse(struct soap *soap, const char *tag, int id, const ns1__registerThisUnitResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__registerThisUnitResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__gingkoUnitPack(soap, "return", -1, &(a->ns1__registerThisUnitResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__registerThisUnitResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__registerThisUnitResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__registerThisUnitResponse * SOAP_FMAC4 soap_get_ns1__registerThisUnitResponse(struct soap *soap, ns1__registerThisUnitResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__registerThisUnitResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__registerThisUnitResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__registerThisUnitResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__registerThisUnitResponse * SOAP_FMAC4 soap_in_ns1__registerThisUnitResponse(struct soap *soap, const char *tag, ns1__registerThisUnitResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__registerThisUnitResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__registerThisUnitResponse, sizeof(ns1__registerThisUnitResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__registerThisUnitResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__registerThisUnitResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__gingkoUnitPack(soap, "return", &(a->ns1__registerThisUnitResponse::return_), "ns1:gingkoUnitPack"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__registerThisUnitResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__registerThisUnitResponse, 0, sizeof(ns1__registerThisUnitResponse), 0, soap_copy_ns1__registerThisUnitResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__registerThisUnitResponse * SOAP_FMAC4 soap_instantiate_ns1__registerThisUnitResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__registerThisUnitResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__registerThisUnitResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__registerThisUnitResponse;
		if (size)
			*size = sizeof(ns1__registerThisUnitResponse);
		((ns1__registerThisUnitResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__registerThisUnitResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__registerThisUnitResponse);
		for (int i = 0; i < n; i++)
			((ns1__registerThisUnitResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__registerThisUnitResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__registerThisUnitResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__registerThisUnitResponse %p -> %p\n", q, p));
	*(ns1__registerThisUnitResponse*)p = *(ns1__registerThisUnitResponse*)q;
}

void ns1__registerThisUnit::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__registerThisUnit::unitId = NULL;
	this->ns1__registerThisUnit::parentId = NULL;
	this->ns1__registerThisUnit::unitServerUrl = NULL;
	this->ns1__registerThisUnit::unitType = NULL;
	this->ns1__registerThisUnit::unitLevel = NULL;
	this->ns1__registerThisUnit::status = NULL;
	/* transient soap skipped */
}

void ns1__registerThisUnit::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__registerThisUnit::unitId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__registerThisUnit::parentId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__registerThisUnit::unitServerUrl);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__registerThisUnit::unitType);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__registerThisUnit::unitLevel);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__registerThisUnit::status);
	/* transient soap skipped */
}

int ns1__registerThisUnit::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__registerThisUnit);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__registerThisUnit::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__registerThisUnit(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__registerThisUnit(struct soap *soap, const char *tag, int id, const ns1__registerThisUnit *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__registerThisUnit), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "unitId", -1, &(a->ns1__registerThisUnit::unitId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "parentId", -1, &(a->ns1__registerThisUnit::parentId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "unitServerUrl", -1, &(a->ns1__registerThisUnit::unitServerUrl), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "unitType", -1, &(a->ns1__registerThisUnit::unitType), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "unitLevel", -1, &(a->ns1__registerThisUnit::unitLevel), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "status", -1, &(a->ns1__registerThisUnit::status), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__registerThisUnit::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__registerThisUnit(soap, this, tag, type);
}

SOAP_FMAC3 ns1__registerThisUnit * SOAP_FMAC4 soap_get_ns1__registerThisUnit(struct soap *soap, ns1__registerThisUnit *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__registerThisUnit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__registerThisUnit::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__registerThisUnit(soap, tag, this, type);
}

SOAP_FMAC3 ns1__registerThisUnit * SOAP_FMAC4 soap_in_ns1__registerThisUnit(struct soap *soap, const char *tag, ns1__registerThisUnit *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__registerThisUnit *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__registerThisUnit, sizeof(ns1__registerThisUnit), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__registerThisUnit)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__registerThisUnit *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_unitId1 = 1;
	size_t soap_flag_parentId1 = 1;
	size_t soap_flag_unitServerUrl1 = 1;
	size_t soap_flag_unitType1 = 1;
	size_t soap_flag_unitLevel1 = 1;
	size_t soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_unitId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "unitId", &(a->ns1__registerThisUnit::unitId), "xsd:string"))
				{	soap_flag_unitId1--;
					continue;
				}
			if (soap_flag_parentId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "parentId", &(a->ns1__registerThisUnit::parentId), "xsd:string"))
				{	soap_flag_parentId1--;
					continue;
				}
			if (soap_flag_unitServerUrl1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "unitServerUrl", &(a->ns1__registerThisUnit::unitServerUrl), "xsd:string"))
				{	soap_flag_unitServerUrl1--;
					continue;
				}
			if (soap_flag_unitType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "unitType", &(a->ns1__registerThisUnit::unitType), "xsd:string"))
				{	soap_flag_unitType1--;
					continue;
				}
			if (soap_flag_unitLevel1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "unitLevel", &(a->ns1__registerThisUnit::unitLevel), "xsd:string"))
				{	soap_flag_unitLevel1--;
					continue;
				}
			if (soap_flag_status1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "status", &(a->ns1__registerThisUnit::status), "xsd:string"))
				{	soap_flag_status1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__registerThisUnit *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__registerThisUnit, 0, sizeof(ns1__registerThisUnit), 0, soap_copy_ns1__registerThisUnit);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__registerThisUnit * SOAP_FMAC4 soap_instantiate_ns1__registerThisUnit(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__registerThisUnit(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__registerThisUnit, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__registerThisUnit;
		if (size)
			*size = sizeof(ns1__registerThisUnit);
		((ns1__registerThisUnit*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__registerThisUnit[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__registerThisUnit);
		for (int i = 0; i < n; i++)
			((ns1__registerThisUnit*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__registerThisUnit*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__registerThisUnit(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__registerThisUnit %p -> %p\n", q, p));
	*(ns1__registerThisUnit*)p = *(ns1__registerThisUnit*)q;
}

void ns1__companyUnit::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__companyUnit::unitId = NULL;
	this->ns1__companyUnit::name = NULL;
	this->ns1__companyUnit::description = NULL;
	this->ns1__companyUnit::address = NULL;
	this->ns1__companyUnit::serverUrl = NULL;
	this->ns1__companyUnit::domains = NULL;
	this->ns1__companyUnit::level = NULL;
	this->ns1__companyUnit::type = NULL;
	this->ns1__companyUnit::parentId = NULL;
	this->ns1__companyUnit::status = NULL;
	this->ns1__companyUnit::updatedTime = NULL;
	this->ns1__companyUnit::updatedBy = NULL;
	/* transient soap skipped */
}

void ns1__companyUnit::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__companyUnit::unitId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__companyUnit::name);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__companyUnit::description);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__companyUnit::address);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__companyUnit::serverUrl);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__companyUnit::domains);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__companyUnit::level);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__companyUnit::type);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__companyUnit::parentId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__companyUnit::status);
	soap_serialize_PointerTotime(soap, &this->ns1__companyUnit::updatedTime);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__companyUnit::updatedBy);
	/* transient soap skipped */
}

int ns1__companyUnit::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__companyUnit);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__companyUnit::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__companyUnit(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__companyUnit(struct soap *soap, const char *tag, int id, const ns1__companyUnit *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__companyUnit), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "unitId", -1, &(a->ns1__companyUnit::unitId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "name", -1, &(a->ns1__companyUnit::name), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "description", -1, &(a->ns1__companyUnit::description), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "address", -1, &(a->ns1__companyUnit::address), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "serverUrl", -1, &(a->ns1__companyUnit::serverUrl), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "domains", -1, &(a->ns1__companyUnit::domains), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "level", -1, &(a->ns1__companyUnit::level), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "type", -1, &(a->ns1__companyUnit::type), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "parentId", -1, &(a->ns1__companyUnit::parentId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "status", -1, &(a->ns1__companyUnit::status), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "updatedTime", -1, &(a->ns1__companyUnit::updatedTime), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "updatedBy", -1, &(a->ns1__companyUnit::updatedBy), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__companyUnit::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__companyUnit(soap, this, tag, type);
}

SOAP_FMAC3 ns1__companyUnit * SOAP_FMAC4 soap_get_ns1__companyUnit(struct soap *soap, ns1__companyUnit *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__companyUnit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__companyUnit::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__companyUnit(soap, tag, this, type);
}

SOAP_FMAC3 ns1__companyUnit * SOAP_FMAC4 soap_in_ns1__companyUnit(struct soap *soap, const char *tag, ns1__companyUnit *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__companyUnit *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__companyUnit, sizeof(ns1__companyUnit), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__companyUnit)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__companyUnit *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_unitId1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_address1 = 1;
	size_t soap_flag_serverUrl1 = 1;
	size_t soap_flag_domains1 = 1;
	size_t soap_flag_level1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_parentId1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_updatedTime1 = 1;
	size_t soap_flag_updatedBy1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_unitId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "unitId", &(a->ns1__companyUnit::unitId), "xsd:string"))
				{	soap_flag_unitId1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "name", &(a->ns1__companyUnit::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "description", &(a->ns1__companyUnit::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_address1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "address", &(a->ns1__companyUnit::address), "xsd:string"))
				{	soap_flag_address1--;
					continue;
				}
			if (soap_flag_serverUrl1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "serverUrl", &(a->ns1__companyUnit::serverUrl), "xsd:string"))
				{	soap_flag_serverUrl1--;
					continue;
				}
			if (soap_flag_domains1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "domains", &(a->ns1__companyUnit::domains), "xsd:string"))
				{	soap_flag_domains1--;
					continue;
				}
			if (soap_flag_level1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "level", &(a->ns1__companyUnit::level), "xsd:string"))
				{	soap_flag_level1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "type", &(a->ns1__companyUnit::type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_parentId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "parentId", &(a->ns1__companyUnit::parentId), "xsd:string"))
				{	soap_flag_parentId1--;
					continue;
				}
			if (soap_flag_status1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "status", &(a->ns1__companyUnit::status), "xsd:string"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_updatedTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "updatedTime", &(a->ns1__companyUnit::updatedTime), "xsd:dateTime"))
				{	soap_flag_updatedTime1--;
					continue;
				}
			if (soap_flag_updatedBy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "updatedBy", &(a->ns1__companyUnit::updatedBy), "xsd:string"))
				{	soap_flag_updatedBy1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__companyUnit *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__companyUnit, 0, sizeof(ns1__companyUnit), 0, soap_copy_ns1__companyUnit);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__companyUnit * SOAP_FMAC4 soap_instantiate_ns1__companyUnit(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__companyUnit(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__companyUnit, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__companyUnit;
		if (size)
			*size = sizeof(ns1__companyUnit);
		((ns1__companyUnit*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__companyUnit[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__companyUnit);
		for (int i = 0; i < n; i++)
			((ns1__companyUnit*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__companyUnit*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__companyUnit(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__companyUnit %p -> %p\n", q, p));
	*(ns1__companyUnit*)p = *(ns1__companyUnit*)q;
}

void ns1__gingkoUnitPack::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__gingkoUnitPack::gingkoUnit = NULL;
	this->ns1__gingkoUnitPack::message = NULL;
	this->ns1__gingkoUnitPack::status = NULL;
	/* transient soap skipped */
}

void ns1__gingkoUnitPack::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__companyUnit(soap, &this->ns1__gingkoUnitPack::gingkoUnit);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__gingkoUnitPack::message);
	soap_serialize_PointerTons1__soapPackStatusEnum(soap, &this->ns1__gingkoUnitPack::status);
	/* transient soap skipped */
}

int ns1__gingkoUnitPack::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__gingkoUnitPack);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__gingkoUnitPack::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__gingkoUnitPack(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__gingkoUnitPack(struct soap *soap, const char *tag, int id, const ns1__gingkoUnitPack *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__gingkoUnitPack), type))
		return soap->error;
	if (soap_out_PointerTons1__companyUnit(soap, "gingkoUnit", -1, &(a->ns1__gingkoUnitPack::gingkoUnit), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "message", -1, &(a->ns1__gingkoUnitPack::message), ""))
		return soap->error;
	if (soap_out_PointerTons1__soapPackStatusEnum(soap, "status", -1, &(a->ns1__gingkoUnitPack::status), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__gingkoUnitPack::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__gingkoUnitPack(soap, this, tag, type);
}

SOAP_FMAC3 ns1__gingkoUnitPack * SOAP_FMAC4 soap_get_ns1__gingkoUnitPack(struct soap *soap, ns1__gingkoUnitPack *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__gingkoUnitPack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__gingkoUnitPack::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__gingkoUnitPack(soap, tag, this, type);
}

SOAP_FMAC3 ns1__gingkoUnitPack * SOAP_FMAC4 soap_in_ns1__gingkoUnitPack(struct soap *soap, const char *tag, ns1__gingkoUnitPack *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__gingkoUnitPack *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__gingkoUnitPack, sizeof(ns1__gingkoUnitPack), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__gingkoUnitPack)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__gingkoUnitPack *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_gingkoUnit1 = 1;
	size_t soap_flag_message1 = 1;
	size_t soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_gingkoUnit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__companyUnit(soap, "gingkoUnit", &(a->ns1__gingkoUnitPack::gingkoUnit), "ns1:companyUnit"))
				{	soap_flag_gingkoUnit1--;
					continue;
				}
			if (soap_flag_message1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "message", &(a->ns1__gingkoUnitPack::message), "xsd:string"))
				{	soap_flag_message1--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__soapPackStatusEnum(soap, "status", &(a->ns1__gingkoUnitPack::status), "ns1:soapPackStatusEnum"))
				{	soap_flag_status1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__gingkoUnitPack *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__gingkoUnitPack, 0, sizeof(ns1__gingkoUnitPack), 0, soap_copy_ns1__gingkoUnitPack);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__gingkoUnitPack * SOAP_FMAC4 soap_instantiate_ns1__gingkoUnitPack(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__gingkoUnitPack(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__gingkoUnitPack, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__gingkoUnitPack;
		if (size)
			*size = sizeof(ns1__gingkoUnitPack);
		((ns1__gingkoUnitPack*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__gingkoUnitPack[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__gingkoUnitPack);
		for (int i = 0; i < n; i++)
			((ns1__gingkoUnitPack*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__gingkoUnitPack*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__gingkoUnitPack(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__gingkoUnitPack %p -> %p\n", q, p));
	*(ns1__gingkoUnitPack*)p = *(ns1__gingkoUnitPack*)q;
}

void ns1__findGingkoUnitInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__findGingkoUnitInfoResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__findGingkoUnitInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__gingkoUnitPack(soap, &this->ns1__findGingkoUnitInfoResponse::return_);
	/* transient soap skipped */
}

int ns1__findGingkoUnitInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__findGingkoUnitInfoResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__findGingkoUnitInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__findGingkoUnitInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__findGingkoUnitInfoResponse(struct soap *soap, const char *tag, int id, const ns1__findGingkoUnitInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__findGingkoUnitInfoResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__gingkoUnitPack(soap, "return", -1, &(a->ns1__findGingkoUnitInfoResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__findGingkoUnitInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__findGingkoUnitInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__findGingkoUnitInfoResponse * SOAP_FMAC4 soap_get_ns1__findGingkoUnitInfoResponse(struct soap *soap, ns1__findGingkoUnitInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__findGingkoUnitInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__findGingkoUnitInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__findGingkoUnitInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__findGingkoUnitInfoResponse * SOAP_FMAC4 soap_in_ns1__findGingkoUnitInfoResponse(struct soap *soap, const char *tag, ns1__findGingkoUnitInfoResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__findGingkoUnitInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__findGingkoUnitInfoResponse, sizeof(ns1__findGingkoUnitInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__findGingkoUnitInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__findGingkoUnitInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__gingkoUnitPack(soap, "return", &(a->ns1__findGingkoUnitInfoResponse::return_), "ns1:gingkoUnitPack"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__findGingkoUnitInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__findGingkoUnitInfoResponse, 0, sizeof(ns1__findGingkoUnitInfoResponse), 0, soap_copy_ns1__findGingkoUnitInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__findGingkoUnitInfoResponse * SOAP_FMAC4 soap_instantiate_ns1__findGingkoUnitInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__findGingkoUnitInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__findGingkoUnitInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__findGingkoUnitInfoResponse;
		if (size)
			*size = sizeof(ns1__findGingkoUnitInfoResponse);
		((ns1__findGingkoUnitInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__findGingkoUnitInfoResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__findGingkoUnitInfoResponse);
		for (int i = 0; i < n; i++)
			((ns1__findGingkoUnitInfoResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__findGingkoUnitInfoResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__findGingkoUnitInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__findGingkoUnitInfoResponse %p -> %p\n", q, p));
	*(ns1__findGingkoUnitInfoResponse*)p = *(ns1__findGingkoUnitInfoResponse*)q;
}

void ns1__findGingkoUnitInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__findGingkoUnitInfo::unitId = NULL;
	/* transient soap skipped */
}

void ns1__findGingkoUnitInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__findGingkoUnitInfo::unitId);
	/* transient soap skipped */
}

int ns1__findGingkoUnitInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__findGingkoUnitInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__findGingkoUnitInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__findGingkoUnitInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__findGingkoUnitInfo(struct soap *soap, const char *tag, int id, const ns1__findGingkoUnitInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__findGingkoUnitInfo), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "unitId", -1, &(a->ns1__findGingkoUnitInfo::unitId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__findGingkoUnitInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__findGingkoUnitInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__findGingkoUnitInfo * SOAP_FMAC4 soap_get_ns1__findGingkoUnitInfo(struct soap *soap, ns1__findGingkoUnitInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__findGingkoUnitInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__findGingkoUnitInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__findGingkoUnitInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__findGingkoUnitInfo * SOAP_FMAC4 soap_in_ns1__findGingkoUnitInfo(struct soap *soap, const char *tag, ns1__findGingkoUnitInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__findGingkoUnitInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__findGingkoUnitInfo, sizeof(ns1__findGingkoUnitInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__findGingkoUnitInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__findGingkoUnitInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_unitId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_unitId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "unitId", &(a->ns1__findGingkoUnitInfo::unitId), "xsd:string"))
				{	soap_flag_unitId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__findGingkoUnitInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__findGingkoUnitInfo, 0, sizeof(ns1__findGingkoUnitInfo), 0, soap_copy_ns1__findGingkoUnitInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__findGingkoUnitInfo * SOAP_FMAC4 soap_instantiate_ns1__findGingkoUnitInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__findGingkoUnitInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__findGingkoUnitInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__findGingkoUnitInfo;
		if (size)
			*size = sizeof(ns1__findGingkoUnitInfo);
		((ns1__findGingkoUnitInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__findGingkoUnitInfo[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__findGingkoUnitInfo);
		for (int i = 0; i < n; i++)
			((ns1__findGingkoUnitInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__findGingkoUnitInfo*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__findGingkoUnitInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__findGingkoUnitInfo %p -> %p\n", q, p));
	*(ns1__findGingkoUnitInfo*)p = *(ns1__findGingkoUnitInfo*)q;
}

void ns1__findDigitalPermission::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__findDigitalPermission::unitId = NULL;
	this->ns1__findDigitalPermission::digitalId = NULL;
	/* transient soap skipped */
}

void ns1__findDigitalPermission::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__findDigitalPermission::unitId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__findDigitalPermission::digitalId);
	/* transient soap skipped */
}

int ns1__findDigitalPermission::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__findDigitalPermission);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__findDigitalPermission::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__findDigitalPermission(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__findDigitalPermission(struct soap *soap, const char *tag, int id, const ns1__findDigitalPermission *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__findDigitalPermission), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "unitId", -1, &(a->ns1__findDigitalPermission::unitId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "digitalId", -1, &(a->ns1__findDigitalPermission::digitalId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__findDigitalPermission::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__findDigitalPermission(soap, this, tag, type);
}

SOAP_FMAC3 ns1__findDigitalPermission * SOAP_FMAC4 soap_get_ns1__findDigitalPermission(struct soap *soap, ns1__findDigitalPermission *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__findDigitalPermission(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__findDigitalPermission::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__findDigitalPermission(soap, tag, this, type);
}

SOAP_FMAC3 ns1__findDigitalPermission * SOAP_FMAC4 soap_in_ns1__findDigitalPermission(struct soap *soap, const char *tag, ns1__findDigitalPermission *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__findDigitalPermission *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__findDigitalPermission, sizeof(ns1__findDigitalPermission), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__findDigitalPermission)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__findDigitalPermission *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_unitId1 = 1;
	size_t soap_flag_digitalId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_unitId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "unitId", &(a->ns1__findDigitalPermission::unitId), "xsd:string"))
				{	soap_flag_unitId1--;
					continue;
				}
			if (soap_flag_digitalId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "digitalId", &(a->ns1__findDigitalPermission::digitalId), "xsd:string"))
				{	soap_flag_digitalId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__findDigitalPermission *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__findDigitalPermission, 0, sizeof(ns1__findDigitalPermission), 0, soap_copy_ns1__findDigitalPermission);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__findDigitalPermission * SOAP_FMAC4 soap_instantiate_ns1__findDigitalPermission(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__findDigitalPermission(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__findDigitalPermission, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__findDigitalPermission;
		if (size)
			*size = sizeof(ns1__findDigitalPermission);
		((ns1__findDigitalPermission*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__findDigitalPermission[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__findDigitalPermission);
		for (int i = 0; i < n; i++)
			((ns1__findDigitalPermission*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__findDigitalPermission*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__findDigitalPermission(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__findDigitalPermission %p -> %p\n", q, p));
	*(ns1__findDigitalPermission*)p = *(ns1__findDigitalPermission*)q;
}

void ns1__createDigitalInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__createDigitalInfo::author = NULL;
	this->ns1__createDigitalInfo::description = NULL;
	this->ns1__createDigitalInfo::digitalId = NULL;
	this->ns1__createDigitalInfo::fileHash = NULL;
	this->ns1__createDigitalInfo::title = NULL;
	this->ns1__createDigitalInfo::keyword = NULL;
	this->ns1__createDigitalInfo::owner = NULL;
	this->ns1__createDigitalInfo::status = NULL;
	this->ns1__createDigitalInfo::securityType = NULL;
	this->ns1__createDigitalInfo::permissionType = NULL;
	this->ns1__createDigitalInfo::limitationType = NULL;
	this->ns1__createDigitalInfo::publicKey = NULL;
	this->ns1__createDigitalInfo::privateKey = NULL;
	/* transient soap skipped */
}

void ns1__createDigitalInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__createDigitalInfo::author);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__createDigitalInfo::description);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__createDigitalInfo::digitalId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__createDigitalInfo::fileHash);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__createDigitalInfo::title);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__createDigitalInfo::keyword);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__createDigitalInfo::owner);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__createDigitalInfo::status);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__createDigitalInfo::securityType);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__createDigitalInfo::permissionType);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__createDigitalInfo::limitationType);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__createDigitalInfo::publicKey);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__createDigitalInfo::privateKey);
	/* transient soap skipped */
}

int ns1__createDigitalInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__createDigitalInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__createDigitalInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__createDigitalInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__createDigitalInfo(struct soap *soap, const char *tag, int id, const ns1__createDigitalInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__createDigitalInfo), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "author", -1, &(a->ns1__createDigitalInfo::author), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "description", -1, &(a->ns1__createDigitalInfo::description), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "digitalId", -1, &(a->ns1__createDigitalInfo::digitalId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fileHash", -1, &(a->ns1__createDigitalInfo::fileHash), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "title", -1, &(a->ns1__createDigitalInfo::title), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "keyword", -1, &(a->ns1__createDigitalInfo::keyword), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "owner", -1, &(a->ns1__createDigitalInfo::owner), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "status", -1, &(a->ns1__createDigitalInfo::status), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "securityType", -1, &(a->ns1__createDigitalInfo::securityType), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "permissionType", -1, &(a->ns1__createDigitalInfo::permissionType), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "limitationType", -1, &(a->ns1__createDigitalInfo::limitationType), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "publicKey", -1, &(a->ns1__createDigitalInfo::publicKey), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "privateKey", -1, &(a->ns1__createDigitalInfo::privateKey), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__createDigitalInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__createDigitalInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__createDigitalInfo * SOAP_FMAC4 soap_get_ns1__createDigitalInfo(struct soap *soap, ns1__createDigitalInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__createDigitalInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__createDigitalInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__createDigitalInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__createDigitalInfo * SOAP_FMAC4 soap_in_ns1__createDigitalInfo(struct soap *soap, const char *tag, ns1__createDigitalInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__createDigitalInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__createDigitalInfo, sizeof(ns1__createDigitalInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__createDigitalInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__createDigitalInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_author1 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_digitalId1 = 1;
	size_t soap_flag_fileHash1 = 1;
	size_t soap_flag_title1 = 1;
	size_t soap_flag_keyword1 = 1;
	size_t soap_flag_owner1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_securityType1 = 1;
	size_t soap_flag_permissionType1 = 1;
	size_t soap_flag_limitationType1 = 1;
	size_t soap_flag_publicKey1 = 1;
	size_t soap_flag_privateKey1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_author1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "author", &(a->ns1__createDigitalInfo::author), "xsd:string"))
				{	soap_flag_author1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "description", &(a->ns1__createDigitalInfo::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_digitalId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "digitalId", &(a->ns1__createDigitalInfo::digitalId), "xsd:string"))
				{	soap_flag_digitalId1--;
					continue;
				}
			if (soap_flag_fileHash1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fileHash", &(a->ns1__createDigitalInfo::fileHash), "xsd:string"))
				{	soap_flag_fileHash1--;
					continue;
				}
			if (soap_flag_title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "title", &(a->ns1__createDigitalInfo::title), "xsd:string"))
				{	soap_flag_title1--;
					continue;
				}
			if (soap_flag_keyword1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "keyword", &(a->ns1__createDigitalInfo::keyword), "xsd:string"))
				{	soap_flag_keyword1--;
					continue;
				}
			if (soap_flag_owner1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "owner", &(a->ns1__createDigitalInfo::owner), "xsd:string"))
				{	soap_flag_owner1--;
					continue;
				}
			if (soap_flag_status1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "status", &(a->ns1__createDigitalInfo::status), "xsd:string"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_securityType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "securityType", &(a->ns1__createDigitalInfo::securityType), "xsd:string"))
				{	soap_flag_securityType1--;
					continue;
				}
			if (soap_flag_permissionType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "permissionType", &(a->ns1__createDigitalInfo::permissionType), "xsd:string"))
				{	soap_flag_permissionType1--;
					continue;
				}
			if (soap_flag_limitationType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "limitationType", &(a->ns1__createDigitalInfo::limitationType), "xsd:string"))
				{	soap_flag_limitationType1--;
					continue;
				}
			if (soap_flag_publicKey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "publicKey", &(a->ns1__createDigitalInfo::publicKey), "xsd:string"))
				{	soap_flag_publicKey1--;
					continue;
				}
			if (soap_flag_privateKey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "privateKey", &(a->ns1__createDigitalInfo::privateKey), "xsd:string"))
				{	soap_flag_privateKey1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__createDigitalInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__createDigitalInfo, 0, sizeof(ns1__createDigitalInfo), 0, soap_copy_ns1__createDigitalInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__createDigitalInfo * SOAP_FMAC4 soap_instantiate_ns1__createDigitalInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__createDigitalInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__createDigitalInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__createDigitalInfo;
		if (size)
			*size = sizeof(ns1__createDigitalInfo);
		((ns1__createDigitalInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__createDigitalInfo[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__createDigitalInfo);
		for (int i = 0; i < n; i++)
			((ns1__createDigitalInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__createDigitalInfo*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__createDigitalInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__createDigitalInfo %p -> %p\n", q, p));
	*(ns1__createDigitalInfo*)p = *(ns1__createDigitalInfo*)q;
}

void ns1__findDigitalInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__findDigitalInfoResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__findDigitalInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__gingkoDigitalPack(soap, &this->ns1__findDigitalInfoResponse::return_);
	/* transient soap skipped */
}

int ns1__findDigitalInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__findDigitalInfoResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__findDigitalInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__findDigitalInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__findDigitalInfoResponse(struct soap *soap, const char *tag, int id, const ns1__findDigitalInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__findDigitalInfoResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__gingkoDigitalPack(soap, "return", -1, &(a->ns1__findDigitalInfoResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__findDigitalInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__findDigitalInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__findDigitalInfoResponse * SOAP_FMAC4 soap_get_ns1__findDigitalInfoResponse(struct soap *soap, ns1__findDigitalInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__findDigitalInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__findDigitalInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__findDigitalInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__findDigitalInfoResponse * SOAP_FMAC4 soap_in_ns1__findDigitalInfoResponse(struct soap *soap, const char *tag, ns1__findDigitalInfoResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__findDigitalInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__findDigitalInfoResponse, sizeof(ns1__findDigitalInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__findDigitalInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__findDigitalInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__gingkoDigitalPack(soap, "return", &(a->ns1__findDigitalInfoResponse::return_), "ns1:gingkoDigitalPack"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__findDigitalInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__findDigitalInfoResponse, 0, sizeof(ns1__findDigitalInfoResponse), 0, soap_copy_ns1__findDigitalInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__findDigitalInfoResponse * SOAP_FMAC4 soap_instantiate_ns1__findDigitalInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__findDigitalInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__findDigitalInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__findDigitalInfoResponse;
		if (size)
			*size = sizeof(ns1__findDigitalInfoResponse);
		((ns1__findDigitalInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__findDigitalInfoResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__findDigitalInfoResponse);
		for (int i = 0; i < n; i++)
			((ns1__findDigitalInfoResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__findDigitalInfoResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__findDigitalInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__findDigitalInfoResponse %p -> %p\n", q, p));
	*(ns1__findDigitalInfoResponse*)p = *(ns1__findDigitalInfoResponse*)q;
}

void ns1__findAssignedPermissionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__findAssignedPermissionResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__findAssignedPermissionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__gingkoPermissionListPack(soap, &this->ns1__findAssignedPermissionResponse::return_);
	/* transient soap skipped */
}

int ns1__findAssignedPermissionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__findAssignedPermissionResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__findAssignedPermissionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__findAssignedPermissionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__findAssignedPermissionResponse(struct soap *soap, const char *tag, int id, const ns1__findAssignedPermissionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__findAssignedPermissionResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__gingkoPermissionListPack(soap, "return", -1, &(a->ns1__findAssignedPermissionResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__findAssignedPermissionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__findAssignedPermissionResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__findAssignedPermissionResponse * SOAP_FMAC4 soap_get_ns1__findAssignedPermissionResponse(struct soap *soap, ns1__findAssignedPermissionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__findAssignedPermissionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__findAssignedPermissionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__findAssignedPermissionResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__findAssignedPermissionResponse * SOAP_FMAC4 soap_in_ns1__findAssignedPermissionResponse(struct soap *soap, const char *tag, ns1__findAssignedPermissionResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__findAssignedPermissionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__findAssignedPermissionResponse, sizeof(ns1__findAssignedPermissionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__findAssignedPermissionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__findAssignedPermissionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__gingkoPermissionListPack(soap, "return", &(a->ns1__findAssignedPermissionResponse::return_), "ns1:gingkoPermissionListPack"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__findAssignedPermissionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__findAssignedPermissionResponse, 0, sizeof(ns1__findAssignedPermissionResponse), 0, soap_copy_ns1__findAssignedPermissionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__findAssignedPermissionResponse * SOAP_FMAC4 soap_instantiate_ns1__findAssignedPermissionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__findAssignedPermissionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__findAssignedPermissionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__findAssignedPermissionResponse;
		if (size)
			*size = sizeof(ns1__findAssignedPermissionResponse);
		((ns1__findAssignedPermissionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__findAssignedPermissionResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__findAssignedPermissionResponse);
		for (int i = 0; i < n; i++)
			((ns1__findAssignedPermissionResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__findAssignedPermissionResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__findAssignedPermissionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__findAssignedPermissionResponse %p -> %p\n", q, p));
	*(ns1__findAssignedPermissionResponse*)p = *(ns1__findAssignedPermissionResponse*)q;
}

void ns1__deleteDigitalInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__deleteDigitalInfoResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__deleteDigitalInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__gingkoDigitalPack(soap, &this->ns1__deleteDigitalInfoResponse::return_);
	/* transient soap skipped */
}

int ns1__deleteDigitalInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__deleteDigitalInfoResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__deleteDigitalInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__deleteDigitalInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteDigitalInfoResponse(struct soap *soap, const char *tag, int id, const ns1__deleteDigitalInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteDigitalInfoResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__gingkoDigitalPack(soap, "return", -1, &(a->ns1__deleteDigitalInfoResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__deleteDigitalInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__deleteDigitalInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__deleteDigitalInfoResponse * SOAP_FMAC4 soap_get_ns1__deleteDigitalInfoResponse(struct soap *soap, ns1__deleteDigitalInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteDigitalInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__deleteDigitalInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__deleteDigitalInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__deleteDigitalInfoResponse * SOAP_FMAC4 soap_in_ns1__deleteDigitalInfoResponse(struct soap *soap, const char *tag, ns1__deleteDigitalInfoResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__deleteDigitalInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteDigitalInfoResponse, sizeof(ns1__deleteDigitalInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__deleteDigitalInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__deleteDigitalInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__gingkoDigitalPack(soap, "return", &(a->ns1__deleteDigitalInfoResponse::return_), "ns1:gingkoDigitalPack"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__deleteDigitalInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteDigitalInfoResponse, 0, sizeof(ns1__deleteDigitalInfoResponse), 0, soap_copy_ns1__deleteDigitalInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__deleteDigitalInfoResponse * SOAP_FMAC4 soap_instantiate_ns1__deleteDigitalInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteDigitalInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteDigitalInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__deleteDigitalInfoResponse;
		if (size)
			*size = sizeof(ns1__deleteDigitalInfoResponse);
		((ns1__deleteDigitalInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__deleteDigitalInfoResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__deleteDigitalInfoResponse);
		for (int i = 0; i < n; i++)
			((ns1__deleteDigitalInfoResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__deleteDigitalInfoResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteDigitalInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__deleteDigitalInfoResponse %p -> %p\n", q, p));
	*(ns1__deleteDigitalInfoResponse*)p = *(ns1__deleteDigitalInfoResponse*)q;
}

void ns1__gingkoPermissionListPack::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__gingkoPermission(soap, &this->ns1__gingkoPermissionListPack::resultsList);
	this->ns1__gingkoPermissionListPack::message = NULL;
	this->ns1__gingkoPermissionListPack::status = NULL;
	/* transient soap skipped */
}

void ns1__gingkoPermissionListPack::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__gingkoPermission(soap, &this->ns1__gingkoPermissionListPack::resultsList);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__gingkoPermissionListPack::message);
	soap_serialize_PointerTons1__soapPackStatusEnum(soap, &this->ns1__gingkoPermissionListPack::status);
	/* transient soap skipped */
}

int ns1__gingkoPermissionListPack::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__gingkoPermissionListPack);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__gingkoPermissionListPack::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__gingkoPermissionListPack(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__gingkoPermissionListPack(struct soap *soap, const char *tag, int id, const ns1__gingkoPermissionListPack *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__gingkoPermissionListPack), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__gingkoPermission(soap, "resultsList", -1, &(a->ns1__gingkoPermissionListPack::resultsList), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "message", -1, &(a->ns1__gingkoPermissionListPack::message), ""))
		return soap->error;
	if (soap_out_PointerTons1__soapPackStatusEnum(soap, "status", -1, &(a->ns1__gingkoPermissionListPack::status), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__gingkoPermissionListPack::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__gingkoPermissionListPack(soap, this, tag, type);
}

SOAP_FMAC3 ns1__gingkoPermissionListPack * SOAP_FMAC4 soap_get_ns1__gingkoPermissionListPack(struct soap *soap, ns1__gingkoPermissionListPack *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__gingkoPermissionListPack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__gingkoPermissionListPack::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__gingkoPermissionListPack(soap, tag, this, type);
}

SOAP_FMAC3 ns1__gingkoPermissionListPack * SOAP_FMAC4 soap_in_ns1__gingkoPermissionListPack(struct soap *soap, const char *tag, ns1__gingkoPermissionListPack *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__gingkoPermissionListPack *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__gingkoPermissionListPack, sizeof(ns1__gingkoPermissionListPack), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__gingkoPermissionListPack)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__gingkoPermissionListPack *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message1 = 1;
	size_t soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__gingkoPermission(soap, "resultsList", &(a->ns1__gingkoPermissionListPack::resultsList), "ns1:gingkoPermission"))
					continue;
			if (soap_flag_message1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "message", &(a->ns1__gingkoPermissionListPack::message), "xsd:string"))
				{	soap_flag_message1--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__soapPackStatusEnum(soap, "status", &(a->ns1__gingkoPermissionListPack::status), "ns1:soapPackStatusEnum"))
				{	soap_flag_status1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__gingkoPermissionListPack *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__gingkoPermissionListPack, 0, sizeof(ns1__gingkoPermissionListPack), 0, soap_copy_ns1__gingkoPermissionListPack);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__gingkoPermissionListPack * SOAP_FMAC4 soap_instantiate_ns1__gingkoPermissionListPack(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__gingkoPermissionListPack(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__gingkoPermissionListPack, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__gingkoPermissionListPack;
		if (size)
			*size = sizeof(ns1__gingkoPermissionListPack);
		((ns1__gingkoPermissionListPack*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__gingkoPermissionListPack[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__gingkoPermissionListPack);
		for (int i = 0; i < n; i++)
			((ns1__gingkoPermissionListPack*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__gingkoPermissionListPack*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__gingkoPermissionListPack(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__gingkoPermissionListPack %p -> %p\n", q, p));
	*(ns1__gingkoPermissionListPack*)p = *(ns1__gingkoPermissionListPack*)q;
}

void ns1__findDigitalPermissionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__findDigitalPermissionResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__findDigitalPermissionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__gingkoPermissionPack(soap, &this->ns1__findDigitalPermissionResponse::return_);
	/* transient soap skipped */
}

int ns1__findDigitalPermissionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__findDigitalPermissionResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__findDigitalPermissionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__findDigitalPermissionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__findDigitalPermissionResponse(struct soap *soap, const char *tag, int id, const ns1__findDigitalPermissionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__findDigitalPermissionResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__gingkoPermissionPack(soap, "return", -1, &(a->ns1__findDigitalPermissionResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__findDigitalPermissionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__findDigitalPermissionResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__findDigitalPermissionResponse * SOAP_FMAC4 soap_get_ns1__findDigitalPermissionResponse(struct soap *soap, ns1__findDigitalPermissionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__findDigitalPermissionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__findDigitalPermissionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__findDigitalPermissionResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__findDigitalPermissionResponse * SOAP_FMAC4 soap_in_ns1__findDigitalPermissionResponse(struct soap *soap, const char *tag, ns1__findDigitalPermissionResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__findDigitalPermissionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__findDigitalPermissionResponse, sizeof(ns1__findDigitalPermissionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__findDigitalPermissionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__findDigitalPermissionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__gingkoPermissionPack(soap, "return", &(a->ns1__findDigitalPermissionResponse::return_), "ns1:gingkoPermissionPack"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__findDigitalPermissionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__findDigitalPermissionResponse, 0, sizeof(ns1__findDigitalPermissionResponse), 0, soap_copy_ns1__findDigitalPermissionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__findDigitalPermissionResponse * SOAP_FMAC4 soap_instantiate_ns1__findDigitalPermissionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__findDigitalPermissionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__findDigitalPermissionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__findDigitalPermissionResponse;
		if (size)
			*size = sizeof(ns1__findDigitalPermissionResponse);
		((ns1__findDigitalPermissionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__findDigitalPermissionResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__findDigitalPermissionResponse);
		for (int i = 0; i < n; i++)
			((ns1__findDigitalPermissionResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__findDigitalPermissionResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__findDigitalPermissionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__findDigitalPermissionResponse %p -> %p\n", q, p));
	*(ns1__findDigitalPermissionResponse*)p = *(ns1__findDigitalPermissionResponse*)q;
}

void ns1__updateDigitalInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__updateDigitalInfoResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__updateDigitalInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__gingkoDigitalPack(soap, &this->ns1__updateDigitalInfoResponse::return_);
	/* transient soap skipped */
}

int ns1__updateDigitalInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__updateDigitalInfoResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__updateDigitalInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__updateDigitalInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__updateDigitalInfoResponse(struct soap *soap, const char *tag, int id, const ns1__updateDigitalInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__updateDigitalInfoResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__gingkoDigitalPack(soap, "return", -1, &(a->ns1__updateDigitalInfoResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__updateDigitalInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__updateDigitalInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__updateDigitalInfoResponse * SOAP_FMAC4 soap_get_ns1__updateDigitalInfoResponse(struct soap *soap, ns1__updateDigitalInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__updateDigitalInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__updateDigitalInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__updateDigitalInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__updateDigitalInfoResponse * SOAP_FMAC4 soap_in_ns1__updateDigitalInfoResponse(struct soap *soap, const char *tag, ns1__updateDigitalInfoResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__updateDigitalInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__updateDigitalInfoResponse, sizeof(ns1__updateDigitalInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__updateDigitalInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__updateDigitalInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__gingkoDigitalPack(soap, "return", &(a->ns1__updateDigitalInfoResponse::return_), "ns1:gingkoDigitalPack"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__updateDigitalInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__updateDigitalInfoResponse, 0, sizeof(ns1__updateDigitalInfoResponse), 0, soap_copy_ns1__updateDigitalInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__updateDigitalInfoResponse * SOAP_FMAC4 soap_instantiate_ns1__updateDigitalInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__updateDigitalInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__updateDigitalInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__updateDigitalInfoResponse;
		if (size)
			*size = sizeof(ns1__updateDigitalInfoResponse);
		((ns1__updateDigitalInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__updateDigitalInfoResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__updateDigitalInfoResponse);
		for (int i = 0; i < n; i++)
			((ns1__updateDigitalInfoResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__updateDigitalInfoResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__updateDigitalInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__updateDigitalInfoResponse %p -> %p\n", q, p));
	*(ns1__updateDigitalInfoResponse*)p = *(ns1__updateDigitalInfoResponse*)q;
}

void ns1__deleteDigitalInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__deleteDigitalInfo::unitId = NULL;
	this->ns1__deleteDigitalInfo::digitalId = NULL;
	/* transient soap skipped */
}

void ns1__deleteDigitalInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__deleteDigitalInfo::unitId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__deleteDigitalInfo::digitalId);
	/* transient soap skipped */
}

int ns1__deleteDigitalInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__deleteDigitalInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__deleteDigitalInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__deleteDigitalInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteDigitalInfo(struct soap *soap, const char *tag, int id, const ns1__deleteDigitalInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteDigitalInfo), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "unitId", -1, &(a->ns1__deleteDigitalInfo::unitId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "digitalId", -1, &(a->ns1__deleteDigitalInfo::digitalId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__deleteDigitalInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__deleteDigitalInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__deleteDigitalInfo * SOAP_FMAC4 soap_get_ns1__deleteDigitalInfo(struct soap *soap, ns1__deleteDigitalInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteDigitalInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__deleteDigitalInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__deleteDigitalInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__deleteDigitalInfo * SOAP_FMAC4 soap_in_ns1__deleteDigitalInfo(struct soap *soap, const char *tag, ns1__deleteDigitalInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__deleteDigitalInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteDigitalInfo, sizeof(ns1__deleteDigitalInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__deleteDigitalInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__deleteDigitalInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_unitId1 = 1;
	size_t soap_flag_digitalId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_unitId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "unitId", &(a->ns1__deleteDigitalInfo::unitId), "xsd:string"))
				{	soap_flag_unitId1--;
					continue;
				}
			if (soap_flag_digitalId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "digitalId", &(a->ns1__deleteDigitalInfo::digitalId), "xsd:string"))
				{	soap_flag_digitalId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__deleteDigitalInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteDigitalInfo, 0, sizeof(ns1__deleteDigitalInfo), 0, soap_copy_ns1__deleteDigitalInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__deleteDigitalInfo * SOAP_FMAC4 soap_instantiate_ns1__deleteDigitalInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteDigitalInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteDigitalInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__deleteDigitalInfo;
		if (size)
			*size = sizeof(ns1__deleteDigitalInfo);
		((ns1__deleteDigitalInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__deleteDigitalInfo[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__deleteDigitalInfo);
		for (int i = 0; i < n; i++)
			((ns1__deleteDigitalInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__deleteDigitalInfo*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteDigitalInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__deleteDigitalInfo %p -> %p\n", q, p));
	*(ns1__deleteDigitalInfo*)p = *(ns1__deleteDigitalInfo*)q;
}

void ns1__digitalContent::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__digitalContent::author = NULL;
	this->ns1__digitalContent::description = NULL;
	this->ns1__digitalContent::digitalId = NULL;
	this->ns1__digitalContent::fileHash = NULL;
	this->ns1__digitalContent::title = NULL;
	this->ns1__digitalContent::keyword = NULL;
	this->ns1__digitalContent::owner = NULL;
	this->ns1__digitalContent::publicKey = NULL;
	this->ns1__digitalContent::privateKey = NULL;
	this->ns1__digitalContent::status = NULL;
	this->ns1__digitalContent::securityType = NULL;
	this->ns1__digitalContent::permissionType = NULL;
	this->ns1__digitalContent::limitationType = NULL;
	this->ns1__digitalContent::updatedBy = NULL;
	this->ns1__digitalContent::updatedTime = NULL;
	/* transient soap skipped */
}

void ns1__digitalContent::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__digitalContent::author);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__digitalContent::description);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__digitalContent::digitalId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__digitalContent::fileHash);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__digitalContent::title);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__digitalContent::keyword);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__digitalContent::owner);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__digitalContent::publicKey);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__digitalContent::privateKey);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__digitalContent::status);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__digitalContent::securityType);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__digitalContent::permissionType);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__digitalContent::limitationType);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__digitalContent::updatedBy);
	soap_serialize_PointerTotime(soap, &this->ns1__digitalContent::updatedTime);
	/* transient soap skipped */
}

int ns1__digitalContent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__digitalContent);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__digitalContent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__digitalContent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__digitalContent(struct soap *soap, const char *tag, int id, const ns1__digitalContent *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__digitalContent), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "author", -1, &(a->ns1__digitalContent::author), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "description", -1, &(a->ns1__digitalContent::description), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "digitalId", -1, &(a->ns1__digitalContent::digitalId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fileHash", -1, &(a->ns1__digitalContent::fileHash), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "title", -1, &(a->ns1__digitalContent::title), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "keyword", -1, &(a->ns1__digitalContent::keyword), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "owner", -1, &(a->ns1__digitalContent::owner), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "publicKey", -1, &(a->ns1__digitalContent::publicKey), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "privateKey", -1, &(a->ns1__digitalContent::privateKey), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "status", -1, &(a->ns1__digitalContent::status), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "securityType", -1, &(a->ns1__digitalContent::securityType), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "permissionType", -1, &(a->ns1__digitalContent::permissionType), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "limitationType", -1, &(a->ns1__digitalContent::limitationType), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "updatedBy", -1, &(a->ns1__digitalContent::updatedBy), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "updatedTime", -1, &(a->ns1__digitalContent::updatedTime), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__digitalContent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__digitalContent(soap, this, tag, type);
}

SOAP_FMAC3 ns1__digitalContent * SOAP_FMAC4 soap_get_ns1__digitalContent(struct soap *soap, ns1__digitalContent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__digitalContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__digitalContent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__digitalContent(soap, tag, this, type);
}

SOAP_FMAC3 ns1__digitalContent * SOAP_FMAC4 soap_in_ns1__digitalContent(struct soap *soap, const char *tag, ns1__digitalContent *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__digitalContent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__digitalContent, sizeof(ns1__digitalContent), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__digitalContent)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__digitalContent *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_author1 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_digitalId1 = 1;
	size_t soap_flag_fileHash1 = 1;
	size_t soap_flag_title1 = 1;
	size_t soap_flag_keyword1 = 1;
	size_t soap_flag_owner1 = 1;
	size_t soap_flag_publicKey1 = 1;
	size_t soap_flag_privateKey1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_securityType1 = 1;
	size_t soap_flag_permissionType1 = 1;
	size_t soap_flag_limitationType1 = 1;
	size_t soap_flag_updatedBy1 = 1;
	size_t soap_flag_updatedTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_author1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "author", &(a->ns1__digitalContent::author), "xsd:string"))
				{	soap_flag_author1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "description", &(a->ns1__digitalContent::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_digitalId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "digitalId", &(a->ns1__digitalContent::digitalId), "xsd:string"))
				{	soap_flag_digitalId1--;
					continue;
				}
			if (soap_flag_fileHash1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fileHash", &(a->ns1__digitalContent::fileHash), "xsd:string"))
				{	soap_flag_fileHash1--;
					continue;
				}
			if (soap_flag_title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "title", &(a->ns1__digitalContent::title), "xsd:string"))
				{	soap_flag_title1--;
					continue;
				}
			if (soap_flag_keyword1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "keyword", &(a->ns1__digitalContent::keyword), "xsd:string"))
				{	soap_flag_keyword1--;
					continue;
				}
			if (soap_flag_owner1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "owner", &(a->ns1__digitalContent::owner), "xsd:string"))
				{	soap_flag_owner1--;
					continue;
				}
			if (soap_flag_publicKey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "publicKey", &(a->ns1__digitalContent::publicKey), "xsd:string"))
				{	soap_flag_publicKey1--;
					continue;
				}
			if (soap_flag_privateKey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "privateKey", &(a->ns1__digitalContent::privateKey), "xsd:string"))
				{	soap_flag_privateKey1--;
					continue;
				}
			if (soap_flag_status1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "status", &(a->ns1__digitalContent::status), "xsd:string"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_securityType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "securityType", &(a->ns1__digitalContent::securityType), "xsd:string"))
				{	soap_flag_securityType1--;
					continue;
				}
			if (soap_flag_permissionType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "permissionType", &(a->ns1__digitalContent::permissionType), "xsd:string"))
				{	soap_flag_permissionType1--;
					continue;
				}
			if (soap_flag_limitationType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "limitationType", &(a->ns1__digitalContent::limitationType), "xsd:string"))
				{	soap_flag_limitationType1--;
					continue;
				}
			if (soap_flag_updatedBy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "updatedBy", &(a->ns1__digitalContent::updatedBy), "xsd:string"))
				{	soap_flag_updatedBy1--;
					continue;
				}
			if (soap_flag_updatedTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "updatedTime", &(a->ns1__digitalContent::updatedTime), "xsd:dateTime"))
				{	soap_flag_updatedTime1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__digitalContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__digitalContent, 0, sizeof(ns1__digitalContent), 0, soap_copy_ns1__digitalContent);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__digitalContent * SOAP_FMAC4 soap_instantiate_ns1__digitalContent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__digitalContent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__digitalContent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__digitalContent;
		if (size)
			*size = sizeof(ns1__digitalContent);
		((ns1__digitalContent*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__digitalContent[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__digitalContent);
		for (int i = 0; i < n; i++)
			((ns1__digitalContent*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__digitalContent*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__digitalContent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__digitalContent %p -> %p\n", q, p));
	*(ns1__digitalContent*)p = *(ns1__digitalContent*)q;
}

void ns1__gingkoDigitalPack::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__gingkoDigitalPack::digitalContent = NULL;
	this->ns1__gingkoDigitalPack::message = NULL;
	this->ns1__gingkoDigitalPack::status = NULL;
	/* transient soap skipped */
}

void ns1__gingkoDigitalPack::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__digitalContent(soap, &this->ns1__gingkoDigitalPack::digitalContent);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__gingkoDigitalPack::message);
	soap_serialize_PointerTons1__soapPackStatusEnum(soap, &this->ns1__gingkoDigitalPack::status);
	/* transient soap skipped */
}

int ns1__gingkoDigitalPack::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__gingkoDigitalPack);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__gingkoDigitalPack::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__gingkoDigitalPack(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__gingkoDigitalPack(struct soap *soap, const char *tag, int id, const ns1__gingkoDigitalPack *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__gingkoDigitalPack), type))
		return soap->error;
	if (soap_out_PointerTons1__digitalContent(soap, "digitalContent", -1, &(a->ns1__gingkoDigitalPack::digitalContent), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "message", -1, &(a->ns1__gingkoDigitalPack::message), ""))
		return soap->error;
	if (soap_out_PointerTons1__soapPackStatusEnum(soap, "status", -1, &(a->ns1__gingkoDigitalPack::status), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__gingkoDigitalPack::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__gingkoDigitalPack(soap, this, tag, type);
}

SOAP_FMAC3 ns1__gingkoDigitalPack * SOAP_FMAC4 soap_get_ns1__gingkoDigitalPack(struct soap *soap, ns1__gingkoDigitalPack *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__gingkoDigitalPack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__gingkoDigitalPack::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__gingkoDigitalPack(soap, tag, this, type);
}

SOAP_FMAC3 ns1__gingkoDigitalPack * SOAP_FMAC4 soap_in_ns1__gingkoDigitalPack(struct soap *soap, const char *tag, ns1__gingkoDigitalPack *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__gingkoDigitalPack *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__gingkoDigitalPack, sizeof(ns1__gingkoDigitalPack), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__gingkoDigitalPack)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__gingkoDigitalPack *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_digitalContent1 = 1;
	size_t soap_flag_message1 = 1;
	size_t soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_digitalContent1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__digitalContent(soap, "digitalContent", &(a->ns1__gingkoDigitalPack::digitalContent), "ns1:digitalContent"))
				{	soap_flag_digitalContent1--;
					continue;
				}
			if (soap_flag_message1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "message", &(a->ns1__gingkoDigitalPack::message), "xsd:string"))
				{	soap_flag_message1--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__soapPackStatusEnum(soap, "status", &(a->ns1__gingkoDigitalPack::status), "ns1:soapPackStatusEnum"))
				{	soap_flag_status1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__gingkoDigitalPack *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__gingkoDigitalPack, 0, sizeof(ns1__gingkoDigitalPack), 0, soap_copy_ns1__gingkoDigitalPack);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__gingkoDigitalPack * SOAP_FMAC4 soap_instantiate_ns1__gingkoDigitalPack(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__gingkoDigitalPack(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__gingkoDigitalPack, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__gingkoDigitalPack;
		if (size)
			*size = sizeof(ns1__gingkoDigitalPack);
		((ns1__gingkoDigitalPack*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__gingkoDigitalPack[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__gingkoDigitalPack);
		for (int i = 0; i < n; i++)
			((ns1__gingkoDigitalPack*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__gingkoDigitalPack*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__gingkoDigitalPack(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__gingkoDigitalPack %p -> %p\n", q, p));
	*(ns1__gingkoDigitalPack*)p = *(ns1__gingkoDigitalPack*)q;
}

void ns1__createDigitalInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__createDigitalInfoResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__createDigitalInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__gingkoDigitalPack(soap, &this->ns1__createDigitalInfoResponse::return_);
	/* transient soap skipped */
}

int ns1__createDigitalInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__createDigitalInfoResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__createDigitalInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__createDigitalInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__createDigitalInfoResponse(struct soap *soap, const char *tag, int id, const ns1__createDigitalInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__createDigitalInfoResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__gingkoDigitalPack(soap, "return", -1, &(a->ns1__createDigitalInfoResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__createDigitalInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__createDigitalInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__createDigitalInfoResponse * SOAP_FMAC4 soap_get_ns1__createDigitalInfoResponse(struct soap *soap, ns1__createDigitalInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__createDigitalInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__createDigitalInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__createDigitalInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__createDigitalInfoResponse * SOAP_FMAC4 soap_in_ns1__createDigitalInfoResponse(struct soap *soap, const char *tag, ns1__createDigitalInfoResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__createDigitalInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__createDigitalInfoResponse, sizeof(ns1__createDigitalInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__createDigitalInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__createDigitalInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__gingkoDigitalPack(soap, "return", &(a->ns1__createDigitalInfoResponse::return_), "ns1:gingkoDigitalPack"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__createDigitalInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__createDigitalInfoResponse, 0, sizeof(ns1__createDigitalInfoResponse), 0, soap_copy_ns1__createDigitalInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__createDigitalInfoResponse * SOAP_FMAC4 soap_instantiate_ns1__createDigitalInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__createDigitalInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__createDigitalInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__createDigitalInfoResponse;
		if (size)
			*size = sizeof(ns1__createDigitalInfoResponse);
		((ns1__createDigitalInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__createDigitalInfoResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__createDigitalInfoResponse);
		for (int i = 0; i < n; i++)
			((ns1__createDigitalInfoResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__createDigitalInfoResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__createDigitalInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__createDigitalInfoResponse %p -> %p\n", q, p));
	*(ns1__createDigitalInfoResponse*)p = *(ns1__createDigitalInfoResponse*)q;
}

void ns1__findAssignedPermission::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__findAssignedPermission::unitId = NULL;
	this->ns1__findAssignedPermission::digitalId = NULL;
	/* transient soap skipped */
}

void ns1__findAssignedPermission::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__findAssignedPermission::unitId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__findAssignedPermission::digitalId);
	/* transient soap skipped */
}

int ns1__findAssignedPermission::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__findAssignedPermission);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__findAssignedPermission::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__findAssignedPermission(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__findAssignedPermission(struct soap *soap, const char *tag, int id, const ns1__findAssignedPermission *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__findAssignedPermission), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "unitId", -1, &(a->ns1__findAssignedPermission::unitId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "digitalId", -1, &(a->ns1__findAssignedPermission::digitalId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__findAssignedPermission::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__findAssignedPermission(soap, this, tag, type);
}

SOAP_FMAC3 ns1__findAssignedPermission * SOAP_FMAC4 soap_get_ns1__findAssignedPermission(struct soap *soap, ns1__findAssignedPermission *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__findAssignedPermission(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__findAssignedPermission::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__findAssignedPermission(soap, tag, this, type);
}

SOAP_FMAC3 ns1__findAssignedPermission * SOAP_FMAC4 soap_in_ns1__findAssignedPermission(struct soap *soap, const char *tag, ns1__findAssignedPermission *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__findAssignedPermission *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__findAssignedPermission, sizeof(ns1__findAssignedPermission), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__findAssignedPermission)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__findAssignedPermission *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_unitId1 = 1;
	size_t soap_flag_digitalId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_unitId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "unitId", &(a->ns1__findAssignedPermission::unitId), "xsd:string"))
				{	soap_flag_unitId1--;
					continue;
				}
			if (soap_flag_digitalId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "digitalId", &(a->ns1__findAssignedPermission::digitalId), "xsd:string"))
				{	soap_flag_digitalId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__findAssignedPermission *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__findAssignedPermission, 0, sizeof(ns1__findAssignedPermission), 0, soap_copy_ns1__findAssignedPermission);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__findAssignedPermission * SOAP_FMAC4 soap_instantiate_ns1__findAssignedPermission(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__findAssignedPermission(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__findAssignedPermission, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__findAssignedPermission;
		if (size)
			*size = sizeof(ns1__findAssignedPermission);
		((ns1__findAssignedPermission*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__findAssignedPermission[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__findAssignedPermission);
		for (int i = 0; i < n; i++)
			((ns1__findAssignedPermission*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__findAssignedPermission*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__findAssignedPermission(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__findAssignedPermission %p -> %p\n", q, p));
	*(ns1__findAssignedPermission*)p = *(ns1__findAssignedPermission*)q;
}

void ns1__updateDigitalInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__updateDigitalInfo::digitalId = NULL;
	this->ns1__updateDigitalInfo::author = NULL;
	this->ns1__updateDigitalInfo::description = NULL;
	this->ns1__updateDigitalInfo::title = NULL;
	this->ns1__updateDigitalInfo::keyword = NULL;
	this->ns1__updateDigitalInfo::status = NULL;
	this->ns1__updateDigitalInfo::securityType = NULL;
	this->ns1__updateDigitalInfo::permissionType = NULL;
	this->ns1__updateDigitalInfo::limitationType = NULL;
	/* transient soap skipped */
}

void ns1__updateDigitalInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__updateDigitalInfo::digitalId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__updateDigitalInfo::author);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__updateDigitalInfo::description);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__updateDigitalInfo::title);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__updateDigitalInfo::keyword);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__updateDigitalInfo::status);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__updateDigitalInfo::securityType);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__updateDigitalInfo::permissionType);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__updateDigitalInfo::limitationType);
	/* transient soap skipped */
}

int ns1__updateDigitalInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__updateDigitalInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__updateDigitalInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__updateDigitalInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__updateDigitalInfo(struct soap *soap, const char *tag, int id, const ns1__updateDigitalInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__updateDigitalInfo), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "digitalId", -1, &(a->ns1__updateDigitalInfo::digitalId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "author", -1, &(a->ns1__updateDigitalInfo::author), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "description", -1, &(a->ns1__updateDigitalInfo::description), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "title", -1, &(a->ns1__updateDigitalInfo::title), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "keyword", -1, &(a->ns1__updateDigitalInfo::keyword), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "status", -1, &(a->ns1__updateDigitalInfo::status), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "securityType", -1, &(a->ns1__updateDigitalInfo::securityType), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "permissionType", -1, &(a->ns1__updateDigitalInfo::permissionType), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "limitationType", -1, &(a->ns1__updateDigitalInfo::limitationType), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__updateDigitalInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__updateDigitalInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__updateDigitalInfo * SOAP_FMAC4 soap_get_ns1__updateDigitalInfo(struct soap *soap, ns1__updateDigitalInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__updateDigitalInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__updateDigitalInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__updateDigitalInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__updateDigitalInfo * SOAP_FMAC4 soap_in_ns1__updateDigitalInfo(struct soap *soap, const char *tag, ns1__updateDigitalInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__updateDigitalInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__updateDigitalInfo, sizeof(ns1__updateDigitalInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__updateDigitalInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__updateDigitalInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_digitalId1 = 1;
	size_t soap_flag_author1 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_title1 = 1;
	size_t soap_flag_keyword1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_securityType1 = 1;
	size_t soap_flag_permissionType1 = 1;
	size_t soap_flag_limitationType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_digitalId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "digitalId", &(a->ns1__updateDigitalInfo::digitalId), "xsd:string"))
				{	soap_flag_digitalId1--;
					continue;
				}
			if (soap_flag_author1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "author", &(a->ns1__updateDigitalInfo::author), "xsd:string"))
				{	soap_flag_author1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "description", &(a->ns1__updateDigitalInfo::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "title", &(a->ns1__updateDigitalInfo::title), "xsd:string"))
				{	soap_flag_title1--;
					continue;
				}
			if (soap_flag_keyword1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "keyword", &(a->ns1__updateDigitalInfo::keyword), "xsd:string"))
				{	soap_flag_keyword1--;
					continue;
				}
			if (soap_flag_status1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "status", &(a->ns1__updateDigitalInfo::status), "xsd:string"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_securityType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "securityType", &(a->ns1__updateDigitalInfo::securityType), "xsd:string"))
				{	soap_flag_securityType1--;
					continue;
				}
			if (soap_flag_permissionType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "permissionType", &(a->ns1__updateDigitalInfo::permissionType), "xsd:string"))
				{	soap_flag_permissionType1--;
					continue;
				}
			if (soap_flag_limitationType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "limitationType", &(a->ns1__updateDigitalInfo::limitationType), "xsd:string"))
				{	soap_flag_limitationType1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__updateDigitalInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__updateDigitalInfo, 0, sizeof(ns1__updateDigitalInfo), 0, soap_copy_ns1__updateDigitalInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__updateDigitalInfo * SOAP_FMAC4 soap_instantiate_ns1__updateDigitalInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__updateDigitalInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__updateDigitalInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__updateDigitalInfo;
		if (size)
			*size = sizeof(ns1__updateDigitalInfo);
		((ns1__updateDigitalInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__updateDigitalInfo[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__updateDigitalInfo);
		for (int i = 0; i < n; i++)
			((ns1__updateDigitalInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__updateDigitalInfo*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__updateDigitalInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__updateDigitalInfo %p -> %p\n", q, p));
	*(ns1__updateDigitalInfo*)p = *(ns1__updateDigitalInfo*)q;
}

void ns1__findDigitalInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__findDigitalInfo::unitId = NULL;
	this->ns1__findDigitalInfo::digitalId = NULL;
	/* transient soap skipped */
}

void ns1__findDigitalInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__findDigitalInfo::unitId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__findDigitalInfo::digitalId);
	/* transient soap skipped */
}

int ns1__findDigitalInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__findDigitalInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__findDigitalInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__findDigitalInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__findDigitalInfo(struct soap *soap, const char *tag, int id, const ns1__findDigitalInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__findDigitalInfo), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "unitId", -1, &(a->ns1__findDigitalInfo::unitId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "digitalId", -1, &(a->ns1__findDigitalInfo::digitalId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__findDigitalInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__findDigitalInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__findDigitalInfo * SOAP_FMAC4 soap_get_ns1__findDigitalInfo(struct soap *soap, ns1__findDigitalInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__findDigitalInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__findDigitalInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__findDigitalInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__findDigitalInfo * SOAP_FMAC4 soap_in_ns1__findDigitalInfo(struct soap *soap, const char *tag, ns1__findDigitalInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__findDigitalInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__findDigitalInfo, sizeof(ns1__findDigitalInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__findDigitalInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__findDigitalInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_unitId1 = 1;
	size_t soap_flag_digitalId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_unitId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "unitId", &(a->ns1__findDigitalInfo::unitId), "xsd:string"))
				{	soap_flag_unitId1--;
					continue;
				}
			if (soap_flag_digitalId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "digitalId", &(a->ns1__findDigitalInfo::digitalId), "xsd:string"))
				{	soap_flag_digitalId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__findDigitalInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__findDigitalInfo, 0, sizeof(ns1__findDigitalInfo), 0, soap_copy_ns1__findDigitalInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__findDigitalInfo * SOAP_FMAC4 soap_instantiate_ns1__findDigitalInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__findDigitalInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__findDigitalInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__findDigitalInfo;
		if (size)
			*size = sizeof(ns1__findDigitalInfo);
		((ns1__findDigitalInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__findDigitalInfo[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__findDigitalInfo);
		for (int i = 0; i < n; i++)
			((ns1__findDigitalInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__findDigitalInfo*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__findDigitalInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__findDigitalInfo %p -> %p\n", q, p));
	*(ns1__findDigitalInfo*)p = *(ns1__findDigitalInfo*)q;
}

void ns1__bindingGingkoUserResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__bindingGingkoUserResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__bindingGingkoUserResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__gingkoUserPack(soap, &this->ns1__bindingGingkoUserResponse::return_);
	/* transient soap skipped */
}

int ns1__bindingGingkoUserResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__bindingGingkoUserResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__bindingGingkoUserResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__bindingGingkoUserResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__bindingGingkoUserResponse(struct soap *soap, const char *tag, int id, const ns1__bindingGingkoUserResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__bindingGingkoUserResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__gingkoUserPack(soap, "return", -1, &(a->ns1__bindingGingkoUserResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__bindingGingkoUserResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__bindingGingkoUserResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__bindingGingkoUserResponse * SOAP_FMAC4 soap_get_ns1__bindingGingkoUserResponse(struct soap *soap, ns1__bindingGingkoUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__bindingGingkoUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__bindingGingkoUserResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__bindingGingkoUserResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__bindingGingkoUserResponse * SOAP_FMAC4 soap_in_ns1__bindingGingkoUserResponse(struct soap *soap, const char *tag, ns1__bindingGingkoUserResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__bindingGingkoUserResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__bindingGingkoUserResponse, sizeof(ns1__bindingGingkoUserResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__bindingGingkoUserResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__bindingGingkoUserResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__gingkoUserPack(soap, "return", &(a->ns1__bindingGingkoUserResponse::return_), "ns1:gingkoUserPack"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__bindingGingkoUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__bindingGingkoUserResponse, 0, sizeof(ns1__bindingGingkoUserResponse), 0, soap_copy_ns1__bindingGingkoUserResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__bindingGingkoUserResponse * SOAP_FMAC4 soap_instantiate_ns1__bindingGingkoUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__bindingGingkoUserResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__bindingGingkoUserResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__bindingGingkoUserResponse;
		if (size)
			*size = sizeof(ns1__bindingGingkoUserResponse);
		((ns1__bindingGingkoUserResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__bindingGingkoUserResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__bindingGingkoUserResponse);
		for (int i = 0; i < n; i++)
			((ns1__bindingGingkoUserResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__bindingGingkoUserResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__bindingGingkoUserResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__bindingGingkoUserResponse %p -> %p\n", q, p));
	*(ns1__bindingGingkoUserResponse*)p = *(ns1__bindingGingkoUserResponse*)q;
}

void ns1__findUserByLoginIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__findUserByLoginIdResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__findUserByLoginIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__gingkoUserPack(soap, &this->ns1__findUserByLoginIdResponse::return_);
	/* transient soap skipped */
}

int ns1__findUserByLoginIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__findUserByLoginIdResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__findUserByLoginIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__findUserByLoginIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__findUserByLoginIdResponse(struct soap *soap, const char *tag, int id, const ns1__findUserByLoginIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__findUserByLoginIdResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__gingkoUserPack(soap, "return", -1, &(a->ns1__findUserByLoginIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__findUserByLoginIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__findUserByLoginIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__findUserByLoginIdResponse * SOAP_FMAC4 soap_get_ns1__findUserByLoginIdResponse(struct soap *soap, ns1__findUserByLoginIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__findUserByLoginIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__findUserByLoginIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__findUserByLoginIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__findUserByLoginIdResponse * SOAP_FMAC4 soap_in_ns1__findUserByLoginIdResponse(struct soap *soap, const char *tag, ns1__findUserByLoginIdResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__findUserByLoginIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__findUserByLoginIdResponse, sizeof(ns1__findUserByLoginIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__findUserByLoginIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__findUserByLoginIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__gingkoUserPack(soap, "return", &(a->ns1__findUserByLoginIdResponse::return_), "ns1:gingkoUserPack"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__findUserByLoginIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__findUserByLoginIdResponse, 0, sizeof(ns1__findUserByLoginIdResponse), 0, soap_copy_ns1__findUserByLoginIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__findUserByLoginIdResponse * SOAP_FMAC4 soap_instantiate_ns1__findUserByLoginIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__findUserByLoginIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__findUserByLoginIdResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__findUserByLoginIdResponse;
		if (size)
			*size = sizeof(ns1__findUserByLoginIdResponse);
		((ns1__findUserByLoginIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__findUserByLoginIdResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__findUserByLoginIdResponse);
		for (int i = 0; i < n; i++)
			((ns1__findUserByLoginIdResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__findUserByLoginIdResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__findUserByLoginIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__findUserByLoginIdResponse %p -> %p\n", q, p));
	*(ns1__findUserByLoginIdResponse*)p = *(ns1__findUserByLoginIdResponse*)q;
}

void ns1__findUserByLoginId::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__findUserByLoginId::loginId = NULL;
	/* transient soap skipped */
}

void ns1__findUserByLoginId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__findUserByLoginId::loginId);
	/* transient soap skipped */
}

int ns1__findUserByLoginId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__findUserByLoginId);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__findUserByLoginId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__findUserByLoginId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__findUserByLoginId(struct soap *soap, const char *tag, int id, const ns1__findUserByLoginId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__findUserByLoginId), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "loginId", -1, &(a->ns1__findUserByLoginId::loginId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__findUserByLoginId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__findUserByLoginId(soap, this, tag, type);
}

SOAP_FMAC3 ns1__findUserByLoginId * SOAP_FMAC4 soap_get_ns1__findUserByLoginId(struct soap *soap, ns1__findUserByLoginId *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__findUserByLoginId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__findUserByLoginId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__findUserByLoginId(soap, tag, this, type);
}

SOAP_FMAC3 ns1__findUserByLoginId * SOAP_FMAC4 soap_in_ns1__findUserByLoginId(struct soap *soap, const char *tag, ns1__findUserByLoginId *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__findUserByLoginId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__findUserByLoginId, sizeof(ns1__findUserByLoginId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__findUserByLoginId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__findUserByLoginId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_loginId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_loginId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "loginId", &(a->ns1__findUserByLoginId::loginId), "xsd:string"))
				{	soap_flag_loginId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__findUserByLoginId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__findUserByLoginId, 0, sizeof(ns1__findUserByLoginId), 0, soap_copy_ns1__findUserByLoginId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__findUserByLoginId * SOAP_FMAC4 soap_instantiate_ns1__findUserByLoginId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__findUserByLoginId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__findUserByLoginId, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__findUserByLoginId;
		if (size)
			*size = sizeof(ns1__findUserByLoginId);
		((ns1__findUserByLoginId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__findUserByLoginId[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__findUserByLoginId);
		for (int i = 0; i < n; i++)
			((ns1__findUserByLoginId*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__findUserByLoginId*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__findUserByLoginId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__findUserByLoginId %p -> %p\n", q, p));
	*(ns1__findUserByLoginId*)p = *(ns1__findUserByLoginId*)q;
}

void ns1__findUserByGingkoIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__findUserByGingkoIdResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__findUserByGingkoIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__gingkoUserPack(soap, &this->ns1__findUserByGingkoIdResponse::return_);
	/* transient soap skipped */
}

int ns1__findUserByGingkoIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__findUserByGingkoIdResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__findUserByGingkoIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__findUserByGingkoIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__findUserByGingkoIdResponse(struct soap *soap, const char *tag, int id, const ns1__findUserByGingkoIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__findUserByGingkoIdResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__gingkoUserPack(soap, "return", -1, &(a->ns1__findUserByGingkoIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__findUserByGingkoIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__findUserByGingkoIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__findUserByGingkoIdResponse * SOAP_FMAC4 soap_get_ns1__findUserByGingkoIdResponse(struct soap *soap, ns1__findUserByGingkoIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__findUserByGingkoIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__findUserByGingkoIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__findUserByGingkoIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__findUserByGingkoIdResponse * SOAP_FMAC4 soap_in_ns1__findUserByGingkoIdResponse(struct soap *soap, const char *tag, ns1__findUserByGingkoIdResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__findUserByGingkoIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__findUserByGingkoIdResponse, sizeof(ns1__findUserByGingkoIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__findUserByGingkoIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__findUserByGingkoIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__gingkoUserPack(soap, "return", &(a->ns1__findUserByGingkoIdResponse::return_), "ns1:gingkoUserPack"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__findUserByGingkoIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__findUserByGingkoIdResponse, 0, sizeof(ns1__findUserByGingkoIdResponse), 0, soap_copy_ns1__findUserByGingkoIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__findUserByGingkoIdResponse * SOAP_FMAC4 soap_instantiate_ns1__findUserByGingkoIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__findUserByGingkoIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__findUserByGingkoIdResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__findUserByGingkoIdResponse;
		if (size)
			*size = sizeof(ns1__findUserByGingkoIdResponse);
		((ns1__findUserByGingkoIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__findUserByGingkoIdResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__findUserByGingkoIdResponse);
		for (int i = 0; i < n; i++)
			((ns1__findUserByGingkoIdResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__findUserByGingkoIdResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__findUserByGingkoIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__findUserByGingkoIdResponse %p -> %p\n", q, p));
	*(ns1__findUserByGingkoIdResponse*)p = *(ns1__findUserByGingkoIdResponse*)q;
}

void ns1__findUserByGingkoId::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__findUserByGingkoId::gingkoId = NULL;
	/* transient soap skipped */
}

void ns1__findUserByGingkoId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__findUserByGingkoId::gingkoId);
	/* transient soap skipped */
}

int ns1__findUserByGingkoId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__findUserByGingkoId);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__findUserByGingkoId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__findUserByGingkoId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__findUserByGingkoId(struct soap *soap, const char *tag, int id, const ns1__findUserByGingkoId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__findUserByGingkoId), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "gingkoId", -1, &(a->ns1__findUserByGingkoId::gingkoId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__findUserByGingkoId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__findUserByGingkoId(soap, this, tag, type);
}

SOAP_FMAC3 ns1__findUserByGingkoId * SOAP_FMAC4 soap_get_ns1__findUserByGingkoId(struct soap *soap, ns1__findUserByGingkoId *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__findUserByGingkoId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__findUserByGingkoId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__findUserByGingkoId(soap, tag, this, type);
}

SOAP_FMAC3 ns1__findUserByGingkoId * SOAP_FMAC4 soap_in_ns1__findUserByGingkoId(struct soap *soap, const char *tag, ns1__findUserByGingkoId *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__findUserByGingkoId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__findUserByGingkoId, sizeof(ns1__findUserByGingkoId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__findUserByGingkoId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__findUserByGingkoId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_gingkoId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_gingkoId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "gingkoId", &(a->ns1__findUserByGingkoId::gingkoId), "xsd:string"))
				{	soap_flag_gingkoId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__findUserByGingkoId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__findUserByGingkoId, 0, sizeof(ns1__findUserByGingkoId), 0, soap_copy_ns1__findUserByGingkoId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__findUserByGingkoId * SOAP_FMAC4 soap_instantiate_ns1__findUserByGingkoId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__findUserByGingkoId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__findUserByGingkoId, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__findUserByGingkoId;
		if (size)
			*size = sizeof(ns1__findUserByGingkoId);
		((ns1__findUserByGingkoId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__findUserByGingkoId[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__findUserByGingkoId);
		for (int i = 0; i < n; i++)
			((ns1__findUserByGingkoId*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__findUserByGingkoId*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__findUserByGingkoId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__findUserByGingkoId %p -> %p\n", q, p));
	*(ns1__findUserByGingkoId*)p = *(ns1__findUserByGingkoId*)q;
}

void ns1__changePasswordResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__changePasswordResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__changePasswordResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__gingkoUserPack(soap, &this->ns1__changePasswordResponse::return_);
	/* transient soap skipped */
}

int ns1__changePasswordResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__changePasswordResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__changePasswordResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__changePasswordResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__changePasswordResponse(struct soap *soap, const char *tag, int id, const ns1__changePasswordResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__changePasswordResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__gingkoUserPack(soap, "return", -1, &(a->ns1__changePasswordResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__changePasswordResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__changePasswordResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__changePasswordResponse * SOAP_FMAC4 soap_get_ns1__changePasswordResponse(struct soap *soap, ns1__changePasswordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__changePasswordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__changePasswordResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__changePasswordResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__changePasswordResponse * SOAP_FMAC4 soap_in_ns1__changePasswordResponse(struct soap *soap, const char *tag, ns1__changePasswordResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__changePasswordResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__changePasswordResponse, sizeof(ns1__changePasswordResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__changePasswordResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__changePasswordResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__gingkoUserPack(soap, "return", &(a->ns1__changePasswordResponse::return_), "ns1:gingkoUserPack"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__changePasswordResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__changePasswordResponse, 0, sizeof(ns1__changePasswordResponse), 0, soap_copy_ns1__changePasswordResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__changePasswordResponse * SOAP_FMAC4 soap_instantiate_ns1__changePasswordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__changePasswordResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__changePasswordResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__changePasswordResponse;
		if (size)
			*size = sizeof(ns1__changePasswordResponse);
		((ns1__changePasswordResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__changePasswordResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__changePasswordResponse);
		for (int i = 0; i < n; i++)
			((ns1__changePasswordResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__changePasswordResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__changePasswordResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__changePasswordResponse %p -> %p\n", q, p));
	*(ns1__changePasswordResponse*)p = *(ns1__changePasswordResponse*)q;
}

void ns1__changePassword::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__changePassword::loginId = NULL;
	this->ns1__changePassword::oldPassword = NULL;
	this->ns1__changePassword::newPassword = NULL;
	/* transient soap skipped */
}

void ns1__changePassword::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__changePassword::loginId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__changePassword::oldPassword);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__changePassword::newPassword);
	/* transient soap skipped */
}

int ns1__changePassword::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__changePassword);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__changePassword::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__changePassword(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__changePassword(struct soap *soap, const char *tag, int id, const ns1__changePassword *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__changePassword), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "loginId", -1, &(a->ns1__changePassword::loginId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "oldPassword", -1, &(a->ns1__changePassword::oldPassword), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "newPassword", -1, &(a->ns1__changePassword::newPassword), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__changePassword::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__changePassword(soap, this, tag, type);
}

SOAP_FMAC3 ns1__changePassword * SOAP_FMAC4 soap_get_ns1__changePassword(struct soap *soap, ns1__changePassword *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__changePassword(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__changePassword::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__changePassword(soap, tag, this, type);
}

SOAP_FMAC3 ns1__changePassword * SOAP_FMAC4 soap_in_ns1__changePassword(struct soap *soap, const char *tag, ns1__changePassword *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__changePassword *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__changePassword, sizeof(ns1__changePassword), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__changePassword)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__changePassword *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_loginId1 = 1;
	size_t soap_flag_oldPassword1 = 1;
	size_t soap_flag_newPassword1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_loginId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "loginId", &(a->ns1__changePassword::loginId), "xsd:string"))
				{	soap_flag_loginId1--;
					continue;
				}
			if (soap_flag_oldPassword1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "oldPassword", &(a->ns1__changePassword::oldPassword), "xsd:string"))
				{	soap_flag_oldPassword1--;
					continue;
				}
			if (soap_flag_newPassword1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "newPassword", &(a->ns1__changePassword::newPassword), "xsd:string"))
				{	soap_flag_newPassword1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__changePassword *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__changePassword, 0, sizeof(ns1__changePassword), 0, soap_copy_ns1__changePassword);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__changePassword * SOAP_FMAC4 soap_instantiate_ns1__changePassword(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__changePassword(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__changePassword, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__changePassword;
		if (size)
			*size = sizeof(ns1__changePassword);
		((ns1__changePassword*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__changePassword[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__changePassword);
		for (int i = 0; i < n; i++)
			((ns1__changePassword*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__changePassword*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__changePassword(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__changePassword %p -> %p\n", q, p));
	*(ns1__changePassword*)p = *(ns1__changePassword*)q;
}

void ns1__bindingGingkoUser::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__bindingGingkoUser::loginId = NULL;
	this->ns1__bindingGingkoUser::thePassword = NULL;
	this->ns1__bindingGingkoUser::theDisplayName = NULL;
	/* transient soap skipped */
}

void ns1__bindingGingkoUser::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__bindingGingkoUser::loginId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__bindingGingkoUser::thePassword);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__bindingGingkoUser::theDisplayName);
	/* transient soap skipped */
}

int ns1__bindingGingkoUser::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__bindingGingkoUser);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__bindingGingkoUser::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__bindingGingkoUser(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__bindingGingkoUser(struct soap *soap, const char *tag, int id, const ns1__bindingGingkoUser *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__bindingGingkoUser), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "loginId", -1, &(a->ns1__bindingGingkoUser::loginId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "thePassword", -1, &(a->ns1__bindingGingkoUser::thePassword), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "theDisplayName", -1, &(a->ns1__bindingGingkoUser::theDisplayName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__bindingGingkoUser::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__bindingGingkoUser(soap, this, tag, type);
}

SOAP_FMAC3 ns1__bindingGingkoUser * SOAP_FMAC4 soap_get_ns1__bindingGingkoUser(struct soap *soap, ns1__bindingGingkoUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__bindingGingkoUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__bindingGingkoUser::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__bindingGingkoUser(soap, tag, this, type);
}

SOAP_FMAC3 ns1__bindingGingkoUser * SOAP_FMAC4 soap_in_ns1__bindingGingkoUser(struct soap *soap, const char *tag, ns1__bindingGingkoUser *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__bindingGingkoUser *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__bindingGingkoUser, sizeof(ns1__bindingGingkoUser), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__bindingGingkoUser)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__bindingGingkoUser *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_loginId1 = 1;
	size_t soap_flag_thePassword1 = 1;
	size_t soap_flag_theDisplayName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_loginId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "loginId", &(a->ns1__bindingGingkoUser::loginId), "xsd:string"))
				{	soap_flag_loginId1--;
					continue;
				}
			if (soap_flag_thePassword1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "thePassword", &(a->ns1__bindingGingkoUser::thePassword), "xsd:string"))
				{	soap_flag_thePassword1--;
					continue;
				}
			if (soap_flag_theDisplayName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "theDisplayName", &(a->ns1__bindingGingkoUser::theDisplayName), "xsd:string"))
				{	soap_flag_theDisplayName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__bindingGingkoUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__bindingGingkoUser, 0, sizeof(ns1__bindingGingkoUser), 0, soap_copy_ns1__bindingGingkoUser);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__bindingGingkoUser * SOAP_FMAC4 soap_instantiate_ns1__bindingGingkoUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__bindingGingkoUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__bindingGingkoUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__bindingGingkoUser;
		if (size)
			*size = sizeof(ns1__bindingGingkoUser);
		((ns1__bindingGingkoUser*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__bindingGingkoUser[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__bindingGingkoUser);
		for (int i = 0; i < n; i++)
			((ns1__bindingGingkoUser*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__bindingGingkoUser*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__bindingGingkoUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__bindingGingkoUser %p -> %p\n", q, p));
	*(ns1__bindingGingkoUser*)p = *(ns1__bindingGingkoUser*)q;
}

void ns1__requestPermissionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__requestPermissionResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__requestPermissionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__gingkoPermissionPack(soap, &this->ns1__requestPermissionResponse::return_);
	/* transient soap skipped */
}

int ns1__requestPermissionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__requestPermissionResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__requestPermissionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__requestPermissionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__requestPermissionResponse(struct soap *soap, const char *tag, int id, const ns1__requestPermissionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__requestPermissionResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__gingkoPermissionPack(soap, "return", -1, &(a->ns1__requestPermissionResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__requestPermissionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__requestPermissionResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__requestPermissionResponse * SOAP_FMAC4 soap_get_ns1__requestPermissionResponse(struct soap *soap, ns1__requestPermissionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__requestPermissionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__requestPermissionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__requestPermissionResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__requestPermissionResponse * SOAP_FMAC4 soap_in_ns1__requestPermissionResponse(struct soap *soap, const char *tag, ns1__requestPermissionResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__requestPermissionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__requestPermissionResponse, sizeof(ns1__requestPermissionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__requestPermissionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__requestPermissionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__gingkoPermissionPack(soap, "return", &(a->ns1__requestPermissionResponse::return_), "ns1:gingkoPermissionPack"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__requestPermissionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__requestPermissionResponse, 0, sizeof(ns1__requestPermissionResponse), 0, soap_copy_ns1__requestPermissionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__requestPermissionResponse * SOAP_FMAC4 soap_instantiate_ns1__requestPermissionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__requestPermissionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__requestPermissionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__requestPermissionResponse;
		if (size)
			*size = sizeof(ns1__requestPermissionResponse);
		((ns1__requestPermissionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__requestPermissionResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__requestPermissionResponse);
		for (int i = 0; i < n; i++)
			((ns1__requestPermissionResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__requestPermissionResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__requestPermissionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__requestPermissionResponse %p -> %p\n", q, p));
	*(ns1__requestPermissionResponse*)p = *(ns1__requestPermissionResponse*)q;
}

void ns1__requestPermission::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__requestPermission::unitId = NULL;
	this->ns1__requestPermission::digitalId = NULL;
	this->ns1__requestPermission::gingkoId = NULL;
	soap_default_bool(soap, &this->ns1__requestPermission::isOwner);
	soap_default_bool(soap, &this->ns1__requestPermission::isHolder);
	soap_default_bool(soap, &this->ns1__requestPermission::readable);
	soap_default_bool(soap, &this->ns1__requestPermission::writable);
	soap_default_bool(soap, &this->ns1__requestPermission::printable);
	soap_default_bool(soap, &this->ns1__requestPermission::deletable);
	this->ns1__requestPermission::message = NULL;
	/* transient soap skipped */
}

void ns1__requestPermission::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__requestPermission::unitId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__requestPermission::digitalId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__requestPermission::gingkoId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__requestPermission::message);
	/* transient soap skipped */
}

int ns1__requestPermission::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__requestPermission);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__requestPermission::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__requestPermission(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__requestPermission(struct soap *soap, const char *tag, int id, const ns1__requestPermission *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__requestPermission), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "unitId", -1, &(a->ns1__requestPermission::unitId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "digitalId", -1, &(a->ns1__requestPermission::digitalId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "gingkoId", -1, &(a->ns1__requestPermission::gingkoId), ""))
		return soap->error;
	if (soap_out_bool(soap, "isOwner", -1, &(a->ns1__requestPermission::isOwner), ""))
		return soap->error;
	if (soap_out_bool(soap, "isHolder", -1, &(a->ns1__requestPermission::isHolder), ""))
		return soap->error;
	if (soap_out_bool(soap, "readable", -1, &(a->ns1__requestPermission::readable), ""))
		return soap->error;
	if (soap_out_bool(soap, "writable", -1, &(a->ns1__requestPermission::writable), ""))
		return soap->error;
	if (soap_out_bool(soap, "printable", -1, &(a->ns1__requestPermission::printable), ""))
		return soap->error;
	if (soap_out_bool(soap, "deletable", -1, &(a->ns1__requestPermission::deletable), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "message", -1, &(a->ns1__requestPermission::message), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__requestPermission::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__requestPermission(soap, this, tag, type);
}

SOAP_FMAC3 ns1__requestPermission * SOAP_FMAC4 soap_get_ns1__requestPermission(struct soap *soap, ns1__requestPermission *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__requestPermission(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__requestPermission::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__requestPermission(soap, tag, this, type);
}

SOAP_FMAC3 ns1__requestPermission * SOAP_FMAC4 soap_in_ns1__requestPermission(struct soap *soap, const char *tag, ns1__requestPermission *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__requestPermission *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__requestPermission, sizeof(ns1__requestPermission), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__requestPermission)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__requestPermission *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_unitId1 = 1;
	size_t soap_flag_digitalId1 = 1;
	size_t soap_flag_gingkoId1 = 1;
	size_t soap_flag_isOwner1 = 1;
	size_t soap_flag_isHolder1 = 1;
	size_t soap_flag_readable1 = 1;
	size_t soap_flag_writable1 = 1;
	size_t soap_flag_printable1 = 1;
	size_t soap_flag_deletable1 = 1;
	size_t soap_flag_message1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_unitId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "unitId", &(a->ns1__requestPermission::unitId), "xsd:string"))
				{	soap_flag_unitId1--;
					continue;
				}
			if (soap_flag_digitalId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "digitalId", &(a->ns1__requestPermission::digitalId), "xsd:string"))
				{	soap_flag_digitalId1--;
					continue;
				}
			if (soap_flag_gingkoId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "gingkoId", &(a->ns1__requestPermission::gingkoId), "xsd:string"))
				{	soap_flag_gingkoId1--;
					continue;
				}
			if (soap_flag_isOwner1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "isOwner", &(a->ns1__requestPermission::isOwner), "xsd:boolean"))
				{	soap_flag_isOwner1--;
					continue;
				}
			if (soap_flag_isHolder1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "isHolder", &(a->ns1__requestPermission::isHolder), "xsd:boolean"))
				{	soap_flag_isHolder1--;
					continue;
				}
			if (soap_flag_readable1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "readable", &(a->ns1__requestPermission::readable), "xsd:boolean"))
				{	soap_flag_readable1--;
					continue;
				}
			if (soap_flag_writable1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "writable", &(a->ns1__requestPermission::writable), "xsd:boolean"))
				{	soap_flag_writable1--;
					continue;
				}
			if (soap_flag_printable1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "printable", &(a->ns1__requestPermission::printable), "xsd:boolean"))
				{	soap_flag_printable1--;
					continue;
				}
			if (soap_flag_deletable1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "deletable", &(a->ns1__requestPermission::deletable), "xsd:boolean"))
				{	soap_flag_deletable1--;
					continue;
				}
			if (soap_flag_message1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "message", &(a->ns1__requestPermission::message), "xsd:string"))
				{	soap_flag_message1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__requestPermission *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__requestPermission, 0, sizeof(ns1__requestPermission), 0, soap_copy_ns1__requestPermission);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_isOwner1 > 0 || soap_flag_isHolder1 > 0 || soap_flag_readable1 > 0 || soap_flag_writable1 > 0 || soap_flag_printable1 > 0 || soap_flag_deletable1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__requestPermission * SOAP_FMAC4 soap_instantiate_ns1__requestPermission(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__requestPermission(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__requestPermission, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__requestPermission;
		if (size)
			*size = sizeof(ns1__requestPermission);
		((ns1__requestPermission*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__requestPermission[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__requestPermission);
		for (int i = 0; i < n; i++)
			((ns1__requestPermission*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__requestPermission*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__requestPermission(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__requestPermission %p -> %p\n", q, p));
	*(ns1__requestPermission*)p = *(ns1__requestPermission*)q;
}

void ns1__gingkoPermission::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__gingkoPermission::digitalId = NULL;
	this->ns1__gingkoPermission::gingkoId = NULL;
	this->ns1__gingkoPermission::loginId = NULL;
	this->ns1__gingkoPermission::userName = NULL;
	soap_default_bool(soap, &this->ns1__gingkoPermission::activated);
	soap_default_bool(soap, &this->ns1__gingkoPermission::holder);
	soap_default_bool(soap, &this->ns1__gingkoPermission::owner);
	soap_default_bool(soap, &this->ns1__gingkoPermission::readable);
	soap_default_bool(soap, &this->ns1__gingkoPermission::writable);
	soap_default_bool(soap, &this->ns1__gingkoPermission::printable);
	soap_default_bool(soap, &this->ns1__gingkoPermission::deletable);
	this->ns1__gingkoPermission::assignedBy = NULL;
	this->ns1__gingkoPermission::assignedByName = NULL;
	this->ns1__gingkoPermission::updatedTime = NULL;
	/* transient soap skipped */
}

void ns1__gingkoPermission::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__gingkoPermission::digitalId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__gingkoPermission::gingkoId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__gingkoPermission::loginId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__gingkoPermission::userName);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__gingkoPermission::assignedBy);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__gingkoPermission::assignedByName);
	soap_serialize_PointerTotime(soap, &this->ns1__gingkoPermission::updatedTime);
	/* transient soap skipped */
}

int ns1__gingkoPermission::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__gingkoPermission);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__gingkoPermission::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__gingkoPermission(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__gingkoPermission(struct soap *soap, const char *tag, int id, const ns1__gingkoPermission *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__gingkoPermission), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "digitalId", -1, &(a->ns1__gingkoPermission::digitalId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "gingkoId", -1, &(a->ns1__gingkoPermission::gingkoId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "loginId", -1, &(a->ns1__gingkoPermission::loginId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "userName", -1, &(a->ns1__gingkoPermission::userName), ""))
		return soap->error;
	if (soap_out_bool(soap, "activated", -1, &(a->ns1__gingkoPermission::activated), ""))
		return soap->error;
	if (soap_out_bool(soap, "holder", -1, &(a->ns1__gingkoPermission::holder), ""))
		return soap->error;
	if (soap_out_bool(soap, "owner", -1, &(a->ns1__gingkoPermission::owner), ""))
		return soap->error;
	if (soap_out_bool(soap, "readable", -1, &(a->ns1__gingkoPermission::readable), ""))
		return soap->error;
	if (soap_out_bool(soap, "writable", -1, &(a->ns1__gingkoPermission::writable), ""))
		return soap->error;
	if (soap_out_bool(soap, "printable", -1, &(a->ns1__gingkoPermission::printable), ""))
		return soap->error;
	if (soap_out_bool(soap, "deletable", -1, &(a->ns1__gingkoPermission::deletable), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "assignedBy", -1, &(a->ns1__gingkoPermission::assignedBy), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "assignedByName", -1, &(a->ns1__gingkoPermission::assignedByName), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "updatedTime", -1, &(a->ns1__gingkoPermission::updatedTime), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__gingkoPermission::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__gingkoPermission(soap, this, tag, type);
}

SOAP_FMAC3 ns1__gingkoPermission * SOAP_FMAC4 soap_get_ns1__gingkoPermission(struct soap *soap, ns1__gingkoPermission *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__gingkoPermission(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__gingkoPermission::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__gingkoPermission(soap, tag, this, type);
}

SOAP_FMAC3 ns1__gingkoPermission * SOAP_FMAC4 soap_in_ns1__gingkoPermission(struct soap *soap, const char *tag, ns1__gingkoPermission *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__gingkoPermission *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__gingkoPermission, sizeof(ns1__gingkoPermission), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__gingkoPermission)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__gingkoPermission *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_digitalId1 = 1;
	size_t soap_flag_gingkoId1 = 1;
	size_t soap_flag_loginId1 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_activated1 = 1;
	size_t soap_flag_holder1 = 1;
	size_t soap_flag_owner1 = 1;
	size_t soap_flag_readable1 = 1;
	size_t soap_flag_writable1 = 1;
	size_t soap_flag_printable1 = 1;
	size_t soap_flag_deletable1 = 1;
	size_t soap_flag_assignedBy1 = 1;
	size_t soap_flag_assignedByName1 = 1;
	size_t soap_flag_updatedTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_digitalId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "digitalId", &(a->ns1__gingkoPermission::digitalId), "xsd:string"))
				{	soap_flag_digitalId1--;
					continue;
				}
			if (soap_flag_gingkoId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "gingkoId", &(a->ns1__gingkoPermission::gingkoId), "xsd:string"))
				{	soap_flag_gingkoId1--;
					continue;
				}
			if (soap_flag_loginId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "loginId", &(a->ns1__gingkoPermission::loginId), "xsd:string"))
				{	soap_flag_loginId1--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "userName", &(a->ns1__gingkoPermission::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_activated1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "activated", &(a->ns1__gingkoPermission::activated), "xsd:boolean"))
				{	soap_flag_activated1--;
					continue;
				}
			if (soap_flag_holder1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "holder", &(a->ns1__gingkoPermission::holder), "xsd:boolean"))
				{	soap_flag_holder1--;
					continue;
				}
			if (soap_flag_owner1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "owner", &(a->ns1__gingkoPermission::owner), "xsd:boolean"))
				{	soap_flag_owner1--;
					continue;
				}
			if (soap_flag_readable1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "readable", &(a->ns1__gingkoPermission::readable), "xsd:boolean"))
				{	soap_flag_readable1--;
					continue;
				}
			if (soap_flag_writable1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "writable", &(a->ns1__gingkoPermission::writable), "xsd:boolean"))
				{	soap_flag_writable1--;
					continue;
				}
			if (soap_flag_printable1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "printable", &(a->ns1__gingkoPermission::printable), "xsd:boolean"))
				{	soap_flag_printable1--;
					continue;
				}
			if (soap_flag_deletable1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "deletable", &(a->ns1__gingkoPermission::deletable), "xsd:boolean"))
				{	soap_flag_deletable1--;
					continue;
				}
			if (soap_flag_assignedBy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "assignedBy", &(a->ns1__gingkoPermission::assignedBy), "xsd:string"))
				{	soap_flag_assignedBy1--;
					continue;
				}
			if (soap_flag_assignedByName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "assignedByName", &(a->ns1__gingkoPermission::assignedByName), "xsd:string"))
				{	soap_flag_assignedByName1--;
					continue;
				}
			if (soap_flag_updatedTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "updatedTime", &(a->ns1__gingkoPermission::updatedTime), "xsd:dateTime"))
				{	soap_flag_updatedTime1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__gingkoPermission *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__gingkoPermission, 0, sizeof(ns1__gingkoPermission), 0, soap_copy_ns1__gingkoPermission);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_activated1 > 0 || soap_flag_holder1 > 0 || soap_flag_owner1 > 0 || soap_flag_readable1 > 0 || soap_flag_writable1 > 0 || soap_flag_printable1 > 0 || soap_flag_deletable1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__gingkoPermission * SOAP_FMAC4 soap_instantiate_ns1__gingkoPermission(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__gingkoPermission(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__gingkoPermission, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__gingkoPermission;
		if (size)
			*size = sizeof(ns1__gingkoPermission);
		((ns1__gingkoPermission*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__gingkoPermission[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__gingkoPermission);
		for (int i = 0; i < n; i++)
			((ns1__gingkoPermission*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__gingkoPermission*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__gingkoPermission(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__gingkoPermission %p -> %p\n", q, p));
	*(ns1__gingkoPermission*)p = *(ns1__gingkoPermission*)q;
}

void ns1__gingkoPermissionPack::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__gingkoPermissionPack::permission = NULL;
	this->ns1__gingkoPermissionPack::message = NULL;
	this->ns1__gingkoPermissionPack::status = NULL;
	soap_default_bool(soap, &this->ns1__gingkoPermissionPack::deleted);
	this->ns1__gingkoPermissionPack::privateKey = NULL;
	this->ns1__gingkoPermissionPack::publicKey = NULL;
	/* transient soap skipped */
}

void ns1__gingkoPermissionPack::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__gingkoPermission(soap, &this->ns1__gingkoPermissionPack::permission);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__gingkoPermissionPack::message);
	soap_serialize_PointerTons1__soapPackStatusEnum(soap, &this->ns1__gingkoPermissionPack::status);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__gingkoPermissionPack::privateKey);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__gingkoPermissionPack::publicKey);
	/* transient soap skipped */
}

int ns1__gingkoPermissionPack::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__gingkoPermissionPack);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__gingkoPermissionPack::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__gingkoPermissionPack(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__gingkoPermissionPack(struct soap *soap, const char *tag, int id, const ns1__gingkoPermissionPack *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__gingkoPermissionPack), type))
		return soap->error;
	if (soap_out_PointerTons1__gingkoPermission(soap, "permission", -1, &(a->ns1__gingkoPermissionPack::permission), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "message", -1, &(a->ns1__gingkoPermissionPack::message), ""))
		return soap->error;
	if (soap_out_PointerTons1__soapPackStatusEnum(soap, "status", -1, &(a->ns1__gingkoPermissionPack::status), ""))
		return soap->error;
	if (soap_out_bool(soap, "deleted", -1, &(a->ns1__gingkoPermissionPack::deleted), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "privateKey", -1, &(a->ns1__gingkoPermissionPack::privateKey), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "publicKey", -1, &(a->ns1__gingkoPermissionPack::publicKey), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__gingkoPermissionPack::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__gingkoPermissionPack(soap, this, tag, type);
}

SOAP_FMAC3 ns1__gingkoPermissionPack * SOAP_FMAC4 soap_get_ns1__gingkoPermissionPack(struct soap *soap, ns1__gingkoPermissionPack *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__gingkoPermissionPack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__gingkoPermissionPack::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__gingkoPermissionPack(soap, tag, this, type);
}

SOAP_FMAC3 ns1__gingkoPermissionPack * SOAP_FMAC4 soap_in_ns1__gingkoPermissionPack(struct soap *soap, const char *tag, ns1__gingkoPermissionPack *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__gingkoPermissionPack *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__gingkoPermissionPack, sizeof(ns1__gingkoPermissionPack), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__gingkoPermissionPack)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__gingkoPermissionPack *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_permission1 = 1;
	size_t soap_flag_message1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_deleted1 = 1;
	size_t soap_flag_privateKey1 = 1;
	size_t soap_flag_publicKey1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_permission1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__gingkoPermission(soap, "permission", &(a->ns1__gingkoPermissionPack::permission), "ns1:gingkoPermission"))
				{	soap_flag_permission1--;
					continue;
				}
			if (soap_flag_message1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "message", &(a->ns1__gingkoPermissionPack::message), "xsd:string"))
				{	soap_flag_message1--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__soapPackStatusEnum(soap, "status", &(a->ns1__gingkoPermissionPack::status), "ns1:soapPackStatusEnum"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_deleted1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "deleted", &(a->ns1__gingkoPermissionPack::deleted), "xsd:boolean"))
				{	soap_flag_deleted1--;
					continue;
				}
			if (soap_flag_privateKey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "privateKey", &(a->ns1__gingkoPermissionPack::privateKey), "xsd:string"))
				{	soap_flag_privateKey1--;
					continue;
				}
			if (soap_flag_publicKey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "publicKey", &(a->ns1__gingkoPermissionPack::publicKey), "xsd:string"))
				{	soap_flag_publicKey1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__gingkoPermissionPack *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__gingkoPermissionPack, 0, sizeof(ns1__gingkoPermissionPack), 0, soap_copy_ns1__gingkoPermissionPack);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_deleted1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__gingkoPermissionPack * SOAP_FMAC4 soap_instantiate_ns1__gingkoPermissionPack(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__gingkoPermissionPack(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__gingkoPermissionPack, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__gingkoPermissionPack;
		if (size)
			*size = sizeof(ns1__gingkoPermissionPack);
		((ns1__gingkoPermissionPack*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__gingkoPermissionPack[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__gingkoPermissionPack);
		for (int i = 0; i < n; i++)
			((ns1__gingkoPermissionPack*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__gingkoPermissionPack*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__gingkoPermissionPack(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__gingkoPermissionPack %p -> %p\n", q, p));
	*(ns1__gingkoPermissionPack*)p = *(ns1__gingkoPermissionPack*)q;
}

void ns1__assignPermissionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__assignPermissionResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__assignPermissionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__gingkoPermissionPack(soap, &this->ns1__assignPermissionResponse::return_);
	/* transient soap skipped */
}

int ns1__assignPermissionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__assignPermissionResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__assignPermissionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__assignPermissionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__assignPermissionResponse(struct soap *soap, const char *tag, int id, const ns1__assignPermissionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__assignPermissionResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__gingkoPermissionPack(soap, "return", -1, &(a->ns1__assignPermissionResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__assignPermissionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__assignPermissionResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__assignPermissionResponse * SOAP_FMAC4 soap_get_ns1__assignPermissionResponse(struct soap *soap, ns1__assignPermissionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__assignPermissionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__assignPermissionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__assignPermissionResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__assignPermissionResponse * SOAP_FMAC4 soap_in_ns1__assignPermissionResponse(struct soap *soap, const char *tag, ns1__assignPermissionResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__assignPermissionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__assignPermissionResponse, sizeof(ns1__assignPermissionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__assignPermissionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__assignPermissionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__gingkoPermissionPack(soap, "return", &(a->ns1__assignPermissionResponse::return_), "ns1:gingkoPermissionPack"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__assignPermissionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__assignPermissionResponse, 0, sizeof(ns1__assignPermissionResponse), 0, soap_copy_ns1__assignPermissionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__assignPermissionResponse * SOAP_FMAC4 soap_instantiate_ns1__assignPermissionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__assignPermissionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__assignPermissionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__assignPermissionResponse;
		if (size)
			*size = sizeof(ns1__assignPermissionResponse);
		((ns1__assignPermissionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__assignPermissionResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__assignPermissionResponse);
		for (int i = 0; i < n; i++)
			((ns1__assignPermissionResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__assignPermissionResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__assignPermissionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__assignPermissionResponse %p -> %p\n", q, p));
	*(ns1__assignPermissionResponse*)p = *(ns1__assignPermissionResponse*)q;
}

void ns1__assignPermission::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__assignPermission::unitId = NULL;
	this->ns1__assignPermission::digitalId = NULL;
	this->ns1__assignPermission::loginId = NULL;
	this->ns1__assignPermission::gingkoId = NULL;
	soap_default_bool(soap, &this->ns1__assignPermission::isOwner);
	soap_default_bool(soap, &this->ns1__assignPermission::isHolder);
	soap_default_bool(soap, &this->ns1__assignPermission::readable);
	soap_default_bool(soap, &this->ns1__assignPermission::writable);
	soap_default_bool(soap, &this->ns1__assignPermission::printable);
	soap_default_bool(soap, &this->ns1__assignPermission::deletable);
	soap_default_bool(soap, &this->ns1__assignPermission::actived);
	/* transient soap skipped */
}

void ns1__assignPermission::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__assignPermission::unitId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__assignPermission::digitalId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__assignPermission::loginId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__assignPermission::gingkoId);
	/* transient soap skipped */
}

int ns1__assignPermission::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__assignPermission);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__assignPermission::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__assignPermission(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__assignPermission(struct soap *soap, const char *tag, int id, const ns1__assignPermission *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__assignPermission), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "unitId", -1, &(a->ns1__assignPermission::unitId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "digitalId", -1, &(a->ns1__assignPermission::digitalId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "loginId", -1, &(a->ns1__assignPermission::loginId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "gingkoId", -1, &(a->ns1__assignPermission::gingkoId), ""))
		return soap->error;
	if (soap_out_bool(soap, "isOwner", -1, &(a->ns1__assignPermission::isOwner), ""))
		return soap->error;
	if (soap_out_bool(soap, "isHolder", -1, &(a->ns1__assignPermission::isHolder), ""))
		return soap->error;
	if (soap_out_bool(soap, "readable", -1, &(a->ns1__assignPermission::readable), ""))
		return soap->error;
	if (soap_out_bool(soap, "writable", -1, &(a->ns1__assignPermission::writable), ""))
		return soap->error;
	if (soap_out_bool(soap, "printable", -1, &(a->ns1__assignPermission::printable), ""))
		return soap->error;
	if (soap_out_bool(soap, "deletable", -1, &(a->ns1__assignPermission::deletable), ""))
		return soap->error;
	if (soap_out_bool(soap, "actived", -1, &(a->ns1__assignPermission::actived), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__assignPermission::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__assignPermission(soap, this, tag, type);
}

SOAP_FMAC3 ns1__assignPermission * SOAP_FMAC4 soap_get_ns1__assignPermission(struct soap *soap, ns1__assignPermission *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__assignPermission(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__assignPermission::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__assignPermission(soap, tag, this, type);
}

SOAP_FMAC3 ns1__assignPermission * SOAP_FMAC4 soap_in_ns1__assignPermission(struct soap *soap, const char *tag, ns1__assignPermission *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__assignPermission *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__assignPermission, sizeof(ns1__assignPermission), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__assignPermission)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__assignPermission *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_unitId1 = 1;
	size_t soap_flag_digitalId1 = 1;
	size_t soap_flag_loginId1 = 1;
	size_t soap_flag_gingkoId1 = 1;
	size_t soap_flag_isOwner1 = 1;
	size_t soap_flag_isHolder1 = 1;
	size_t soap_flag_readable1 = 1;
	size_t soap_flag_writable1 = 1;
	size_t soap_flag_printable1 = 1;
	size_t soap_flag_deletable1 = 1;
	size_t soap_flag_actived1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_unitId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "unitId", &(a->ns1__assignPermission::unitId), "xsd:string"))
				{	soap_flag_unitId1--;
					continue;
				}
			if (soap_flag_digitalId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "digitalId", &(a->ns1__assignPermission::digitalId), "xsd:string"))
				{	soap_flag_digitalId1--;
					continue;
				}
			if (soap_flag_loginId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "loginId", &(a->ns1__assignPermission::loginId), "xsd:string"))
				{	soap_flag_loginId1--;
					continue;
				}
			if (soap_flag_gingkoId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "gingkoId", &(a->ns1__assignPermission::gingkoId), "xsd:string"))
				{	soap_flag_gingkoId1--;
					continue;
				}
			if (soap_flag_isOwner1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "isOwner", &(a->ns1__assignPermission::isOwner), "xsd:boolean"))
				{	soap_flag_isOwner1--;
					continue;
				}
			if (soap_flag_isHolder1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "isHolder", &(a->ns1__assignPermission::isHolder), "xsd:boolean"))
				{	soap_flag_isHolder1--;
					continue;
				}
			if (soap_flag_readable1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "readable", &(a->ns1__assignPermission::readable), "xsd:boolean"))
				{	soap_flag_readable1--;
					continue;
				}
			if (soap_flag_writable1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "writable", &(a->ns1__assignPermission::writable), "xsd:boolean"))
				{	soap_flag_writable1--;
					continue;
				}
			if (soap_flag_printable1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "printable", &(a->ns1__assignPermission::printable), "xsd:boolean"))
				{	soap_flag_printable1--;
					continue;
				}
			if (soap_flag_deletable1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "deletable", &(a->ns1__assignPermission::deletable), "xsd:boolean"))
				{	soap_flag_deletable1--;
					continue;
				}
			if (soap_flag_actived1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "actived", &(a->ns1__assignPermission::actived), "xsd:boolean"))
				{	soap_flag_actived1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__assignPermission *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__assignPermission, 0, sizeof(ns1__assignPermission), 0, soap_copy_ns1__assignPermission);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_isOwner1 > 0 || soap_flag_isHolder1 > 0 || soap_flag_readable1 > 0 || soap_flag_writable1 > 0 || soap_flag_printable1 > 0 || soap_flag_deletable1 > 0 || soap_flag_actived1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__assignPermission * SOAP_FMAC4 soap_instantiate_ns1__assignPermission(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__assignPermission(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__assignPermission, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__assignPermission;
		if (size)
			*size = sizeof(ns1__assignPermission);
		((ns1__assignPermission*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__assignPermission[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__assignPermission);
		for (int i = 0; i < n; i++)
			((ns1__assignPermission*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__assignPermission*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__assignPermission(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__assignPermission %p -> %p\n", q, p));
	*(ns1__assignPermission*)p = *(ns1__assignPermission*)q;
}

void ns1__checkTokenResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__checkTokenResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__checkTokenResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__gingkoUserPack(soap, &this->ns1__checkTokenResponse::return_);
	/* transient soap skipped */
}

int ns1__checkTokenResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__checkTokenResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__checkTokenResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__checkTokenResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__checkTokenResponse(struct soap *soap, const char *tag, int id, const ns1__checkTokenResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__checkTokenResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__gingkoUserPack(soap, "return", -1, &(a->ns1__checkTokenResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__checkTokenResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__checkTokenResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__checkTokenResponse * SOAP_FMAC4 soap_get_ns1__checkTokenResponse(struct soap *soap, ns1__checkTokenResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__checkTokenResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__checkTokenResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__checkTokenResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__checkTokenResponse * SOAP_FMAC4 soap_in_ns1__checkTokenResponse(struct soap *soap, const char *tag, ns1__checkTokenResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__checkTokenResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__checkTokenResponse, sizeof(ns1__checkTokenResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__checkTokenResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__checkTokenResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__gingkoUserPack(soap, "return", &(a->ns1__checkTokenResponse::return_), "ns1:gingkoUserPack"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__checkTokenResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__checkTokenResponse, 0, sizeof(ns1__checkTokenResponse), 0, soap_copy_ns1__checkTokenResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__checkTokenResponse * SOAP_FMAC4 soap_instantiate_ns1__checkTokenResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__checkTokenResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__checkTokenResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__checkTokenResponse;
		if (size)
			*size = sizeof(ns1__checkTokenResponse);
		((ns1__checkTokenResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__checkTokenResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__checkTokenResponse);
		for (int i = 0; i < n; i++)
			((ns1__checkTokenResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__checkTokenResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__checkTokenResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__checkTokenResponse %p -> %p\n", q, p));
	*(ns1__checkTokenResponse*)p = *(ns1__checkTokenResponse*)q;
}

void ns1__checkToken::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__checkToken::token = NULL;
	/* transient soap skipped */
}

void ns1__checkToken::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__checkToken::token);
	/* transient soap skipped */
}

int ns1__checkToken::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__checkToken);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__checkToken::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__checkToken(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__checkToken(struct soap *soap, const char *tag, int id, const ns1__checkToken *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__checkToken), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "token", -1, &(a->ns1__checkToken::token), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__checkToken::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__checkToken(soap, this, tag, type);
}

SOAP_FMAC3 ns1__checkToken * SOAP_FMAC4 soap_get_ns1__checkToken(struct soap *soap, ns1__checkToken *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__checkToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__checkToken::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__checkToken(soap, tag, this, type);
}

SOAP_FMAC3 ns1__checkToken * SOAP_FMAC4 soap_in_ns1__checkToken(struct soap *soap, const char *tag, ns1__checkToken *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__checkToken *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__checkToken, sizeof(ns1__checkToken), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__checkToken)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__checkToken *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_token1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "token", &(a->ns1__checkToken::token), "xsd:string"))
				{	soap_flag_token1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__checkToken *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__checkToken, 0, sizeof(ns1__checkToken), 0, soap_copy_ns1__checkToken);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__checkToken * SOAP_FMAC4 soap_instantiate_ns1__checkToken(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__checkToken(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__checkToken, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__checkToken;
		if (size)
			*size = sizeof(ns1__checkToken);
		((ns1__checkToken*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__checkToken[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__checkToken);
		for (int i = 0; i < n; i++)
			((ns1__checkToken*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__checkToken*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__checkToken(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__checkToken %p -> %p\n", q, p));
	*(ns1__checkToken*)p = *(ns1__checkToken*)q;
}

void ns1__stringPack::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__stringPack::result = NULL;
	this->ns1__stringPack::message = NULL;
	this->ns1__stringPack::status = NULL;
	/* transient soap skipped */
}

void ns1__stringPack::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__stringPack::result);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__stringPack::message);
	soap_serialize_PointerTons1__soapPackStatusEnum(soap, &this->ns1__stringPack::status);
	/* transient soap skipped */
}

int ns1__stringPack::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__stringPack);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__stringPack::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__stringPack(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__stringPack(struct soap *soap, const char *tag, int id, const ns1__stringPack *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__stringPack), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "result", -1, &(a->ns1__stringPack::result), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "message", -1, &(a->ns1__stringPack::message), ""))
		return soap->error;
	if (soap_out_PointerTons1__soapPackStatusEnum(soap, "status", -1, &(a->ns1__stringPack::status), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__stringPack::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__stringPack(soap, this, tag, type);
}

SOAP_FMAC3 ns1__stringPack * SOAP_FMAC4 soap_get_ns1__stringPack(struct soap *soap, ns1__stringPack *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__stringPack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__stringPack::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__stringPack(soap, tag, this, type);
}

SOAP_FMAC3 ns1__stringPack * SOAP_FMAC4 soap_in_ns1__stringPack(struct soap *soap, const char *tag, ns1__stringPack *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__stringPack *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__stringPack, sizeof(ns1__stringPack), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__stringPack)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__stringPack *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_result1 = 1;
	size_t soap_flag_message1 = 1;
	size_t soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "result", &(a->ns1__stringPack::result), "xsd:string"))
				{	soap_flag_result1--;
					continue;
				}
			if (soap_flag_message1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "message", &(a->ns1__stringPack::message), "xsd:string"))
				{	soap_flag_message1--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__soapPackStatusEnum(soap, "status", &(a->ns1__stringPack::status), "ns1:soapPackStatusEnum"))
				{	soap_flag_status1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__stringPack *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__stringPack, 0, sizeof(ns1__stringPack), 0, soap_copy_ns1__stringPack);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__stringPack * SOAP_FMAC4 soap_instantiate_ns1__stringPack(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__stringPack(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__stringPack, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__stringPack;
		if (size)
			*size = sizeof(ns1__stringPack);
		((ns1__stringPack*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__stringPack[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__stringPack);
		for (int i = 0; i < n; i++)
			((ns1__stringPack*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__stringPack*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__stringPack(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__stringPack %p -> %p\n", q, p));
	*(ns1__stringPack*)p = *(ns1__stringPack*)q;
}

void ns1__newGingkoIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__newGingkoIdResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__newGingkoIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__stringPack(soap, &this->ns1__newGingkoIdResponse::return_);
	/* transient soap skipped */
}

int ns1__newGingkoIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__newGingkoIdResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__newGingkoIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__newGingkoIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__newGingkoIdResponse(struct soap *soap, const char *tag, int id, const ns1__newGingkoIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__newGingkoIdResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__stringPack(soap, "return", -1, &(a->ns1__newGingkoIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__newGingkoIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__newGingkoIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__newGingkoIdResponse * SOAP_FMAC4 soap_get_ns1__newGingkoIdResponse(struct soap *soap, ns1__newGingkoIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__newGingkoIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__newGingkoIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__newGingkoIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__newGingkoIdResponse * SOAP_FMAC4 soap_in_ns1__newGingkoIdResponse(struct soap *soap, const char *tag, ns1__newGingkoIdResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__newGingkoIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__newGingkoIdResponse, sizeof(ns1__newGingkoIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__newGingkoIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__newGingkoIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__stringPack(soap, "return", &(a->ns1__newGingkoIdResponse::return_), "ns1:stringPack"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__newGingkoIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__newGingkoIdResponse, 0, sizeof(ns1__newGingkoIdResponse), 0, soap_copy_ns1__newGingkoIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__newGingkoIdResponse * SOAP_FMAC4 soap_instantiate_ns1__newGingkoIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__newGingkoIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__newGingkoIdResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__newGingkoIdResponse;
		if (size)
			*size = sizeof(ns1__newGingkoIdResponse);
		((ns1__newGingkoIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__newGingkoIdResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__newGingkoIdResponse);
		for (int i = 0; i < n; i++)
			((ns1__newGingkoIdResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__newGingkoIdResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__newGingkoIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__newGingkoIdResponse %p -> %p\n", q, p));
	*(ns1__newGingkoIdResponse*)p = *(ns1__newGingkoIdResponse*)q;
}

void ns1__newGingkoId::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void ns1__newGingkoId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__newGingkoId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__newGingkoId);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__newGingkoId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__newGingkoId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__newGingkoId(struct soap *soap, const char *tag, int id, const ns1__newGingkoId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__newGingkoId), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__newGingkoId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__newGingkoId(soap, this, tag, type);
}

SOAP_FMAC3 ns1__newGingkoId * SOAP_FMAC4 soap_get_ns1__newGingkoId(struct soap *soap, ns1__newGingkoId *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__newGingkoId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__newGingkoId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__newGingkoId(soap, tag, this, type);
}

SOAP_FMAC3 ns1__newGingkoId * SOAP_FMAC4 soap_in_ns1__newGingkoId(struct soap *soap, const char *tag, ns1__newGingkoId *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__newGingkoId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__newGingkoId, sizeof(ns1__newGingkoId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__newGingkoId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__newGingkoId *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__newGingkoId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__newGingkoId, 0, sizeof(ns1__newGingkoId), 0, soap_copy_ns1__newGingkoId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__newGingkoId * SOAP_FMAC4 soap_instantiate_ns1__newGingkoId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__newGingkoId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__newGingkoId, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__newGingkoId;
		if (size)
			*size = sizeof(ns1__newGingkoId);
		((ns1__newGingkoId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__newGingkoId[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__newGingkoId);
		for (int i = 0; i < n; i++)
			((ns1__newGingkoId*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__newGingkoId*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__newGingkoId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__newGingkoId %p -> %p\n", q, p));
	*(ns1__newGingkoId*)p = *(ns1__newGingkoId*)q;
}

void ns1__gingkoVersionPack::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__gingkoVersionPack::version = NULL;
	soap_default_int(soap, &this->ns1__gingkoVersionPack::major);
	soap_default_int(soap, &this->ns1__gingkoVersionPack::middle);
	soap_default_int(soap, &this->ns1__gingkoVersionPack::minor);
	this->ns1__gingkoVersionPack::servicePack = NULL;
	this->ns1__gingkoVersionPack::message = NULL;
	this->ns1__gingkoVersionPack::status = NULL;
	/* transient soap skipped */
}

void ns1__gingkoVersionPack::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__gingkoVersionPack::version);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__gingkoVersionPack::servicePack);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__gingkoVersionPack::message);
	soap_serialize_PointerTons1__soapPackStatusEnum(soap, &this->ns1__gingkoVersionPack::status);
	/* transient soap skipped */
}

int ns1__gingkoVersionPack::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__gingkoVersionPack);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__gingkoVersionPack::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__gingkoVersionPack(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__gingkoVersionPack(struct soap *soap, const char *tag, int id, const ns1__gingkoVersionPack *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__gingkoVersionPack), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "version", -1, &(a->ns1__gingkoVersionPack::version), ""))
		return soap->error;
	if (soap_out_int(soap, "major", -1, &(a->ns1__gingkoVersionPack::major), ""))
		return soap->error;
	if (soap_out_int(soap, "middle", -1, &(a->ns1__gingkoVersionPack::middle), ""))
		return soap->error;
	if (soap_out_int(soap, "minor", -1, &(a->ns1__gingkoVersionPack::minor), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "servicePack", -1, &(a->ns1__gingkoVersionPack::servicePack), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "message", -1, &(a->ns1__gingkoVersionPack::message), ""))
		return soap->error;
	if (soap_out_PointerTons1__soapPackStatusEnum(soap, "status", -1, &(a->ns1__gingkoVersionPack::status), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__gingkoVersionPack::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__gingkoVersionPack(soap, this, tag, type);
}

SOAP_FMAC3 ns1__gingkoVersionPack * SOAP_FMAC4 soap_get_ns1__gingkoVersionPack(struct soap *soap, ns1__gingkoVersionPack *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__gingkoVersionPack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__gingkoVersionPack::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__gingkoVersionPack(soap, tag, this, type);
}

SOAP_FMAC3 ns1__gingkoVersionPack * SOAP_FMAC4 soap_in_ns1__gingkoVersionPack(struct soap *soap, const char *tag, ns1__gingkoVersionPack *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__gingkoVersionPack *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__gingkoVersionPack, sizeof(ns1__gingkoVersionPack), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__gingkoVersionPack)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__gingkoVersionPack *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_version1 = 1;
	size_t soap_flag_major1 = 1;
	size_t soap_flag_middle1 = 1;
	size_t soap_flag_minor1 = 1;
	size_t soap_flag_servicePack1 = 1;
	size_t soap_flag_message1 = 1;
	size_t soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_version1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "version", &(a->ns1__gingkoVersionPack::version), "xsd:string"))
				{	soap_flag_version1--;
					continue;
				}
			if (soap_flag_major1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "major", &(a->ns1__gingkoVersionPack::major), "xsd:int"))
				{	soap_flag_major1--;
					continue;
				}
			if (soap_flag_middle1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "middle", &(a->ns1__gingkoVersionPack::middle), "xsd:int"))
				{	soap_flag_middle1--;
					continue;
				}
			if (soap_flag_minor1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "minor", &(a->ns1__gingkoVersionPack::minor), "xsd:int"))
				{	soap_flag_minor1--;
					continue;
				}
			if (soap_flag_servicePack1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "servicePack", &(a->ns1__gingkoVersionPack::servicePack), "xsd:string"))
				{	soap_flag_servicePack1--;
					continue;
				}
			if (soap_flag_message1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "message", &(a->ns1__gingkoVersionPack::message), "xsd:string"))
				{	soap_flag_message1--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__soapPackStatusEnum(soap, "status", &(a->ns1__gingkoVersionPack::status), "ns1:soapPackStatusEnum"))
				{	soap_flag_status1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__gingkoVersionPack *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__gingkoVersionPack, 0, sizeof(ns1__gingkoVersionPack), 0, soap_copy_ns1__gingkoVersionPack);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_major1 > 0 || soap_flag_middle1 > 0 || soap_flag_minor1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__gingkoVersionPack * SOAP_FMAC4 soap_instantiate_ns1__gingkoVersionPack(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__gingkoVersionPack(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__gingkoVersionPack, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__gingkoVersionPack;
		if (size)
			*size = sizeof(ns1__gingkoVersionPack);
		((ns1__gingkoVersionPack*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__gingkoVersionPack[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__gingkoVersionPack);
		for (int i = 0; i < n; i++)
			((ns1__gingkoVersionPack*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__gingkoVersionPack*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__gingkoVersionPack(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__gingkoVersionPack %p -> %p\n", q, p));
	*(ns1__gingkoVersionPack*)p = *(ns1__gingkoVersionPack*)q;
}

void ns1__gingkoVersionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__gingkoVersionResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__gingkoVersionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__gingkoVersionPack(soap, &this->ns1__gingkoVersionResponse::return_);
	/* transient soap skipped */
}

int ns1__gingkoVersionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__gingkoVersionResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__gingkoVersionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__gingkoVersionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__gingkoVersionResponse(struct soap *soap, const char *tag, int id, const ns1__gingkoVersionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__gingkoVersionResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__gingkoVersionPack(soap, "return", -1, &(a->ns1__gingkoVersionResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__gingkoVersionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__gingkoVersionResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__gingkoVersionResponse * SOAP_FMAC4 soap_get_ns1__gingkoVersionResponse(struct soap *soap, ns1__gingkoVersionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__gingkoVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__gingkoVersionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__gingkoVersionResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__gingkoVersionResponse * SOAP_FMAC4 soap_in_ns1__gingkoVersionResponse(struct soap *soap, const char *tag, ns1__gingkoVersionResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__gingkoVersionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__gingkoVersionResponse, sizeof(ns1__gingkoVersionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__gingkoVersionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__gingkoVersionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__gingkoVersionPack(soap, "return", &(a->ns1__gingkoVersionResponse::return_), "ns1:gingkoVersionPack"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__gingkoVersionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__gingkoVersionResponse, 0, sizeof(ns1__gingkoVersionResponse), 0, soap_copy_ns1__gingkoVersionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__gingkoVersionResponse * SOAP_FMAC4 soap_instantiate_ns1__gingkoVersionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__gingkoVersionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__gingkoVersionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__gingkoVersionResponse;
		if (size)
			*size = sizeof(ns1__gingkoVersionResponse);
		((ns1__gingkoVersionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__gingkoVersionResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__gingkoVersionResponse);
		for (int i = 0; i < n; i++)
			((ns1__gingkoVersionResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__gingkoVersionResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__gingkoVersionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__gingkoVersionResponse %p -> %p\n", q, p));
	*(ns1__gingkoVersionResponse*)p = *(ns1__gingkoVersionResponse*)q;
}

void ns1__gingkoVersion::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void ns1__gingkoVersion::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__gingkoVersion::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__gingkoVersion);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__gingkoVersion::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__gingkoVersion(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__gingkoVersion(struct soap *soap, const char *tag, int id, const ns1__gingkoVersion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__gingkoVersion), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__gingkoVersion::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__gingkoVersion(soap, this, tag, type);
}

SOAP_FMAC3 ns1__gingkoVersion * SOAP_FMAC4 soap_get_ns1__gingkoVersion(struct soap *soap, ns1__gingkoVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__gingkoVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__gingkoVersion::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__gingkoVersion(soap, tag, this, type);
}

SOAP_FMAC3 ns1__gingkoVersion * SOAP_FMAC4 soap_in_ns1__gingkoVersion(struct soap *soap, const char *tag, ns1__gingkoVersion *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__gingkoVersion *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__gingkoVersion, sizeof(ns1__gingkoVersion), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__gingkoVersion)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__gingkoVersion *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__gingkoVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__gingkoVersion, 0, sizeof(ns1__gingkoVersion), 0, soap_copy_ns1__gingkoVersion);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__gingkoVersion * SOAP_FMAC4 soap_instantiate_ns1__gingkoVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__gingkoVersion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__gingkoVersion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__gingkoVersion;
		if (size)
			*size = sizeof(ns1__gingkoVersion);
		((ns1__gingkoVersion*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__gingkoVersion[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__gingkoVersion);
		for (int i = 0; i < n; i++)
			((ns1__gingkoVersion*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__gingkoVersion*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__gingkoVersion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__gingkoVersion %p -> %p\n", q, p));
	*(ns1__gingkoVersion*)p = *(ns1__gingkoVersion*)q;
}

void ns1__userLoginResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__userLoginResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__userLoginResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__gingkoUserPack(soap, &this->ns1__userLoginResponse::return_);
	/* transient soap skipped */
}

int ns1__userLoginResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__userLoginResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__userLoginResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__userLoginResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__userLoginResponse(struct soap *soap, const char *tag, int id, const ns1__userLoginResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__userLoginResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__gingkoUserPack(soap, "return", -1, &(a->ns1__userLoginResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__userLoginResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__userLoginResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__userLoginResponse * SOAP_FMAC4 soap_get_ns1__userLoginResponse(struct soap *soap, ns1__userLoginResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__userLoginResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__userLoginResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__userLoginResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__userLoginResponse * SOAP_FMAC4 soap_in_ns1__userLoginResponse(struct soap *soap, const char *tag, ns1__userLoginResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__userLoginResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__userLoginResponse, sizeof(ns1__userLoginResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__userLoginResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__userLoginResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__gingkoUserPack(soap, "return", &(a->ns1__userLoginResponse::return_), "ns1:gingkoUserPack"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__userLoginResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__userLoginResponse, 0, sizeof(ns1__userLoginResponse), 0, soap_copy_ns1__userLoginResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__userLoginResponse * SOAP_FMAC4 soap_instantiate_ns1__userLoginResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__userLoginResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__userLoginResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__userLoginResponse;
		if (size)
			*size = sizeof(ns1__userLoginResponse);
		((ns1__userLoginResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__userLoginResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__userLoginResponse);
		for (int i = 0; i < n; i++)
			((ns1__userLoginResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__userLoginResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__userLoginResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__userLoginResponse %p -> %p\n", q, p));
	*(ns1__userLoginResponse*)p = *(ns1__userLoginResponse*)q;
}

void ns1__userLogin::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__userLogin::loginId = NULL;
	this->ns1__userLogin::password = NULL;
	/* transient soap skipped */
}

void ns1__userLogin::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__userLogin::loginId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__userLogin::password);
	/* transient soap skipped */
}

int ns1__userLogin::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__userLogin);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__userLogin::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__userLogin(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__userLogin(struct soap *soap, const char *tag, int id, const ns1__userLogin *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__userLogin), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "loginId", -1, &(a->ns1__userLogin::loginId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "password", -1, &(a->ns1__userLogin::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__userLogin::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__userLogin(soap, this, tag, type);
}

SOAP_FMAC3 ns1__userLogin * SOAP_FMAC4 soap_get_ns1__userLogin(struct soap *soap, ns1__userLogin *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__userLogin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__userLogin::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__userLogin(soap, tag, this, type);
}

SOAP_FMAC3 ns1__userLogin * SOAP_FMAC4 soap_in_ns1__userLogin(struct soap *soap, const char *tag, ns1__userLogin *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__userLogin *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__userLogin, sizeof(ns1__userLogin), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__userLogin)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__userLogin *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_loginId1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_loginId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "loginId", &(a->ns1__userLogin::loginId), "xsd:string"))
				{	soap_flag_loginId1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "password", &(a->ns1__userLogin::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__userLogin *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__userLogin, 0, sizeof(ns1__userLogin), 0, soap_copy_ns1__userLogin);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__userLogin * SOAP_FMAC4 soap_instantiate_ns1__userLogin(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__userLogin(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__userLogin, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__userLogin;
		if (size)
			*size = sizeof(ns1__userLogin);
		((ns1__userLogin*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__userLogin[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__userLogin);
		for (int i = 0; i < n; i++)
			((ns1__userLogin*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__userLogin*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__userLogin(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__userLogin %p -> %p\n", q, p));
	*(ns1__userLogin*)p = *(ns1__userLogin*)q;
}

void ns1__gingkoUser::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__gingkoUser::bindingId = NULL;
	this->ns1__gingkoUser::gingkoId = NULL;
	this->ns1__gingkoUser::loginId = NULL;
	this->ns1__gingkoUser::name = NULL;
	this->ns1__gingkoUser::password = NULL;
	this->ns1__gingkoUser::status = NULL;
	this->ns1__gingkoUser::updatedBy = NULL;
	this->ns1__gingkoUser::updatedTime = NULL;
	/* transient soap skipped */
}

void ns1__gingkoUser::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__gingkoUser::bindingId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__gingkoUser::gingkoId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__gingkoUser::loginId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__gingkoUser::name);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__gingkoUser::password);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__gingkoUser::status);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__gingkoUser::updatedBy);
	soap_serialize_PointerTotime(soap, &this->ns1__gingkoUser::updatedTime);
	/* transient soap skipped */
}

int ns1__gingkoUser::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__gingkoUser);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__gingkoUser::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__gingkoUser(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__gingkoUser(struct soap *soap, const char *tag, int id, const ns1__gingkoUser *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__gingkoUser), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "bindingId", -1, &(a->ns1__gingkoUser::bindingId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "gingkoId", -1, &(a->ns1__gingkoUser::gingkoId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "loginId", -1, &(a->ns1__gingkoUser::loginId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "name", -1, &(a->ns1__gingkoUser::name), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "password", -1, &(a->ns1__gingkoUser::password), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "status", -1, &(a->ns1__gingkoUser::status), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "updatedBy", -1, &(a->ns1__gingkoUser::updatedBy), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "updatedTime", -1, &(a->ns1__gingkoUser::updatedTime), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__gingkoUser::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__gingkoUser(soap, this, tag, type);
}

SOAP_FMAC3 ns1__gingkoUser * SOAP_FMAC4 soap_get_ns1__gingkoUser(struct soap *soap, ns1__gingkoUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__gingkoUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__gingkoUser::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__gingkoUser(soap, tag, this, type);
}

SOAP_FMAC3 ns1__gingkoUser * SOAP_FMAC4 soap_in_ns1__gingkoUser(struct soap *soap, const char *tag, ns1__gingkoUser *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__gingkoUser *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__gingkoUser, sizeof(ns1__gingkoUser), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__gingkoUser)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__gingkoUser *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_bindingId1 = 1;
	size_t soap_flag_gingkoId1 = 1;
	size_t soap_flag_loginId1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_password1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_updatedBy1 = 1;
	size_t soap_flag_updatedTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_bindingId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "bindingId", &(a->ns1__gingkoUser::bindingId), "xsd:string"))
				{	soap_flag_bindingId1--;
					continue;
				}
			if (soap_flag_gingkoId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "gingkoId", &(a->ns1__gingkoUser::gingkoId), "xsd:string"))
				{	soap_flag_gingkoId1--;
					continue;
				}
			if (soap_flag_loginId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "loginId", &(a->ns1__gingkoUser::loginId), "xsd:string"))
				{	soap_flag_loginId1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "name", &(a->ns1__gingkoUser::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "password", &(a->ns1__gingkoUser::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			if (soap_flag_status1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "status", &(a->ns1__gingkoUser::status), "xsd:string"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_updatedBy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "updatedBy", &(a->ns1__gingkoUser::updatedBy), "xsd:string"))
				{	soap_flag_updatedBy1--;
					continue;
				}
			if (soap_flag_updatedTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "updatedTime", &(a->ns1__gingkoUser::updatedTime), "xsd:dateTime"))
				{	soap_flag_updatedTime1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__gingkoUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__gingkoUser, 0, sizeof(ns1__gingkoUser), 0, soap_copy_ns1__gingkoUser);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__gingkoUser * SOAP_FMAC4 soap_instantiate_ns1__gingkoUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__gingkoUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__gingkoUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__gingkoUser;
		if (size)
			*size = sizeof(ns1__gingkoUser);
		((ns1__gingkoUser*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__gingkoUser[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__gingkoUser);
		for (int i = 0; i < n; i++)
			((ns1__gingkoUser*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__gingkoUser*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__gingkoUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__gingkoUser %p -> %p\n", q, p));
	*(ns1__gingkoUser*)p = *(ns1__gingkoUser*)q;
}

void ns1__gingkoUserPack::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__gingkoUserPack::gingkoUser = NULL;
	this->ns1__gingkoUserPack::message = NULL;
	this->ns1__gingkoUserPack::status = NULL;
	this->ns1__gingkoUserPack::token = NULL;
	/* transient soap skipped */
}

void ns1__gingkoUserPack::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__gingkoUser(soap, &this->ns1__gingkoUserPack::gingkoUser);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__gingkoUserPack::message);
	soap_serialize_PointerTons1__soapPackStatusEnum(soap, &this->ns1__gingkoUserPack::status);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__gingkoUserPack::token);
	/* transient soap skipped */
}

int ns1__gingkoUserPack::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__gingkoUserPack);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__gingkoUserPack::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__gingkoUserPack(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__gingkoUserPack(struct soap *soap, const char *tag, int id, const ns1__gingkoUserPack *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__gingkoUserPack), type))
		return soap->error;
	if (soap_out_PointerTons1__gingkoUser(soap, "gingkoUser", -1, &(a->ns1__gingkoUserPack::gingkoUser), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "message", -1, &(a->ns1__gingkoUserPack::message), ""))
		return soap->error;
	if (soap_out_PointerTons1__soapPackStatusEnum(soap, "status", -1, &(a->ns1__gingkoUserPack::status), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "token", -1, &(a->ns1__gingkoUserPack::token), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__gingkoUserPack::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__gingkoUserPack(soap, this, tag, type);
}

SOAP_FMAC3 ns1__gingkoUserPack * SOAP_FMAC4 soap_get_ns1__gingkoUserPack(struct soap *soap, ns1__gingkoUserPack *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__gingkoUserPack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__gingkoUserPack::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__gingkoUserPack(soap, tag, this, type);
}

SOAP_FMAC3 ns1__gingkoUserPack * SOAP_FMAC4 soap_in_ns1__gingkoUserPack(struct soap *soap, const char *tag, ns1__gingkoUserPack *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__gingkoUserPack *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__gingkoUserPack, sizeof(ns1__gingkoUserPack), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__gingkoUserPack)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__gingkoUserPack *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_gingkoUser1 = 1;
	size_t soap_flag_message1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_token1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_gingkoUser1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__gingkoUser(soap, "gingkoUser", &(a->ns1__gingkoUserPack::gingkoUser), "ns1:gingkoUser"))
				{	soap_flag_gingkoUser1--;
					continue;
				}
			if (soap_flag_message1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "message", &(a->ns1__gingkoUserPack::message), "xsd:string"))
				{	soap_flag_message1--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__soapPackStatusEnum(soap, "status", &(a->ns1__gingkoUserPack::status), "ns1:soapPackStatusEnum"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "token", &(a->ns1__gingkoUserPack::token), "xsd:string"))
				{	soap_flag_token1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__gingkoUserPack *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__gingkoUserPack, 0, sizeof(ns1__gingkoUserPack), 0, soap_copy_ns1__gingkoUserPack);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__gingkoUserPack * SOAP_FMAC4 soap_instantiate_ns1__gingkoUserPack(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__gingkoUserPack(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__gingkoUserPack, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__gingkoUserPack;
		if (size)
			*size = sizeof(ns1__gingkoUserPack);
		((ns1__gingkoUserPack*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__gingkoUserPack[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__gingkoUserPack);
		for (int i = 0; i < n; i++)
			((ns1__gingkoUserPack*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__gingkoUserPack*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__gingkoUserPack(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__gingkoUserPack %p -> %p\n", q, p));
	*(ns1__gingkoUserPack*)p = *(ns1__gingkoUserPack*)q;
}

void ns1__registerUserResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__registerUserResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__registerUserResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__gingkoUserPack(soap, &this->ns1__registerUserResponse::return_);
	/* transient soap skipped */
}

int ns1__registerUserResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__registerUserResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__registerUserResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__registerUserResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__registerUserResponse(struct soap *soap, const char *tag, int id, const ns1__registerUserResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__registerUserResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__gingkoUserPack(soap, "return", -1, &(a->ns1__registerUserResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__registerUserResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__registerUserResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__registerUserResponse * SOAP_FMAC4 soap_get_ns1__registerUserResponse(struct soap *soap, ns1__registerUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__registerUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__registerUserResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__registerUserResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__registerUserResponse * SOAP_FMAC4 soap_in_ns1__registerUserResponse(struct soap *soap, const char *tag, ns1__registerUserResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__registerUserResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__registerUserResponse, sizeof(ns1__registerUserResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__registerUserResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__registerUserResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__gingkoUserPack(soap, "return", &(a->ns1__registerUserResponse::return_), "ns1:gingkoUserPack"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__registerUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__registerUserResponse, 0, sizeof(ns1__registerUserResponse), 0, soap_copy_ns1__registerUserResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__registerUserResponse * SOAP_FMAC4 soap_instantiate_ns1__registerUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__registerUserResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__registerUserResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__registerUserResponse;
		if (size)
			*size = sizeof(ns1__registerUserResponse);
		((ns1__registerUserResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__registerUserResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__registerUserResponse);
		for (int i = 0; i < n; i++)
			((ns1__registerUserResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__registerUserResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__registerUserResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__registerUserResponse %p -> %p\n", q, p));
	*(ns1__registerUserResponse*)p = *(ns1__registerUserResponse*)q;
}

void ns1__registerUser::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__registerUser::loginId = NULL;
	this->ns1__registerUser::name = NULL;
	this->ns1__registerUser::password = NULL;
	this->ns1__registerUser::bindingId = NULL;
	this->ns1__registerUser::bindPassword = NULL;
	/* transient soap skipped */
}

void ns1__registerUser::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__registerUser::loginId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__registerUser::name);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__registerUser::password);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__registerUser::bindingId);
	soap_serialize_PointerTostd__wstring(soap, &this->ns1__registerUser::bindPassword);
	/* transient soap skipped */
}

int ns1__registerUser::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__registerUser);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__registerUser::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__registerUser(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__registerUser(struct soap *soap, const char *tag, int id, const ns1__registerUser *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__registerUser), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "loginId", -1, &(a->ns1__registerUser::loginId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "name", -1, &(a->ns1__registerUser::name), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "password", -1, &(a->ns1__registerUser::password), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "bindingId", -1, &(a->ns1__registerUser::bindingId), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "bindPassword", -1, &(a->ns1__registerUser::bindPassword), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__registerUser::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__registerUser(soap, this, tag, type);
}

SOAP_FMAC3 ns1__registerUser * SOAP_FMAC4 soap_get_ns1__registerUser(struct soap *soap, ns1__registerUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__registerUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__registerUser::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__registerUser(soap, tag, this, type);
}

SOAP_FMAC3 ns1__registerUser * SOAP_FMAC4 soap_in_ns1__registerUser(struct soap *soap, const char *tag, ns1__registerUser *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__registerUser *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__registerUser, sizeof(ns1__registerUser), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__registerUser)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__registerUser *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_loginId1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_password1 = 1;
	size_t soap_flag_bindingId1 = 1;
	size_t soap_flag_bindPassword1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_loginId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "loginId", &(a->ns1__registerUser::loginId), "xsd:string"))
				{	soap_flag_loginId1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "name", &(a->ns1__registerUser::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "password", &(a->ns1__registerUser::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			if (soap_flag_bindingId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "bindingId", &(a->ns1__registerUser::bindingId), "xsd:string"))
				{	soap_flag_bindingId1--;
					continue;
				}
			if (soap_flag_bindPassword1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "bindPassword", &(a->ns1__registerUser::bindPassword), "xsd:string"))
				{	soap_flag_bindPassword1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__registerUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__registerUser, 0, sizeof(ns1__registerUser), 0, soap_copy_ns1__registerUser);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 ns1__registerUser * SOAP_FMAC4 soap_instantiate_ns1__registerUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__registerUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__registerUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__registerUser;
		if (size)
			*size = sizeof(ns1__registerUser);
		((ns1__registerUser*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__registerUser[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__registerUser);
		for (int i = 0; i < n; i++)
			((ns1__registerUser*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__registerUser*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__registerUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__registerUser %p -> %p\n", q, p));
	*(ns1__registerUser*)p = *(ns1__registerUser*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault;
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason;
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail;
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Code;
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Code[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Header;
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Header[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__createDigitalInfo(struct soap *soap, struct __ns1__createDigitalInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__createDigitalInfo_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__createDigitalInfo(struct soap *soap, const struct __ns1__createDigitalInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__createDigitalInfo(soap, &a->ns1__createDigitalInfo_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__createDigitalInfo(struct soap *soap, const struct __ns1__createDigitalInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__createDigitalInfo(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__createDigitalInfo(struct soap *soap, const char *tag, int id, const struct __ns1__createDigitalInfo *a, const char *type)
{
	if (soap_out_PointerTons1__createDigitalInfo(soap, "ns1:createDigitalInfo", -1, &a->ns1__createDigitalInfo_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__createDigitalInfo * SOAP_FMAC4 soap_get___ns1__createDigitalInfo(struct soap *soap, struct __ns1__createDigitalInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__createDigitalInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__createDigitalInfo * SOAP_FMAC4 soap_in___ns1__createDigitalInfo(struct soap *soap, const char *tag, struct __ns1__createDigitalInfo *a, const char *type)
{
	size_t soap_flag_ns1__createDigitalInfo_ = 1;
	short soap_flag;
	a = (struct __ns1__createDigitalInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__createDigitalInfo, sizeof(struct __ns1__createDigitalInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__createDigitalInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__createDigitalInfo_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__createDigitalInfo(soap, "ns1:createDigitalInfo", &a->ns1__createDigitalInfo_, "ns1:createDigitalInfo"))
				{	soap_flag_ns1__createDigitalInfo_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__createDigitalInfo * SOAP_FMAC4 soap_instantiate___ns1__createDigitalInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__createDigitalInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__createDigitalInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__createDigitalInfo;
		if (size)
			*size = sizeof(struct __ns1__createDigitalInfo);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__createDigitalInfo[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__createDigitalInfo);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__createDigitalInfo*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__createDigitalInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__createDigitalInfo %p -> %p\n", q, p));
	*(struct __ns1__createDigitalInfo*)p = *(struct __ns1__createDigitalInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__updateDigitalInfo(struct soap *soap, struct __ns1__updateDigitalInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__updateDigitalInfo_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__updateDigitalInfo(struct soap *soap, const struct __ns1__updateDigitalInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__updateDigitalInfo(soap, &a->ns1__updateDigitalInfo_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__updateDigitalInfo(struct soap *soap, const struct __ns1__updateDigitalInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__updateDigitalInfo(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__updateDigitalInfo(struct soap *soap, const char *tag, int id, const struct __ns1__updateDigitalInfo *a, const char *type)
{
	if (soap_out_PointerTons1__updateDigitalInfo(soap, "ns1:updateDigitalInfo", -1, &a->ns1__updateDigitalInfo_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateDigitalInfo * SOAP_FMAC4 soap_get___ns1__updateDigitalInfo(struct soap *soap, struct __ns1__updateDigitalInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__updateDigitalInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__updateDigitalInfo * SOAP_FMAC4 soap_in___ns1__updateDigitalInfo(struct soap *soap, const char *tag, struct __ns1__updateDigitalInfo *a, const char *type)
{
	size_t soap_flag_ns1__updateDigitalInfo_ = 1;
	short soap_flag;
	a = (struct __ns1__updateDigitalInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__updateDigitalInfo, sizeof(struct __ns1__updateDigitalInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__updateDigitalInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__updateDigitalInfo_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__updateDigitalInfo(soap, "ns1:updateDigitalInfo", &a->ns1__updateDigitalInfo_, "ns1:updateDigitalInfo"))
				{	soap_flag_ns1__updateDigitalInfo_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__updateDigitalInfo * SOAP_FMAC4 soap_instantiate___ns1__updateDigitalInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__updateDigitalInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__updateDigitalInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__updateDigitalInfo;
		if (size)
			*size = sizeof(struct __ns1__updateDigitalInfo);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__updateDigitalInfo[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__updateDigitalInfo);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__updateDigitalInfo*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__updateDigitalInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__updateDigitalInfo %p -> %p\n", q, p));
	*(struct __ns1__updateDigitalInfo*)p = *(struct __ns1__updateDigitalInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__findDigitalPermission(struct soap *soap, struct __ns1__findDigitalPermission *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__findDigitalPermission_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__findDigitalPermission(struct soap *soap, const struct __ns1__findDigitalPermission *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__findDigitalPermission(soap, &a->ns1__findDigitalPermission_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__findDigitalPermission(struct soap *soap, const struct __ns1__findDigitalPermission *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__findDigitalPermission(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__findDigitalPermission(struct soap *soap, const char *tag, int id, const struct __ns1__findDigitalPermission *a, const char *type)
{
	if (soap_out_PointerTons1__findDigitalPermission(soap, "ns1:findDigitalPermission", -1, &a->ns1__findDigitalPermission_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__findDigitalPermission * SOAP_FMAC4 soap_get___ns1__findDigitalPermission(struct soap *soap, struct __ns1__findDigitalPermission *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__findDigitalPermission(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__findDigitalPermission * SOAP_FMAC4 soap_in___ns1__findDigitalPermission(struct soap *soap, const char *tag, struct __ns1__findDigitalPermission *a, const char *type)
{
	size_t soap_flag_ns1__findDigitalPermission_ = 1;
	short soap_flag;
	a = (struct __ns1__findDigitalPermission *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__findDigitalPermission, sizeof(struct __ns1__findDigitalPermission), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__findDigitalPermission(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__findDigitalPermission_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__findDigitalPermission(soap, "ns1:findDigitalPermission", &a->ns1__findDigitalPermission_, "ns1:findDigitalPermission"))
				{	soap_flag_ns1__findDigitalPermission_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__findDigitalPermission * SOAP_FMAC4 soap_instantiate___ns1__findDigitalPermission(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__findDigitalPermission(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__findDigitalPermission, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__findDigitalPermission;
		if (size)
			*size = sizeof(struct __ns1__findDigitalPermission);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__findDigitalPermission[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__findDigitalPermission);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__findDigitalPermission*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__findDigitalPermission(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__findDigitalPermission %p -> %p\n", q, p));
	*(struct __ns1__findDigitalPermission*)p = *(struct __ns1__findDigitalPermission*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__assignPermission(struct soap *soap, struct __ns1__assignPermission *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__assignPermission_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__assignPermission(struct soap *soap, const struct __ns1__assignPermission *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__assignPermission(soap, &a->ns1__assignPermission_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__assignPermission(struct soap *soap, const struct __ns1__assignPermission *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__assignPermission(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__assignPermission(struct soap *soap, const char *tag, int id, const struct __ns1__assignPermission *a, const char *type)
{
	if (soap_out_PointerTons1__assignPermission(soap, "ns1:assignPermission", -1, &a->ns1__assignPermission_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__assignPermission * SOAP_FMAC4 soap_get___ns1__assignPermission(struct soap *soap, struct __ns1__assignPermission *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__assignPermission(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__assignPermission * SOAP_FMAC4 soap_in___ns1__assignPermission(struct soap *soap, const char *tag, struct __ns1__assignPermission *a, const char *type)
{
	size_t soap_flag_ns1__assignPermission_ = 1;
	short soap_flag;
	a = (struct __ns1__assignPermission *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__assignPermission, sizeof(struct __ns1__assignPermission), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__assignPermission(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__assignPermission_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__assignPermission(soap, "ns1:assignPermission", &a->ns1__assignPermission_, "ns1:assignPermission"))
				{	soap_flag_ns1__assignPermission_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__assignPermission * SOAP_FMAC4 soap_instantiate___ns1__assignPermission(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__assignPermission(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__assignPermission, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__assignPermission;
		if (size)
			*size = sizeof(struct __ns1__assignPermission);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__assignPermission[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__assignPermission);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__assignPermission*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__assignPermission(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__assignPermission %p -> %p\n", q, p));
	*(struct __ns1__assignPermission*)p = *(struct __ns1__assignPermission*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__findAssignedPermission(struct soap *soap, struct __ns1__findAssignedPermission *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__findAssignedPermission_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__findAssignedPermission(struct soap *soap, const struct __ns1__findAssignedPermission *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__findAssignedPermission(soap, &a->ns1__findAssignedPermission_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__findAssignedPermission(struct soap *soap, const struct __ns1__findAssignedPermission *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__findAssignedPermission(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__findAssignedPermission(struct soap *soap, const char *tag, int id, const struct __ns1__findAssignedPermission *a, const char *type)
{
	if (soap_out_PointerTons1__findAssignedPermission(soap, "ns1:findAssignedPermission", -1, &a->ns1__findAssignedPermission_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__findAssignedPermission * SOAP_FMAC4 soap_get___ns1__findAssignedPermission(struct soap *soap, struct __ns1__findAssignedPermission *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__findAssignedPermission(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__findAssignedPermission * SOAP_FMAC4 soap_in___ns1__findAssignedPermission(struct soap *soap, const char *tag, struct __ns1__findAssignedPermission *a, const char *type)
{
	size_t soap_flag_ns1__findAssignedPermission_ = 1;
	short soap_flag;
	a = (struct __ns1__findAssignedPermission *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__findAssignedPermission, sizeof(struct __ns1__findAssignedPermission), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__findAssignedPermission(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__findAssignedPermission_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__findAssignedPermission(soap, "ns1:findAssignedPermission", &a->ns1__findAssignedPermission_, "ns1:findAssignedPermission"))
				{	soap_flag_ns1__findAssignedPermission_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__findAssignedPermission * SOAP_FMAC4 soap_instantiate___ns1__findAssignedPermission(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__findAssignedPermission(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__findAssignedPermission, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__findAssignedPermission;
		if (size)
			*size = sizeof(struct __ns1__findAssignedPermission);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__findAssignedPermission[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__findAssignedPermission);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__findAssignedPermission*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__findAssignedPermission(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__findAssignedPermission %p -> %p\n", q, p));
	*(struct __ns1__findAssignedPermission*)p = *(struct __ns1__findAssignedPermission*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__findDigitalInfo(struct soap *soap, struct __ns1__findDigitalInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__findDigitalInfo_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__findDigitalInfo(struct soap *soap, const struct __ns1__findDigitalInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__findDigitalInfo(soap, &a->ns1__findDigitalInfo_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__findDigitalInfo(struct soap *soap, const struct __ns1__findDigitalInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__findDigitalInfo(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__findDigitalInfo(struct soap *soap, const char *tag, int id, const struct __ns1__findDigitalInfo *a, const char *type)
{
	if (soap_out_PointerTons1__findDigitalInfo(soap, "ns1:findDigitalInfo", -1, &a->ns1__findDigitalInfo_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__findDigitalInfo * SOAP_FMAC4 soap_get___ns1__findDigitalInfo(struct soap *soap, struct __ns1__findDigitalInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__findDigitalInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__findDigitalInfo * SOAP_FMAC4 soap_in___ns1__findDigitalInfo(struct soap *soap, const char *tag, struct __ns1__findDigitalInfo *a, const char *type)
{
	size_t soap_flag_ns1__findDigitalInfo_ = 1;
	short soap_flag;
	a = (struct __ns1__findDigitalInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__findDigitalInfo, sizeof(struct __ns1__findDigitalInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__findDigitalInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__findDigitalInfo_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__findDigitalInfo(soap, "ns1:findDigitalInfo", &a->ns1__findDigitalInfo_, "ns1:findDigitalInfo"))
				{	soap_flag_ns1__findDigitalInfo_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__findDigitalInfo * SOAP_FMAC4 soap_instantiate___ns1__findDigitalInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__findDigitalInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__findDigitalInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__findDigitalInfo;
		if (size)
			*size = sizeof(struct __ns1__findDigitalInfo);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__findDigitalInfo[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__findDigitalInfo);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__findDigitalInfo*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__findDigitalInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__findDigitalInfo %p -> %p\n", q, p));
	*(struct __ns1__findDigitalInfo*)p = *(struct __ns1__findDigitalInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__deleteDigitalInfo(struct soap *soap, struct __ns1__deleteDigitalInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__deleteDigitalInfo_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__deleteDigitalInfo(struct soap *soap, const struct __ns1__deleteDigitalInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__deleteDigitalInfo(soap, &a->ns1__deleteDigitalInfo_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__deleteDigitalInfo(struct soap *soap, const struct __ns1__deleteDigitalInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__deleteDigitalInfo(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__deleteDigitalInfo(struct soap *soap, const char *tag, int id, const struct __ns1__deleteDigitalInfo *a, const char *type)
{
	if (soap_out_PointerTons1__deleteDigitalInfo(soap, "ns1:deleteDigitalInfo", -1, &a->ns1__deleteDigitalInfo_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteDigitalInfo * SOAP_FMAC4 soap_get___ns1__deleteDigitalInfo(struct soap *soap, struct __ns1__deleteDigitalInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__deleteDigitalInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__deleteDigitalInfo * SOAP_FMAC4 soap_in___ns1__deleteDigitalInfo(struct soap *soap, const char *tag, struct __ns1__deleteDigitalInfo *a, const char *type)
{
	size_t soap_flag_ns1__deleteDigitalInfo_ = 1;
	short soap_flag;
	a = (struct __ns1__deleteDigitalInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__deleteDigitalInfo, sizeof(struct __ns1__deleteDigitalInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__deleteDigitalInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__deleteDigitalInfo_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__deleteDigitalInfo(soap, "ns1:deleteDigitalInfo", &a->ns1__deleteDigitalInfo_, "ns1:deleteDigitalInfo"))
				{	soap_flag_ns1__deleteDigitalInfo_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__deleteDigitalInfo * SOAP_FMAC4 soap_instantiate___ns1__deleteDigitalInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__deleteDigitalInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__deleteDigitalInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__deleteDigitalInfo;
		if (size)
			*size = sizeof(struct __ns1__deleteDigitalInfo);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__deleteDigitalInfo[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__deleteDigitalInfo);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__deleteDigitalInfo*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__deleteDigitalInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__deleteDigitalInfo %p -> %p\n", q, p));
	*(struct __ns1__deleteDigitalInfo*)p = *(struct __ns1__deleteDigitalInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__requestPermission(struct soap *soap, struct __ns1__requestPermission *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__requestPermission_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__requestPermission(struct soap *soap, const struct __ns1__requestPermission *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__requestPermission(soap, &a->ns1__requestPermission_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__requestPermission(struct soap *soap, const struct __ns1__requestPermission *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__requestPermission(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__requestPermission(struct soap *soap, const char *tag, int id, const struct __ns1__requestPermission *a, const char *type)
{
	if (soap_out_PointerTons1__requestPermission(soap, "ns1:requestPermission", -1, &a->ns1__requestPermission_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__requestPermission * SOAP_FMAC4 soap_get___ns1__requestPermission(struct soap *soap, struct __ns1__requestPermission *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__requestPermission(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__requestPermission * SOAP_FMAC4 soap_in___ns1__requestPermission(struct soap *soap, const char *tag, struct __ns1__requestPermission *a, const char *type)
{
	size_t soap_flag_ns1__requestPermission_ = 1;
	short soap_flag;
	a = (struct __ns1__requestPermission *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__requestPermission, sizeof(struct __ns1__requestPermission), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__requestPermission(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__requestPermission_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__requestPermission(soap, "ns1:requestPermission", &a->ns1__requestPermission_, "ns1:requestPermission"))
				{	soap_flag_ns1__requestPermission_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__requestPermission * SOAP_FMAC4 soap_instantiate___ns1__requestPermission(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__requestPermission(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__requestPermission, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__requestPermission;
		if (size)
			*size = sizeof(struct __ns1__requestPermission);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__requestPermission[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__requestPermission);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__requestPermission*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__requestPermission(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__requestPermission %p -> %p\n", q, p));
	*(struct __ns1__requestPermission*)p = *(struct __ns1__requestPermission*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__changePassword(struct soap *soap, struct __ns1__changePassword *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__changePassword_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__changePassword(struct soap *soap, const struct __ns1__changePassword *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__changePassword(soap, &a->ns1__changePassword_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__changePassword(struct soap *soap, const struct __ns1__changePassword *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__changePassword(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__changePassword(struct soap *soap, const char *tag, int id, const struct __ns1__changePassword *a, const char *type)
{
	if (soap_out_PointerTons1__changePassword(soap, "ns1:changePassword", -1, &a->ns1__changePassword_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__changePassword * SOAP_FMAC4 soap_get___ns1__changePassword(struct soap *soap, struct __ns1__changePassword *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__changePassword(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__changePassword * SOAP_FMAC4 soap_in___ns1__changePassword(struct soap *soap, const char *tag, struct __ns1__changePassword *a, const char *type)
{
	size_t soap_flag_ns1__changePassword_ = 1;
	short soap_flag;
	a = (struct __ns1__changePassword *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__changePassword, sizeof(struct __ns1__changePassword), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__changePassword(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__changePassword_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__changePassword(soap, "ns1:changePassword", &a->ns1__changePassword_, "ns1:changePassword"))
				{	soap_flag_ns1__changePassword_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__changePassword * SOAP_FMAC4 soap_instantiate___ns1__changePassword(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__changePassword(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__changePassword, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__changePassword;
		if (size)
			*size = sizeof(struct __ns1__changePassword);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__changePassword[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__changePassword);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__changePassword*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__changePassword(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__changePassword %p -> %p\n", q, p));
	*(struct __ns1__changePassword*)p = *(struct __ns1__changePassword*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__findUserByGingkoId(struct soap *soap, struct __ns1__findUserByGingkoId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__findUserByGingkoId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__findUserByGingkoId(struct soap *soap, const struct __ns1__findUserByGingkoId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__findUserByGingkoId(soap, &a->ns1__findUserByGingkoId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__findUserByGingkoId(struct soap *soap, const struct __ns1__findUserByGingkoId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__findUserByGingkoId(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__findUserByGingkoId(struct soap *soap, const char *tag, int id, const struct __ns1__findUserByGingkoId *a, const char *type)
{
	if (soap_out_PointerTons1__findUserByGingkoId(soap, "ns1:findUserByGingkoId", -1, &a->ns1__findUserByGingkoId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__findUserByGingkoId * SOAP_FMAC4 soap_get___ns1__findUserByGingkoId(struct soap *soap, struct __ns1__findUserByGingkoId *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__findUserByGingkoId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__findUserByGingkoId * SOAP_FMAC4 soap_in___ns1__findUserByGingkoId(struct soap *soap, const char *tag, struct __ns1__findUserByGingkoId *a, const char *type)
{
	size_t soap_flag_ns1__findUserByGingkoId_ = 1;
	short soap_flag;
	a = (struct __ns1__findUserByGingkoId *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__findUserByGingkoId, sizeof(struct __ns1__findUserByGingkoId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__findUserByGingkoId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__findUserByGingkoId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__findUserByGingkoId(soap, "ns1:findUserByGingkoId", &a->ns1__findUserByGingkoId_, "ns1:findUserByGingkoId"))
				{	soap_flag_ns1__findUserByGingkoId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__findUserByGingkoId * SOAP_FMAC4 soap_instantiate___ns1__findUserByGingkoId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__findUserByGingkoId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__findUserByGingkoId, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__findUserByGingkoId;
		if (size)
			*size = sizeof(struct __ns1__findUserByGingkoId);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__findUserByGingkoId[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__findUserByGingkoId);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__findUserByGingkoId*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__findUserByGingkoId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__findUserByGingkoId %p -> %p\n", q, p));
	*(struct __ns1__findUserByGingkoId*)p = *(struct __ns1__findUserByGingkoId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__searchUsers(struct soap *soap, struct __ns1__searchUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__searchUsers_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__searchUsers(struct soap *soap, const struct __ns1__searchUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__searchUsers(soap, &a->ns1__searchUsers_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__searchUsers(struct soap *soap, const struct __ns1__searchUsers *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__searchUsers(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__searchUsers(struct soap *soap, const char *tag, int id, const struct __ns1__searchUsers *a, const char *type)
{
	if (soap_out_PointerTons1__searchUsers(soap, "ns1:searchUsers", -1, &a->ns1__searchUsers_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__searchUsers * SOAP_FMAC4 soap_get___ns1__searchUsers(struct soap *soap, struct __ns1__searchUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__searchUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__searchUsers * SOAP_FMAC4 soap_in___ns1__searchUsers(struct soap *soap, const char *tag, struct __ns1__searchUsers *a, const char *type)
{
	size_t soap_flag_ns1__searchUsers_ = 1;
	short soap_flag;
	a = (struct __ns1__searchUsers *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__searchUsers, sizeof(struct __ns1__searchUsers), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__searchUsers(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__searchUsers_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__searchUsers(soap, "ns1:searchUsers", &a->ns1__searchUsers_, "ns1:searchUsers"))
				{	soap_flag_ns1__searchUsers_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__searchUsers * SOAP_FMAC4 soap_instantiate___ns1__searchUsers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__searchUsers(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__searchUsers, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__searchUsers;
		if (size)
			*size = sizeof(struct __ns1__searchUsers);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__searchUsers[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__searchUsers);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__searchUsers*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__searchUsers(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__searchUsers %p -> %p\n", q, p));
	*(struct __ns1__searchUsers*)p = *(struct __ns1__searchUsers*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__findUserByLoginId(struct soap *soap, struct __ns1__findUserByLoginId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__findUserByLoginId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__findUserByLoginId(struct soap *soap, const struct __ns1__findUserByLoginId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__findUserByLoginId(soap, &a->ns1__findUserByLoginId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__findUserByLoginId(struct soap *soap, const struct __ns1__findUserByLoginId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__findUserByLoginId(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__findUserByLoginId(struct soap *soap, const char *tag, int id, const struct __ns1__findUserByLoginId *a, const char *type)
{
	if (soap_out_PointerTons1__findUserByLoginId(soap, "ns1:findUserByLoginId", -1, &a->ns1__findUserByLoginId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__findUserByLoginId * SOAP_FMAC4 soap_get___ns1__findUserByLoginId(struct soap *soap, struct __ns1__findUserByLoginId *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__findUserByLoginId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__findUserByLoginId * SOAP_FMAC4 soap_in___ns1__findUserByLoginId(struct soap *soap, const char *tag, struct __ns1__findUserByLoginId *a, const char *type)
{
	size_t soap_flag_ns1__findUserByLoginId_ = 1;
	short soap_flag;
	a = (struct __ns1__findUserByLoginId *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__findUserByLoginId, sizeof(struct __ns1__findUserByLoginId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__findUserByLoginId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__findUserByLoginId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__findUserByLoginId(soap, "ns1:findUserByLoginId", &a->ns1__findUserByLoginId_, "ns1:findUserByLoginId"))
				{	soap_flag_ns1__findUserByLoginId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__findUserByLoginId * SOAP_FMAC4 soap_instantiate___ns1__findUserByLoginId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__findUserByLoginId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__findUserByLoginId, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__findUserByLoginId;
		if (size)
			*size = sizeof(struct __ns1__findUserByLoginId);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__findUserByLoginId[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__findUserByLoginId);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__findUserByLoginId*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__findUserByLoginId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__findUserByLoginId %p -> %p\n", q, p));
	*(struct __ns1__findUserByLoginId*)p = *(struct __ns1__findUserByLoginId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__bindingGingkoUser(struct soap *soap, struct __ns1__bindingGingkoUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__bindingGingkoUser_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__bindingGingkoUser(struct soap *soap, const struct __ns1__bindingGingkoUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__bindingGingkoUser(soap, &a->ns1__bindingGingkoUser_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__bindingGingkoUser(struct soap *soap, const struct __ns1__bindingGingkoUser *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__bindingGingkoUser(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__bindingGingkoUser(struct soap *soap, const char *tag, int id, const struct __ns1__bindingGingkoUser *a, const char *type)
{
	if (soap_out_PointerTons1__bindingGingkoUser(soap, "ns1:bindingGingkoUser", -1, &a->ns1__bindingGingkoUser_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__bindingGingkoUser * SOAP_FMAC4 soap_get___ns1__bindingGingkoUser(struct soap *soap, struct __ns1__bindingGingkoUser *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__bindingGingkoUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__bindingGingkoUser * SOAP_FMAC4 soap_in___ns1__bindingGingkoUser(struct soap *soap, const char *tag, struct __ns1__bindingGingkoUser *a, const char *type)
{
	size_t soap_flag_ns1__bindingGingkoUser_ = 1;
	short soap_flag;
	a = (struct __ns1__bindingGingkoUser *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__bindingGingkoUser, sizeof(struct __ns1__bindingGingkoUser), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__bindingGingkoUser(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__bindingGingkoUser_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__bindingGingkoUser(soap, "ns1:bindingGingkoUser", &a->ns1__bindingGingkoUser_, "ns1:bindingGingkoUser"))
				{	soap_flag_ns1__bindingGingkoUser_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__bindingGingkoUser * SOAP_FMAC4 soap_instantiate___ns1__bindingGingkoUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__bindingGingkoUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__bindingGingkoUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__bindingGingkoUser;
		if (size)
			*size = sizeof(struct __ns1__bindingGingkoUser);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__bindingGingkoUser[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__bindingGingkoUser);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__bindingGingkoUser*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__bindingGingkoUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__bindingGingkoUser %p -> %p\n", q, p));
	*(struct __ns1__bindingGingkoUser*)p = *(struct __ns1__bindingGingkoUser*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__findGingkoUnitInfo(struct soap *soap, struct __ns1__findGingkoUnitInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__findGingkoUnitInfo_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__findGingkoUnitInfo(struct soap *soap, const struct __ns1__findGingkoUnitInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__findGingkoUnitInfo(soap, &a->ns1__findGingkoUnitInfo_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__findGingkoUnitInfo(struct soap *soap, const struct __ns1__findGingkoUnitInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__findGingkoUnitInfo(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__findGingkoUnitInfo(struct soap *soap, const char *tag, int id, const struct __ns1__findGingkoUnitInfo *a, const char *type)
{
	if (soap_out_PointerTons1__findGingkoUnitInfo(soap, "ns1:findGingkoUnitInfo", -1, &a->ns1__findGingkoUnitInfo_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__findGingkoUnitInfo * SOAP_FMAC4 soap_get___ns1__findGingkoUnitInfo(struct soap *soap, struct __ns1__findGingkoUnitInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__findGingkoUnitInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__findGingkoUnitInfo * SOAP_FMAC4 soap_in___ns1__findGingkoUnitInfo(struct soap *soap, const char *tag, struct __ns1__findGingkoUnitInfo *a, const char *type)
{
	size_t soap_flag_ns1__findGingkoUnitInfo_ = 1;
	short soap_flag;
	a = (struct __ns1__findGingkoUnitInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__findGingkoUnitInfo, sizeof(struct __ns1__findGingkoUnitInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__findGingkoUnitInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__findGingkoUnitInfo_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__findGingkoUnitInfo(soap, "ns1:findGingkoUnitInfo", &a->ns1__findGingkoUnitInfo_, "ns1:findGingkoUnitInfo"))
				{	soap_flag_ns1__findGingkoUnitInfo_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__findGingkoUnitInfo * SOAP_FMAC4 soap_instantiate___ns1__findGingkoUnitInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__findGingkoUnitInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__findGingkoUnitInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__findGingkoUnitInfo;
		if (size)
			*size = sizeof(struct __ns1__findGingkoUnitInfo);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__findGingkoUnitInfo[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__findGingkoUnitInfo);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__findGingkoUnitInfo*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__findGingkoUnitInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__findGingkoUnitInfo %p -> %p\n", q, p));
	*(struct __ns1__findGingkoUnitInfo*)p = *(struct __ns1__findGingkoUnitInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__registerThisUnit(struct soap *soap, struct __ns1__registerThisUnit *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__registerThisUnit_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__registerThisUnit(struct soap *soap, const struct __ns1__registerThisUnit *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__registerThisUnit(soap, &a->ns1__registerThisUnit_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__registerThisUnit(struct soap *soap, const struct __ns1__registerThisUnit *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__registerThisUnit(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__registerThisUnit(struct soap *soap, const char *tag, int id, const struct __ns1__registerThisUnit *a, const char *type)
{
	if (soap_out_PointerTons1__registerThisUnit(soap, "ns1:registerThisUnit", -1, &a->ns1__registerThisUnit_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__registerThisUnit * SOAP_FMAC4 soap_get___ns1__registerThisUnit(struct soap *soap, struct __ns1__registerThisUnit *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__registerThisUnit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__registerThisUnit * SOAP_FMAC4 soap_in___ns1__registerThisUnit(struct soap *soap, const char *tag, struct __ns1__registerThisUnit *a, const char *type)
{
	size_t soap_flag_ns1__registerThisUnit_ = 1;
	short soap_flag;
	a = (struct __ns1__registerThisUnit *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__registerThisUnit, sizeof(struct __ns1__registerThisUnit), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__registerThisUnit(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__registerThisUnit_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__registerThisUnit(soap, "ns1:registerThisUnit", &a->ns1__registerThisUnit_, "ns1:registerThisUnit"))
				{	soap_flag_ns1__registerThisUnit_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__registerThisUnit * SOAP_FMAC4 soap_instantiate___ns1__registerThisUnit(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__registerThisUnit(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__registerThisUnit, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__registerThisUnit;
		if (size)
			*size = sizeof(struct __ns1__registerThisUnit);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__registerThisUnit[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__registerThisUnit);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__registerThisUnit*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__registerThisUnit(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__registerThisUnit %p -> %p\n", q, p));
	*(struct __ns1__registerThisUnit*)p = *(struct __ns1__registerThisUnit*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__checkToken(struct soap *soap, struct __ns1__checkToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__checkToken_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__checkToken(struct soap *soap, const struct __ns1__checkToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__checkToken(soap, &a->ns1__checkToken_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__checkToken(struct soap *soap, const struct __ns1__checkToken *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__checkToken(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__checkToken(struct soap *soap, const char *tag, int id, const struct __ns1__checkToken *a, const char *type)
{
	if (soap_out_PointerTons1__checkToken(soap, "ns1:checkToken", -1, &a->ns1__checkToken_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__checkToken * SOAP_FMAC4 soap_get___ns1__checkToken(struct soap *soap, struct __ns1__checkToken *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__checkToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__checkToken * SOAP_FMAC4 soap_in___ns1__checkToken(struct soap *soap, const char *tag, struct __ns1__checkToken *a, const char *type)
{
	size_t soap_flag_ns1__checkToken_ = 1;
	short soap_flag;
	a = (struct __ns1__checkToken *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__checkToken, sizeof(struct __ns1__checkToken), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__checkToken(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__checkToken_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__checkToken(soap, "ns1:checkToken", &a->ns1__checkToken_, "ns1:checkToken"))
				{	soap_flag_ns1__checkToken_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__checkToken * SOAP_FMAC4 soap_instantiate___ns1__checkToken(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__checkToken(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__checkToken, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__checkToken;
		if (size)
			*size = sizeof(struct __ns1__checkToken);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__checkToken[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__checkToken);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__checkToken*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__checkToken(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__checkToken %p -> %p\n", q, p));
	*(struct __ns1__checkToken*)p = *(struct __ns1__checkToken*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__newGingkoId(struct soap *soap, struct __ns1__newGingkoId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__newGingkoId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__newGingkoId(struct soap *soap, const struct __ns1__newGingkoId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__newGingkoId(soap, &a->ns1__newGingkoId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__newGingkoId(struct soap *soap, const struct __ns1__newGingkoId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__newGingkoId(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__newGingkoId(struct soap *soap, const char *tag, int id, const struct __ns1__newGingkoId *a, const char *type)
{
	if (soap_out_PointerTons1__newGingkoId(soap, "ns1:newGingkoId", -1, &a->ns1__newGingkoId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__newGingkoId * SOAP_FMAC4 soap_get___ns1__newGingkoId(struct soap *soap, struct __ns1__newGingkoId *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__newGingkoId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__newGingkoId * SOAP_FMAC4 soap_in___ns1__newGingkoId(struct soap *soap, const char *tag, struct __ns1__newGingkoId *a, const char *type)
{
	size_t soap_flag_ns1__newGingkoId_ = 1;
	short soap_flag;
	a = (struct __ns1__newGingkoId *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__newGingkoId, sizeof(struct __ns1__newGingkoId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__newGingkoId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__newGingkoId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__newGingkoId(soap, "ns1:newGingkoId", &a->ns1__newGingkoId_, "ns1:newGingkoId"))
				{	soap_flag_ns1__newGingkoId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__newGingkoId * SOAP_FMAC4 soap_instantiate___ns1__newGingkoId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__newGingkoId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__newGingkoId, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__newGingkoId;
		if (size)
			*size = sizeof(struct __ns1__newGingkoId);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__newGingkoId[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__newGingkoId);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__newGingkoId*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__newGingkoId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__newGingkoId %p -> %p\n", q, p));
	*(struct __ns1__newGingkoId*)p = *(struct __ns1__newGingkoId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__gingkoVersion(struct soap *soap, struct __ns1__gingkoVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__gingkoVersion_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__gingkoVersion(struct soap *soap, const struct __ns1__gingkoVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__gingkoVersion(soap, &a->ns1__gingkoVersion_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__gingkoVersion(struct soap *soap, const struct __ns1__gingkoVersion *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__gingkoVersion(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__gingkoVersion(struct soap *soap, const char *tag, int id, const struct __ns1__gingkoVersion *a, const char *type)
{
	if (soap_out_PointerTons1__gingkoVersion(soap, "ns1:gingkoVersion", -1, &a->ns1__gingkoVersion_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__gingkoVersion * SOAP_FMAC4 soap_get___ns1__gingkoVersion(struct soap *soap, struct __ns1__gingkoVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__gingkoVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__gingkoVersion * SOAP_FMAC4 soap_in___ns1__gingkoVersion(struct soap *soap, const char *tag, struct __ns1__gingkoVersion *a, const char *type)
{
	size_t soap_flag_ns1__gingkoVersion_ = 1;
	short soap_flag;
	a = (struct __ns1__gingkoVersion *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__gingkoVersion, sizeof(struct __ns1__gingkoVersion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__gingkoVersion(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__gingkoVersion_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__gingkoVersion(soap, "ns1:gingkoVersion", &a->ns1__gingkoVersion_, "ns1:gingkoVersion"))
				{	soap_flag_ns1__gingkoVersion_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__gingkoVersion * SOAP_FMAC4 soap_instantiate___ns1__gingkoVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__gingkoVersion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__gingkoVersion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__gingkoVersion;
		if (size)
			*size = sizeof(struct __ns1__gingkoVersion);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__gingkoVersion[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__gingkoVersion);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__gingkoVersion*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__gingkoVersion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__gingkoVersion %p -> %p\n", q, p));
	*(struct __ns1__gingkoVersion*)p = *(struct __ns1__gingkoVersion*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__userLogin(struct soap *soap, struct __ns1__userLogin *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__userLogin_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__userLogin(struct soap *soap, const struct __ns1__userLogin *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__userLogin(soap, &a->ns1__userLogin_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__userLogin(struct soap *soap, const struct __ns1__userLogin *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__userLogin(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__userLogin(struct soap *soap, const char *tag, int id, const struct __ns1__userLogin *a, const char *type)
{
	if (soap_out_PointerTons1__userLogin(soap, "ns1:userLogin", -1, &a->ns1__userLogin_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__userLogin * SOAP_FMAC4 soap_get___ns1__userLogin(struct soap *soap, struct __ns1__userLogin *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__userLogin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__userLogin * SOAP_FMAC4 soap_in___ns1__userLogin(struct soap *soap, const char *tag, struct __ns1__userLogin *a, const char *type)
{
	size_t soap_flag_ns1__userLogin_ = 1;
	short soap_flag;
	a = (struct __ns1__userLogin *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__userLogin, sizeof(struct __ns1__userLogin), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__userLogin(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__userLogin_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__userLogin(soap, "ns1:userLogin", &a->ns1__userLogin_, "ns1:userLogin"))
				{	soap_flag_ns1__userLogin_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__userLogin * SOAP_FMAC4 soap_instantiate___ns1__userLogin(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__userLogin(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__userLogin, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__userLogin;
		if (size)
			*size = sizeof(struct __ns1__userLogin);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__userLogin[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__userLogin);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__userLogin*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__userLogin(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__userLogin %p -> %p\n", q, p));
	*(struct __ns1__userLogin*)p = *(struct __ns1__userLogin*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__registerUser(struct soap *soap, struct __ns1__registerUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__registerUser_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__registerUser(struct soap *soap, const struct __ns1__registerUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__registerUser(soap, &a->ns1__registerUser_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__registerUser(struct soap *soap, const struct __ns1__registerUser *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__registerUser(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__registerUser(struct soap *soap, const char *tag, int id, const struct __ns1__registerUser *a, const char *type)
{
	if (soap_out_PointerTons1__registerUser(soap, "ns1:registerUser", -1, &a->ns1__registerUser_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__registerUser * SOAP_FMAC4 soap_get___ns1__registerUser(struct soap *soap, struct __ns1__registerUser *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__registerUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__registerUser * SOAP_FMAC4 soap_in___ns1__registerUser(struct soap *soap, const char *tag, struct __ns1__registerUser *a, const char *type)
{
	size_t soap_flag_ns1__registerUser_ = 1;
	short soap_flag;
	a = (struct __ns1__registerUser *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__registerUser, sizeof(struct __ns1__registerUser), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__registerUser(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__registerUser_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__registerUser(soap, "ns1:registerUser", &a->ns1__registerUser_, "ns1:registerUser"))
				{	soap_flag_ns1__registerUser_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__registerUser * SOAP_FMAC4 soap_instantiate___ns1__registerUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__registerUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__registerUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__registerUser;
		if (size)
			*size = sizeof(struct __ns1__registerUser);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__registerUser[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__registerUser);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__registerUser*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__registerUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__registerUser %p -> %p\n", q, p));
	*(struct __ns1__registerUser*)p = *(struct __ns1__registerUser*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__createDigitalInfoResponse(struct soap *soap, ns1__createDigitalInfoResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__createDigitalInfoResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__createDigitalInfoResponse(struct soap *soap, ns1__createDigitalInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__createDigitalInfoResponse);
	if (soap_out_PointerTons1__createDigitalInfoResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__createDigitalInfoResponse(struct soap *soap, const char *tag, int id, ns1__createDigitalInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__createDigitalInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__createDigitalInfoResponse ** SOAP_FMAC4 soap_get_PointerTons1__createDigitalInfoResponse(struct soap *soap, ns1__createDigitalInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__createDigitalInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__createDigitalInfoResponse ** SOAP_FMAC4 soap_in_PointerTons1__createDigitalInfoResponse(struct soap *soap, const char *tag, ns1__createDigitalInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__createDigitalInfoResponse **)soap_malloc(soap, sizeof(ns1__createDigitalInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__createDigitalInfoResponse *)soap_instantiate_ns1__createDigitalInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__createDigitalInfoResponse ** p = (ns1__createDigitalInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__createDigitalInfoResponse, sizeof(ns1__createDigitalInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__createDigitalInfo(struct soap *soap, ns1__createDigitalInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__createDigitalInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__createDigitalInfo(struct soap *soap, ns1__createDigitalInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__createDigitalInfo);
	if (soap_out_PointerTons1__createDigitalInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__createDigitalInfo(struct soap *soap, const char *tag, int id, ns1__createDigitalInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__createDigitalInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__createDigitalInfo ** SOAP_FMAC4 soap_get_PointerTons1__createDigitalInfo(struct soap *soap, ns1__createDigitalInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__createDigitalInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__createDigitalInfo ** SOAP_FMAC4 soap_in_PointerTons1__createDigitalInfo(struct soap *soap, const char *tag, ns1__createDigitalInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__createDigitalInfo **)soap_malloc(soap, sizeof(ns1__createDigitalInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__createDigitalInfo *)soap_instantiate_ns1__createDigitalInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__createDigitalInfo ** p = (ns1__createDigitalInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__createDigitalInfo, sizeof(ns1__createDigitalInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__updateDigitalInfoResponse(struct soap *soap, ns1__updateDigitalInfoResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__updateDigitalInfoResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__updateDigitalInfoResponse(struct soap *soap, ns1__updateDigitalInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__updateDigitalInfoResponse);
	if (soap_out_PointerTons1__updateDigitalInfoResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__updateDigitalInfoResponse(struct soap *soap, const char *tag, int id, ns1__updateDigitalInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__updateDigitalInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__updateDigitalInfoResponse ** SOAP_FMAC4 soap_get_PointerTons1__updateDigitalInfoResponse(struct soap *soap, ns1__updateDigitalInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__updateDigitalInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__updateDigitalInfoResponse ** SOAP_FMAC4 soap_in_PointerTons1__updateDigitalInfoResponse(struct soap *soap, const char *tag, ns1__updateDigitalInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__updateDigitalInfoResponse **)soap_malloc(soap, sizeof(ns1__updateDigitalInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__updateDigitalInfoResponse *)soap_instantiate_ns1__updateDigitalInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__updateDigitalInfoResponse ** p = (ns1__updateDigitalInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__updateDigitalInfoResponse, sizeof(ns1__updateDigitalInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__updateDigitalInfo(struct soap *soap, ns1__updateDigitalInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__updateDigitalInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__updateDigitalInfo(struct soap *soap, ns1__updateDigitalInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__updateDigitalInfo);
	if (soap_out_PointerTons1__updateDigitalInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__updateDigitalInfo(struct soap *soap, const char *tag, int id, ns1__updateDigitalInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__updateDigitalInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__updateDigitalInfo ** SOAP_FMAC4 soap_get_PointerTons1__updateDigitalInfo(struct soap *soap, ns1__updateDigitalInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__updateDigitalInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__updateDigitalInfo ** SOAP_FMAC4 soap_in_PointerTons1__updateDigitalInfo(struct soap *soap, const char *tag, ns1__updateDigitalInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__updateDigitalInfo **)soap_malloc(soap, sizeof(ns1__updateDigitalInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__updateDigitalInfo *)soap_instantiate_ns1__updateDigitalInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__updateDigitalInfo ** p = (ns1__updateDigitalInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__updateDigitalInfo, sizeof(ns1__updateDigitalInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__findDigitalPermissionResponse(struct soap *soap, ns1__findDigitalPermissionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__findDigitalPermissionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__findDigitalPermissionResponse(struct soap *soap, ns1__findDigitalPermissionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__findDigitalPermissionResponse);
	if (soap_out_PointerTons1__findDigitalPermissionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__findDigitalPermissionResponse(struct soap *soap, const char *tag, int id, ns1__findDigitalPermissionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__findDigitalPermissionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__findDigitalPermissionResponse ** SOAP_FMAC4 soap_get_PointerTons1__findDigitalPermissionResponse(struct soap *soap, ns1__findDigitalPermissionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__findDigitalPermissionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__findDigitalPermissionResponse ** SOAP_FMAC4 soap_in_PointerTons1__findDigitalPermissionResponse(struct soap *soap, const char *tag, ns1__findDigitalPermissionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__findDigitalPermissionResponse **)soap_malloc(soap, sizeof(ns1__findDigitalPermissionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__findDigitalPermissionResponse *)soap_instantiate_ns1__findDigitalPermissionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__findDigitalPermissionResponse ** p = (ns1__findDigitalPermissionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__findDigitalPermissionResponse, sizeof(ns1__findDigitalPermissionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__findDigitalPermission(struct soap *soap, ns1__findDigitalPermission *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__findDigitalPermission))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__findDigitalPermission(struct soap *soap, ns1__findDigitalPermission *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__findDigitalPermission);
	if (soap_out_PointerTons1__findDigitalPermission(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__findDigitalPermission(struct soap *soap, const char *tag, int id, ns1__findDigitalPermission *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__findDigitalPermission);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__findDigitalPermission ** SOAP_FMAC4 soap_get_PointerTons1__findDigitalPermission(struct soap *soap, ns1__findDigitalPermission **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__findDigitalPermission(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__findDigitalPermission ** SOAP_FMAC4 soap_in_PointerTons1__findDigitalPermission(struct soap *soap, const char *tag, ns1__findDigitalPermission **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__findDigitalPermission **)soap_malloc(soap, sizeof(ns1__findDigitalPermission *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__findDigitalPermission *)soap_instantiate_ns1__findDigitalPermission(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__findDigitalPermission ** p = (ns1__findDigitalPermission **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__findDigitalPermission, sizeof(ns1__findDigitalPermission), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__assignPermissionResponse(struct soap *soap, ns1__assignPermissionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__assignPermissionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__assignPermissionResponse(struct soap *soap, ns1__assignPermissionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__assignPermissionResponse);
	if (soap_out_PointerTons1__assignPermissionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__assignPermissionResponse(struct soap *soap, const char *tag, int id, ns1__assignPermissionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__assignPermissionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__assignPermissionResponse ** SOAP_FMAC4 soap_get_PointerTons1__assignPermissionResponse(struct soap *soap, ns1__assignPermissionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__assignPermissionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__assignPermissionResponse ** SOAP_FMAC4 soap_in_PointerTons1__assignPermissionResponse(struct soap *soap, const char *tag, ns1__assignPermissionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__assignPermissionResponse **)soap_malloc(soap, sizeof(ns1__assignPermissionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__assignPermissionResponse *)soap_instantiate_ns1__assignPermissionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__assignPermissionResponse ** p = (ns1__assignPermissionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__assignPermissionResponse, sizeof(ns1__assignPermissionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__assignPermission(struct soap *soap, ns1__assignPermission *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__assignPermission))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__assignPermission(struct soap *soap, ns1__assignPermission *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__assignPermission);
	if (soap_out_PointerTons1__assignPermission(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__assignPermission(struct soap *soap, const char *tag, int id, ns1__assignPermission *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__assignPermission);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__assignPermission ** SOAP_FMAC4 soap_get_PointerTons1__assignPermission(struct soap *soap, ns1__assignPermission **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__assignPermission(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__assignPermission ** SOAP_FMAC4 soap_in_PointerTons1__assignPermission(struct soap *soap, const char *tag, ns1__assignPermission **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__assignPermission **)soap_malloc(soap, sizeof(ns1__assignPermission *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__assignPermission *)soap_instantiate_ns1__assignPermission(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__assignPermission ** p = (ns1__assignPermission **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__assignPermission, sizeof(ns1__assignPermission), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__findAssignedPermissionResponse(struct soap *soap, ns1__findAssignedPermissionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__findAssignedPermissionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__findAssignedPermissionResponse(struct soap *soap, ns1__findAssignedPermissionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__findAssignedPermissionResponse);
	if (soap_out_PointerTons1__findAssignedPermissionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__findAssignedPermissionResponse(struct soap *soap, const char *tag, int id, ns1__findAssignedPermissionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__findAssignedPermissionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__findAssignedPermissionResponse ** SOAP_FMAC4 soap_get_PointerTons1__findAssignedPermissionResponse(struct soap *soap, ns1__findAssignedPermissionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__findAssignedPermissionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__findAssignedPermissionResponse ** SOAP_FMAC4 soap_in_PointerTons1__findAssignedPermissionResponse(struct soap *soap, const char *tag, ns1__findAssignedPermissionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__findAssignedPermissionResponse **)soap_malloc(soap, sizeof(ns1__findAssignedPermissionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__findAssignedPermissionResponse *)soap_instantiate_ns1__findAssignedPermissionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__findAssignedPermissionResponse ** p = (ns1__findAssignedPermissionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__findAssignedPermissionResponse, sizeof(ns1__findAssignedPermissionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__findAssignedPermission(struct soap *soap, ns1__findAssignedPermission *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__findAssignedPermission))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__findAssignedPermission(struct soap *soap, ns1__findAssignedPermission *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__findAssignedPermission);
	if (soap_out_PointerTons1__findAssignedPermission(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__findAssignedPermission(struct soap *soap, const char *tag, int id, ns1__findAssignedPermission *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__findAssignedPermission);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__findAssignedPermission ** SOAP_FMAC4 soap_get_PointerTons1__findAssignedPermission(struct soap *soap, ns1__findAssignedPermission **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__findAssignedPermission(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__findAssignedPermission ** SOAP_FMAC4 soap_in_PointerTons1__findAssignedPermission(struct soap *soap, const char *tag, ns1__findAssignedPermission **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__findAssignedPermission **)soap_malloc(soap, sizeof(ns1__findAssignedPermission *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__findAssignedPermission *)soap_instantiate_ns1__findAssignedPermission(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__findAssignedPermission ** p = (ns1__findAssignedPermission **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__findAssignedPermission, sizeof(ns1__findAssignedPermission), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__findDigitalInfoResponse(struct soap *soap, ns1__findDigitalInfoResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__findDigitalInfoResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__findDigitalInfoResponse(struct soap *soap, ns1__findDigitalInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__findDigitalInfoResponse);
	if (soap_out_PointerTons1__findDigitalInfoResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__findDigitalInfoResponse(struct soap *soap, const char *tag, int id, ns1__findDigitalInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__findDigitalInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__findDigitalInfoResponse ** SOAP_FMAC4 soap_get_PointerTons1__findDigitalInfoResponse(struct soap *soap, ns1__findDigitalInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__findDigitalInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__findDigitalInfoResponse ** SOAP_FMAC4 soap_in_PointerTons1__findDigitalInfoResponse(struct soap *soap, const char *tag, ns1__findDigitalInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__findDigitalInfoResponse **)soap_malloc(soap, sizeof(ns1__findDigitalInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__findDigitalInfoResponse *)soap_instantiate_ns1__findDigitalInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__findDigitalInfoResponse ** p = (ns1__findDigitalInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__findDigitalInfoResponse, sizeof(ns1__findDigitalInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__findDigitalInfo(struct soap *soap, ns1__findDigitalInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__findDigitalInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__findDigitalInfo(struct soap *soap, ns1__findDigitalInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__findDigitalInfo);
	if (soap_out_PointerTons1__findDigitalInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__findDigitalInfo(struct soap *soap, const char *tag, int id, ns1__findDigitalInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__findDigitalInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__findDigitalInfo ** SOAP_FMAC4 soap_get_PointerTons1__findDigitalInfo(struct soap *soap, ns1__findDigitalInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__findDigitalInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__findDigitalInfo ** SOAP_FMAC4 soap_in_PointerTons1__findDigitalInfo(struct soap *soap, const char *tag, ns1__findDigitalInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__findDigitalInfo **)soap_malloc(soap, sizeof(ns1__findDigitalInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__findDigitalInfo *)soap_instantiate_ns1__findDigitalInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__findDigitalInfo ** p = (ns1__findDigitalInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__findDigitalInfo, sizeof(ns1__findDigitalInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__deleteDigitalInfoResponse(struct soap *soap, ns1__deleteDigitalInfoResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__deleteDigitalInfoResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__deleteDigitalInfoResponse(struct soap *soap, ns1__deleteDigitalInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__deleteDigitalInfoResponse);
	if (soap_out_PointerTons1__deleteDigitalInfoResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__deleteDigitalInfoResponse(struct soap *soap, const char *tag, int id, ns1__deleteDigitalInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__deleteDigitalInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__deleteDigitalInfoResponse ** SOAP_FMAC4 soap_get_PointerTons1__deleteDigitalInfoResponse(struct soap *soap, ns1__deleteDigitalInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__deleteDigitalInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__deleteDigitalInfoResponse ** SOAP_FMAC4 soap_in_PointerTons1__deleteDigitalInfoResponse(struct soap *soap, const char *tag, ns1__deleteDigitalInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__deleteDigitalInfoResponse **)soap_malloc(soap, sizeof(ns1__deleteDigitalInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__deleteDigitalInfoResponse *)soap_instantiate_ns1__deleteDigitalInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__deleteDigitalInfoResponse ** p = (ns1__deleteDigitalInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deleteDigitalInfoResponse, sizeof(ns1__deleteDigitalInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__deleteDigitalInfo(struct soap *soap, ns1__deleteDigitalInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__deleteDigitalInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__deleteDigitalInfo(struct soap *soap, ns1__deleteDigitalInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__deleteDigitalInfo);
	if (soap_out_PointerTons1__deleteDigitalInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__deleteDigitalInfo(struct soap *soap, const char *tag, int id, ns1__deleteDigitalInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__deleteDigitalInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__deleteDigitalInfo ** SOAP_FMAC4 soap_get_PointerTons1__deleteDigitalInfo(struct soap *soap, ns1__deleteDigitalInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__deleteDigitalInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__deleteDigitalInfo ** SOAP_FMAC4 soap_in_PointerTons1__deleteDigitalInfo(struct soap *soap, const char *tag, ns1__deleteDigitalInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__deleteDigitalInfo **)soap_malloc(soap, sizeof(ns1__deleteDigitalInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__deleteDigitalInfo *)soap_instantiate_ns1__deleteDigitalInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__deleteDigitalInfo ** p = (ns1__deleteDigitalInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deleteDigitalInfo, sizeof(ns1__deleteDigitalInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__requestPermissionResponse(struct soap *soap, ns1__requestPermissionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__requestPermissionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__requestPermissionResponse(struct soap *soap, ns1__requestPermissionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__requestPermissionResponse);
	if (soap_out_PointerTons1__requestPermissionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__requestPermissionResponse(struct soap *soap, const char *tag, int id, ns1__requestPermissionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__requestPermissionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__requestPermissionResponse ** SOAP_FMAC4 soap_get_PointerTons1__requestPermissionResponse(struct soap *soap, ns1__requestPermissionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__requestPermissionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__requestPermissionResponse ** SOAP_FMAC4 soap_in_PointerTons1__requestPermissionResponse(struct soap *soap, const char *tag, ns1__requestPermissionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__requestPermissionResponse **)soap_malloc(soap, sizeof(ns1__requestPermissionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__requestPermissionResponse *)soap_instantiate_ns1__requestPermissionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__requestPermissionResponse ** p = (ns1__requestPermissionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__requestPermissionResponse, sizeof(ns1__requestPermissionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__requestPermission(struct soap *soap, ns1__requestPermission *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__requestPermission))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__requestPermission(struct soap *soap, ns1__requestPermission *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__requestPermission);
	if (soap_out_PointerTons1__requestPermission(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__requestPermission(struct soap *soap, const char *tag, int id, ns1__requestPermission *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__requestPermission);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__requestPermission ** SOAP_FMAC4 soap_get_PointerTons1__requestPermission(struct soap *soap, ns1__requestPermission **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__requestPermission(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__requestPermission ** SOAP_FMAC4 soap_in_PointerTons1__requestPermission(struct soap *soap, const char *tag, ns1__requestPermission **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__requestPermission **)soap_malloc(soap, sizeof(ns1__requestPermission *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__requestPermission *)soap_instantiate_ns1__requestPermission(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__requestPermission ** p = (ns1__requestPermission **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__requestPermission, sizeof(ns1__requestPermission), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__changePasswordResponse(struct soap *soap, ns1__changePasswordResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__changePasswordResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__changePasswordResponse(struct soap *soap, ns1__changePasswordResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__changePasswordResponse);
	if (soap_out_PointerTons1__changePasswordResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__changePasswordResponse(struct soap *soap, const char *tag, int id, ns1__changePasswordResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__changePasswordResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__changePasswordResponse ** SOAP_FMAC4 soap_get_PointerTons1__changePasswordResponse(struct soap *soap, ns1__changePasswordResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__changePasswordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__changePasswordResponse ** SOAP_FMAC4 soap_in_PointerTons1__changePasswordResponse(struct soap *soap, const char *tag, ns1__changePasswordResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__changePasswordResponse **)soap_malloc(soap, sizeof(ns1__changePasswordResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__changePasswordResponse *)soap_instantiate_ns1__changePasswordResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__changePasswordResponse ** p = (ns1__changePasswordResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__changePasswordResponse, sizeof(ns1__changePasswordResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__changePassword(struct soap *soap, ns1__changePassword *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__changePassword))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__changePassword(struct soap *soap, ns1__changePassword *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__changePassword);
	if (soap_out_PointerTons1__changePassword(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__changePassword(struct soap *soap, const char *tag, int id, ns1__changePassword *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__changePassword);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__changePassword ** SOAP_FMAC4 soap_get_PointerTons1__changePassword(struct soap *soap, ns1__changePassword **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__changePassword(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__changePassword ** SOAP_FMAC4 soap_in_PointerTons1__changePassword(struct soap *soap, const char *tag, ns1__changePassword **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__changePassword **)soap_malloc(soap, sizeof(ns1__changePassword *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__changePassword *)soap_instantiate_ns1__changePassword(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__changePassword ** p = (ns1__changePassword **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__changePassword, sizeof(ns1__changePassword), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__findUserByGingkoIdResponse(struct soap *soap, ns1__findUserByGingkoIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__findUserByGingkoIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__findUserByGingkoIdResponse(struct soap *soap, ns1__findUserByGingkoIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__findUserByGingkoIdResponse);
	if (soap_out_PointerTons1__findUserByGingkoIdResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__findUserByGingkoIdResponse(struct soap *soap, const char *tag, int id, ns1__findUserByGingkoIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__findUserByGingkoIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__findUserByGingkoIdResponse ** SOAP_FMAC4 soap_get_PointerTons1__findUserByGingkoIdResponse(struct soap *soap, ns1__findUserByGingkoIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__findUserByGingkoIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__findUserByGingkoIdResponse ** SOAP_FMAC4 soap_in_PointerTons1__findUserByGingkoIdResponse(struct soap *soap, const char *tag, ns1__findUserByGingkoIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__findUserByGingkoIdResponse **)soap_malloc(soap, sizeof(ns1__findUserByGingkoIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__findUserByGingkoIdResponse *)soap_instantiate_ns1__findUserByGingkoIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__findUserByGingkoIdResponse ** p = (ns1__findUserByGingkoIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__findUserByGingkoIdResponse, sizeof(ns1__findUserByGingkoIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__findUserByGingkoId(struct soap *soap, ns1__findUserByGingkoId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__findUserByGingkoId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__findUserByGingkoId(struct soap *soap, ns1__findUserByGingkoId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__findUserByGingkoId);
	if (soap_out_PointerTons1__findUserByGingkoId(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__findUserByGingkoId(struct soap *soap, const char *tag, int id, ns1__findUserByGingkoId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__findUserByGingkoId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__findUserByGingkoId ** SOAP_FMAC4 soap_get_PointerTons1__findUserByGingkoId(struct soap *soap, ns1__findUserByGingkoId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__findUserByGingkoId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__findUserByGingkoId ** SOAP_FMAC4 soap_in_PointerTons1__findUserByGingkoId(struct soap *soap, const char *tag, ns1__findUserByGingkoId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__findUserByGingkoId **)soap_malloc(soap, sizeof(ns1__findUserByGingkoId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__findUserByGingkoId *)soap_instantiate_ns1__findUserByGingkoId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__findUserByGingkoId ** p = (ns1__findUserByGingkoId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__findUserByGingkoId, sizeof(ns1__findUserByGingkoId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__searchUsersResponse(struct soap *soap, ns1__searchUsersResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__searchUsersResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__searchUsersResponse(struct soap *soap, ns1__searchUsersResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__searchUsersResponse);
	if (soap_out_PointerTons1__searchUsersResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__searchUsersResponse(struct soap *soap, const char *tag, int id, ns1__searchUsersResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__searchUsersResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__searchUsersResponse ** SOAP_FMAC4 soap_get_PointerTons1__searchUsersResponse(struct soap *soap, ns1__searchUsersResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__searchUsersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__searchUsersResponse ** SOAP_FMAC4 soap_in_PointerTons1__searchUsersResponse(struct soap *soap, const char *tag, ns1__searchUsersResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__searchUsersResponse **)soap_malloc(soap, sizeof(ns1__searchUsersResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__searchUsersResponse *)soap_instantiate_ns1__searchUsersResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__searchUsersResponse ** p = (ns1__searchUsersResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchUsersResponse, sizeof(ns1__searchUsersResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__searchUsers(struct soap *soap, ns1__searchUsers *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__searchUsers))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__searchUsers(struct soap *soap, ns1__searchUsers *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__searchUsers);
	if (soap_out_PointerTons1__searchUsers(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__searchUsers(struct soap *soap, const char *tag, int id, ns1__searchUsers *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__searchUsers);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__searchUsers ** SOAP_FMAC4 soap_get_PointerTons1__searchUsers(struct soap *soap, ns1__searchUsers **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__searchUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__searchUsers ** SOAP_FMAC4 soap_in_PointerTons1__searchUsers(struct soap *soap, const char *tag, ns1__searchUsers **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__searchUsers **)soap_malloc(soap, sizeof(ns1__searchUsers *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__searchUsers *)soap_instantiate_ns1__searchUsers(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__searchUsers ** p = (ns1__searchUsers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchUsers, sizeof(ns1__searchUsers), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__findUserByLoginIdResponse(struct soap *soap, ns1__findUserByLoginIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__findUserByLoginIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__findUserByLoginIdResponse(struct soap *soap, ns1__findUserByLoginIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__findUserByLoginIdResponse);
	if (soap_out_PointerTons1__findUserByLoginIdResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__findUserByLoginIdResponse(struct soap *soap, const char *tag, int id, ns1__findUserByLoginIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__findUserByLoginIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__findUserByLoginIdResponse ** SOAP_FMAC4 soap_get_PointerTons1__findUserByLoginIdResponse(struct soap *soap, ns1__findUserByLoginIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__findUserByLoginIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__findUserByLoginIdResponse ** SOAP_FMAC4 soap_in_PointerTons1__findUserByLoginIdResponse(struct soap *soap, const char *tag, ns1__findUserByLoginIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__findUserByLoginIdResponse **)soap_malloc(soap, sizeof(ns1__findUserByLoginIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__findUserByLoginIdResponse *)soap_instantiate_ns1__findUserByLoginIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__findUserByLoginIdResponse ** p = (ns1__findUserByLoginIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__findUserByLoginIdResponse, sizeof(ns1__findUserByLoginIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__findUserByLoginId(struct soap *soap, ns1__findUserByLoginId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__findUserByLoginId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__findUserByLoginId(struct soap *soap, ns1__findUserByLoginId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__findUserByLoginId);
	if (soap_out_PointerTons1__findUserByLoginId(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__findUserByLoginId(struct soap *soap, const char *tag, int id, ns1__findUserByLoginId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__findUserByLoginId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__findUserByLoginId ** SOAP_FMAC4 soap_get_PointerTons1__findUserByLoginId(struct soap *soap, ns1__findUserByLoginId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__findUserByLoginId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__findUserByLoginId ** SOAP_FMAC4 soap_in_PointerTons1__findUserByLoginId(struct soap *soap, const char *tag, ns1__findUserByLoginId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__findUserByLoginId **)soap_malloc(soap, sizeof(ns1__findUserByLoginId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__findUserByLoginId *)soap_instantiate_ns1__findUserByLoginId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__findUserByLoginId ** p = (ns1__findUserByLoginId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__findUserByLoginId, sizeof(ns1__findUserByLoginId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__bindingGingkoUserResponse(struct soap *soap, ns1__bindingGingkoUserResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__bindingGingkoUserResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__bindingGingkoUserResponse(struct soap *soap, ns1__bindingGingkoUserResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__bindingGingkoUserResponse);
	if (soap_out_PointerTons1__bindingGingkoUserResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__bindingGingkoUserResponse(struct soap *soap, const char *tag, int id, ns1__bindingGingkoUserResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__bindingGingkoUserResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__bindingGingkoUserResponse ** SOAP_FMAC4 soap_get_PointerTons1__bindingGingkoUserResponse(struct soap *soap, ns1__bindingGingkoUserResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__bindingGingkoUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__bindingGingkoUserResponse ** SOAP_FMAC4 soap_in_PointerTons1__bindingGingkoUserResponse(struct soap *soap, const char *tag, ns1__bindingGingkoUserResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__bindingGingkoUserResponse **)soap_malloc(soap, sizeof(ns1__bindingGingkoUserResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__bindingGingkoUserResponse *)soap_instantiate_ns1__bindingGingkoUserResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__bindingGingkoUserResponse ** p = (ns1__bindingGingkoUserResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__bindingGingkoUserResponse, sizeof(ns1__bindingGingkoUserResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__bindingGingkoUser(struct soap *soap, ns1__bindingGingkoUser *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__bindingGingkoUser))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__bindingGingkoUser(struct soap *soap, ns1__bindingGingkoUser *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__bindingGingkoUser);
	if (soap_out_PointerTons1__bindingGingkoUser(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__bindingGingkoUser(struct soap *soap, const char *tag, int id, ns1__bindingGingkoUser *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__bindingGingkoUser);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__bindingGingkoUser ** SOAP_FMAC4 soap_get_PointerTons1__bindingGingkoUser(struct soap *soap, ns1__bindingGingkoUser **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__bindingGingkoUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__bindingGingkoUser ** SOAP_FMAC4 soap_in_PointerTons1__bindingGingkoUser(struct soap *soap, const char *tag, ns1__bindingGingkoUser **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__bindingGingkoUser **)soap_malloc(soap, sizeof(ns1__bindingGingkoUser *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__bindingGingkoUser *)soap_instantiate_ns1__bindingGingkoUser(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__bindingGingkoUser ** p = (ns1__bindingGingkoUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__bindingGingkoUser, sizeof(ns1__bindingGingkoUser), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__findGingkoUnitInfoResponse(struct soap *soap, ns1__findGingkoUnitInfoResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__findGingkoUnitInfoResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__findGingkoUnitInfoResponse(struct soap *soap, ns1__findGingkoUnitInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__findGingkoUnitInfoResponse);
	if (soap_out_PointerTons1__findGingkoUnitInfoResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__findGingkoUnitInfoResponse(struct soap *soap, const char *tag, int id, ns1__findGingkoUnitInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__findGingkoUnitInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__findGingkoUnitInfoResponse ** SOAP_FMAC4 soap_get_PointerTons1__findGingkoUnitInfoResponse(struct soap *soap, ns1__findGingkoUnitInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__findGingkoUnitInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__findGingkoUnitInfoResponse ** SOAP_FMAC4 soap_in_PointerTons1__findGingkoUnitInfoResponse(struct soap *soap, const char *tag, ns1__findGingkoUnitInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__findGingkoUnitInfoResponse **)soap_malloc(soap, sizeof(ns1__findGingkoUnitInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__findGingkoUnitInfoResponse *)soap_instantiate_ns1__findGingkoUnitInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__findGingkoUnitInfoResponse ** p = (ns1__findGingkoUnitInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__findGingkoUnitInfoResponse, sizeof(ns1__findGingkoUnitInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__findGingkoUnitInfo(struct soap *soap, ns1__findGingkoUnitInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__findGingkoUnitInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__findGingkoUnitInfo(struct soap *soap, ns1__findGingkoUnitInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__findGingkoUnitInfo);
	if (soap_out_PointerTons1__findGingkoUnitInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__findGingkoUnitInfo(struct soap *soap, const char *tag, int id, ns1__findGingkoUnitInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__findGingkoUnitInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__findGingkoUnitInfo ** SOAP_FMAC4 soap_get_PointerTons1__findGingkoUnitInfo(struct soap *soap, ns1__findGingkoUnitInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__findGingkoUnitInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__findGingkoUnitInfo ** SOAP_FMAC4 soap_in_PointerTons1__findGingkoUnitInfo(struct soap *soap, const char *tag, ns1__findGingkoUnitInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__findGingkoUnitInfo **)soap_malloc(soap, sizeof(ns1__findGingkoUnitInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__findGingkoUnitInfo *)soap_instantiate_ns1__findGingkoUnitInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__findGingkoUnitInfo ** p = (ns1__findGingkoUnitInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__findGingkoUnitInfo, sizeof(ns1__findGingkoUnitInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__registerThisUnitResponse(struct soap *soap, ns1__registerThisUnitResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__registerThisUnitResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__registerThisUnitResponse(struct soap *soap, ns1__registerThisUnitResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__registerThisUnitResponse);
	if (soap_out_PointerTons1__registerThisUnitResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__registerThisUnitResponse(struct soap *soap, const char *tag, int id, ns1__registerThisUnitResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__registerThisUnitResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__registerThisUnitResponse ** SOAP_FMAC4 soap_get_PointerTons1__registerThisUnitResponse(struct soap *soap, ns1__registerThisUnitResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__registerThisUnitResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__registerThisUnitResponse ** SOAP_FMAC4 soap_in_PointerTons1__registerThisUnitResponse(struct soap *soap, const char *tag, ns1__registerThisUnitResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__registerThisUnitResponse **)soap_malloc(soap, sizeof(ns1__registerThisUnitResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__registerThisUnitResponse *)soap_instantiate_ns1__registerThisUnitResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__registerThisUnitResponse ** p = (ns1__registerThisUnitResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__registerThisUnitResponse, sizeof(ns1__registerThisUnitResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__registerThisUnit(struct soap *soap, ns1__registerThisUnit *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__registerThisUnit))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__registerThisUnit(struct soap *soap, ns1__registerThisUnit *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__registerThisUnit);
	if (soap_out_PointerTons1__registerThisUnit(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__registerThisUnit(struct soap *soap, const char *tag, int id, ns1__registerThisUnit *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__registerThisUnit);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__registerThisUnit ** SOAP_FMAC4 soap_get_PointerTons1__registerThisUnit(struct soap *soap, ns1__registerThisUnit **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__registerThisUnit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__registerThisUnit ** SOAP_FMAC4 soap_in_PointerTons1__registerThisUnit(struct soap *soap, const char *tag, ns1__registerThisUnit **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__registerThisUnit **)soap_malloc(soap, sizeof(ns1__registerThisUnit *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__registerThisUnit *)soap_instantiate_ns1__registerThisUnit(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__registerThisUnit ** p = (ns1__registerThisUnit **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__registerThisUnit, sizeof(ns1__registerThisUnit), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__checkTokenResponse(struct soap *soap, ns1__checkTokenResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__checkTokenResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__checkTokenResponse(struct soap *soap, ns1__checkTokenResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__checkTokenResponse);
	if (soap_out_PointerTons1__checkTokenResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__checkTokenResponse(struct soap *soap, const char *tag, int id, ns1__checkTokenResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__checkTokenResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__checkTokenResponse ** SOAP_FMAC4 soap_get_PointerTons1__checkTokenResponse(struct soap *soap, ns1__checkTokenResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__checkTokenResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__checkTokenResponse ** SOAP_FMAC4 soap_in_PointerTons1__checkTokenResponse(struct soap *soap, const char *tag, ns1__checkTokenResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__checkTokenResponse **)soap_malloc(soap, sizeof(ns1__checkTokenResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__checkTokenResponse *)soap_instantiate_ns1__checkTokenResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__checkTokenResponse ** p = (ns1__checkTokenResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__checkTokenResponse, sizeof(ns1__checkTokenResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__checkToken(struct soap *soap, ns1__checkToken *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__checkToken))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__checkToken(struct soap *soap, ns1__checkToken *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__checkToken);
	if (soap_out_PointerTons1__checkToken(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__checkToken(struct soap *soap, const char *tag, int id, ns1__checkToken *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__checkToken);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__checkToken ** SOAP_FMAC4 soap_get_PointerTons1__checkToken(struct soap *soap, ns1__checkToken **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__checkToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__checkToken ** SOAP_FMAC4 soap_in_PointerTons1__checkToken(struct soap *soap, const char *tag, ns1__checkToken **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__checkToken **)soap_malloc(soap, sizeof(ns1__checkToken *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__checkToken *)soap_instantiate_ns1__checkToken(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__checkToken ** p = (ns1__checkToken **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__checkToken, sizeof(ns1__checkToken), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__newGingkoIdResponse(struct soap *soap, ns1__newGingkoIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__newGingkoIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__newGingkoIdResponse(struct soap *soap, ns1__newGingkoIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__newGingkoIdResponse);
	if (soap_out_PointerTons1__newGingkoIdResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__newGingkoIdResponse(struct soap *soap, const char *tag, int id, ns1__newGingkoIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__newGingkoIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__newGingkoIdResponse ** SOAP_FMAC4 soap_get_PointerTons1__newGingkoIdResponse(struct soap *soap, ns1__newGingkoIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__newGingkoIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__newGingkoIdResponse ** SOAP_FMAC4 soap_in_PointerTons1__newGingkoIdResponse(struct soap *soap, const char *tag, ns1__newGingkoIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__newGingkoIdResponse **)soap_malloc(soap, sizeof(ns1__newGingkoIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__newGingkoIdResponse *)soap_instantiate_ns1__newGingkoIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__newGingkoIdResponse ** p = (ns1__newGingkoIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__newGingkoIdResponse, sizeof(ns1__newGingkoIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__newGingkoId(struct soap *soap, ns1__newGingkoId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__newGingkoId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__newGingkoId(struct soap *soap, ns1__newGingkoId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__newGingkoId);
	if (soap_out_PointerTons1__newGingkoId(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__newGingkoId(struct soap *soap, const char *tag, int id, ns1__newGingkoId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__newGingkoId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__newGingkoId ** SOAP_FMAC4 soap_get_PointerTons1__newGingkoId(struct soap *soap, ns1__newGingkoId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__newGingkoId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__newGingkoId ** SOAP_FMAC4 soap_in_PointerTons1__newGingkoId(struct soap *soap, const char *tag, ns1__newGingkoId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__newGingkoId **)soap_malloc(soap, sizeof(ns1__newGingkoId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__newGingkoId *)soap_instantiate_ns1__newGingkoId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__newGingkoId ** p = (ns1__newGingkoId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__newGingkoId, sizeof(ns1__newGingkoId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__gingkoVersionResponse(struct soap *soap, ns1__gingkoVersionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__gingkoVersionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__gingkoVersionResponse(struct soap *soap, ns1__gingkoVersionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__gingkoVersionResponse);
	if (soap_out_PointerTons1__gingkoVersionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__gingkoVersionResponse(struct soap *soap, const char *tag, int id, ns1__gingkoVersionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__gingkoVersionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__gingkoVersionResponse ** SOAP_FMAC4 soap_get_PointerTons1__gingkoVersionResponse(struct soap *soap, ns1__gingkoVersionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__gingkoVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__gingkoVersionResponse ** SOAP_FMAC4 soap_in_PointerTons1__gingkoVersionResponse(struct soap *soap, const char *tag, ns1__gingkoVersionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__gingkoVersionResponse **)soap_malloc(soap, sizeof(ns1__gingkoVersionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__gingkoVersionResponse *)soap_instantiate_ns1__gingkoVersionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__gingkoVersionResponse ** p = (ns1__gingkoVersionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__gingkoVersionResponse, sizeof(ns1__gingkoVersionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__gingkoVersion(struct soap *soap, ns1__gingkoVersion *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__gingkoVersion))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__gingkoVersion(struct soap *soap, ns1__gingkoVersion *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__gingkoVersion);
	if (soap_out_PointerTons1__gingkoVersion(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__gingkoVersion(struct soap *soap, const char *tag, int id, ns1__gingkoVersion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__gingkoVersion);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__gingkoVersion ** SOAP_FMAC4 soap_get_PointerTons1__gingkoVersion(struct soap *soap, ns1__gingkoVersion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__gingkoVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__gingkoVersion ** SOAP_FMAC4 soap_in_PointerTons1__gingkoVersion(struct soap *soap, const char *tag, ns1__gingkoVersion **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__gingkoVersion **)soap_malloc(soap, sizeof(ns1__gingkoVersion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__gingkoVersion *)soap_instantiate_ns1__gingkoVersion(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__gingkoVersion ** p = (ns1__gingkoVersion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__gingkoVersion, sizeof(ns1__gingkoVersion), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__userLoginResponse(struct soap *soap, ns1__userLoginResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__userLoginResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__userLoginResponse(struct soap *soap, ns1__userLoginResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__userLoginResponse);
	if (soap_out_PointerTons1__userLoginResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__userLoginResponse(struct soap *soap, const char *tag, int id, ns1__userLoginResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__userLoginResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__userLoginResponse ** SOAP_FMAC4 soap_get_PointerTons1__userLoginResponse(struct soap *soap, ns1__userLoginResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__userLoginResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__userLoginResponse ** SOAP_FMAC4 soap_in_PointerTons1__userLoginResponse(struct soap *soap, const char *tag, ns1__userLoginResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__userLoginResponse **)soap_malloc(soap, sizeof(ns1__userLoginResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__userLoginResponse *)soap_instantiate_ns1__userLoginResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__userLoginResponse ** p = (ns1__userLoginResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__userLoginResponse, sizeof(ns1__userLoginResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__userLogin(struct soap *soap, ns1__userLogin *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__userLogin))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__userLogin(struct soap *soap, ns1__userLogin *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__userLogin);
	if (soap_out_PointerTons1__userLogin(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__userLogin(struct soap *soap, const char *tag, int id, ns1__userLogin *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__userLogin);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__userLogin ** SOAP_FMAC4 soap_get_PointerTons1__userLogin(struct soap *soap, ns1__userLogin **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__userLogin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__userLogin ** SOAP_FMAC4 soap_in_PointerTons1__userLogin(struct soap *soap, const char *tag, ns1__userLogin **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__userLogin **)soap_malloc(soap, sizeof(ns1__userLogin *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__userLogin *)soap_instantiate_ns1__userLogin(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__userLogin ** p = (ns1__userLogin **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__userLogin, sizeof(ns1__userLogin), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__registerUserResponse(struct soap *soap, ns1__registerUserResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__registerUserResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__registerUserResponse(struct soap *soap, ns1__registerUserResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__registerUserResponse);
	if (soap_out_PointerTons1__registerUserResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__registerUserResponse(struct soap *soap, const char *tag, int id, ns1__registerUserResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__registerUserResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__registerUserResponse ** SOAP_FMAC4 soap_get_PointerTons1__registerUserResponse(struct soap *soap, ns1__registerUserResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__registerUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__registerUserResponse ** SOAP_FMAC4 soap_in_PointerTons1__registerUserResponse(struct soap *soap, const char *tag, ns1__registerUserResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__registerUserResponse **)soap_malloc(soap, sizeof(ns1__registerUserResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__registerUserResponse *)soap_instantiate_ns1__registerUserResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__registerUserResponse ** p = (ns1__registerUserResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__registerUserResponse, sizeof(ns1__registerUserResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__registerUser(struct soap *soap, ns1__registerUser *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__registerUser))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__registerUser(struct soap *soap, ns1__registerUser *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__registerUser);
	if (soap_out_PointerTons1__registerUser(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__registerUser(struct soap *soap, const char *tag, int id, ns1__registerUser *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__registerUser);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__registerUser ** SOAP_FMAC4 soap_get_PointerTons1__registerUser(struct soap *soap, ns1__registerUser **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__registerUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__registerUser ** SOAP_FMAC4 soap_in_PointerTons1__registerUser(struct soap *soap, const char *tag, ns1__registerUser **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__registerUser **)soap_malloc(soap, sizeof(ns1__registerUser *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__registerUser *)soap_instantiate_ns1__registerUser(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__registerUser ** p = (ns1__registerUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__registerUser, sizeof(ns1__registerUser), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__gingkoUserListPack(struct soap *soap, ns1__gingkoUserListPack *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__gingkoUserListPack))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__gingkoUserListPack(struct soap *soap, ns1__gingkoUserListPack *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__gingkoUserListPack);
	if (soap_out_PointerTons1__gingkoUserListPack(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__gingkoUserListPack(struct soap *soap, const char *tag, int id, ns1__gingkoUserListPack *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__gingkoUserListPack);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__gingkoUserListPack ** SOAP_FMAC4 soap_get_PointerTons1__gingkoUserListPack(struct soap *soap, ns1__gingkoUserListPack **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__gingkoUserListPack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__gingkoUserListPack ** SOAP_FMAC4 soap_in_PointerTons1__gingkoUserListPack(struct soap *soap, const char *tag, ns1__gingkoUserListPack **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__gingkoUserListPack **)soap_malloc(soap, sizeof(ns1__gingkoUserListPack *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__gingkoUserListPack *)soap_instantiate_ns1__gingkoUserListPack(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__gingkoUserListPack ** p = (ns1__gingkoUserListPack **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__gingkoUserListPack, sizeof(ns1__gingkoUserListPack), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__companyUnit(struct soap *soap, ns1__companyUnit *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__companyUnit))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__companyUnit(struct soap *soap, ns1__companyUnit *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__companyUnit);
	if (soap_out_PointerTons1__companyUnit(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__companyUnit(struct soap *soap, const char *tag, int id, ns1__companyUnit *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__companyUnit);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__companyUnit ** SOAP_FMAC4 soap_get_PointerTons1__companyUnit(struct soap *soap, ns1__companyUnit **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__companyUnit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__companyUnit ** SOAP_FMAC4 soap_in_PointerTons1__companyUnit(struct soap *soap, const char *tag, ns1__companyUnit **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__companyUnit **)soap_malloc(soap, sizeof(ns1__companyUnit *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__companyUnit *)soap_instantiate_ns1__companyUnit(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__companyUnit ** p = (ns1__companyUnit **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__companyUnit, sizeof(ns1__companyUnit), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__gingkoUnitPack(struct soap *soap, ns1__gingkoUnitPack *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__gingkoUnitPack))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__gingkoUnitPack(struct soap *soap, ns1__gingkoUnitPack *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__gingkoUnitPack);
	if (soap_out_PointerTons1__gingkoUnitPack(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__gingkoUnitPack(struct soap *soap, const char *tag, int id, ns1__gingkoUnitPack *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__gingkoUnitPack);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__gingkoUnitPack ** SOAP_FMAC4 soap_get_PointerTons1__gingkoUnitPack(struct soap *soap, ns1__gingkoUnitPack **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__gingkoUnitPack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__gingkoUnitPack ** SOAP_FMAC4 soap_in_PointerTons1__gingkoUnitPack(struct soap *soap, const char *tag, ns1__gingkoUnitPack **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__gingkoUnitPack **)soap_malloc(soap, sizeof(ns1__gingkoUnitPack *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__gingkoUnitPack *)soap_instantiate_ns1__gingkoUnitPack(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__gingkoUnitPack ** p = (ns1__gingkoUnitPack **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__gingkoUnitPack, sizeof(ns1__gingkoUnitPack), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__gingkoPermissionListPack(struct soap *soap, ns1__gingkoPermissionListPack *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__gingkoPermissionListPack))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__gingkoPermissionListPack(struct soap *soap, ns1__gingkoPermissionListPack *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__gingkoPermissionListPack);
	if (soap_out_PointerTons1__gingkoPermissionListPack(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__gingkoPermissionListPack(struct soap *soap, const char *tag, int id, ns1__gingkoPermissionListPack *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__gingkoPermissionListPack);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__gingkoPermissionListPack ** SOAP_FMAC4 soap_get_PointerTons1__gingkoPermissionListPack(struct soap *soap, ns1__gingkoPermissionListPack **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__gingkoPermissionListPack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__gingkoPermissionListPack ** SOAP_FMAC4 soap_in_PointerTons1__gingkoPermissionListPack(struct soap *soap, const char *tag, ns1__gingkoPermissionListPack **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__gingkoPermissionListPack **)soap_malloc(soap, sizeof(ns1__gingkoPermissionListPack *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__gingkoPermissionListPack *)soap_instantiate_ns1__gingkoPermissionListPack(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__gingkoPermissionListPack ** p = (ns1__gingkoPermissionListPack **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__gingkoPermissionListPack, sizeof(ns1__gingkoPermissionListPack), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__digitalContent(struct soap *soap, ns1__digitalContent *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__digitalContent))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__digitalContent(struct soap *soap, ns1__digitalContent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__digitalContent);
	if (soap_out_PointerTons1__digitalContent(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__digitalContent(struct soap *soap, const char *tag, int id, ns1__digitalContent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__digitalContent);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__digitalContent ** SOAP_FMAC4 soap_get_PointerTons1__digitalContent(struct soap *soap, ns1__digitalContent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__digitalContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__digitalContent ** SOAP_FMAC4 soap_in_PointerTons1__digitalContent(struct soap *soap, const char *tag, ns1__digitalContent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__digitalContent **)soap_malloc(soap, sizeof(ns1__digitalContent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__digitalContent *)soap_instantiate_ns1__digitalContent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__digitalContent ** p = (ns1__digitalContent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__digitalContent, sizeof(ns1__digitalContent), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__gingkoDigitalPack(struct soap *soap, ns1__gingkoDigitalPack *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__gingkoDigitalPack))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__gingkoDigitalPack(struct soap *soap, ns1__gingkoDigitalPack *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__gingkoDigitalPack);
	if (soap_out_PointerTons1__gingkoDigitalPack(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__gingkoDigitalPack(struct soap *soap, const char *tag, int id, ns1__gingkoDigitalPack *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__gingkoDigitalPack);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__gingkoDigitalPack ** SOAP_FMAC4 soap_get_PointerTons1__gingkoDigitalPack(struct soap *soap, ns1__gingkoDigitalPack **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__gingkoDigitalPack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__gingkoDigitalPack ** SOAP_FMAC4 soap_in_PointerTons1__gingkoDigitalPack(struct soap *soap, const char *tag, ns1__gingkoDigitalPack **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__gingkoDigitalPack **)soap_malloc(soap, sizeof(ns1__gingkoDigitalPack *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__gingkoDigitalPack *)soap_instantiate_ns1__gingkoDigitalPack(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__gingkoDigitalPack ** p = (ns1__gingkoDigitalPack **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__gingkoDigitalPack, sizeof(ns1__gingkoDigitalPack), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__gingkoPermission(struct soap *soap, ns1__gingkoPermission *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__gingkoPermission))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__gingkoPermission(struct soap *soap, ns1__gingkoPermission *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__gingkoPermission);
	if (soap_out_PointerTons1__gingkoPermission(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__gingkoPermission(struct soap *soap, const char *tag, int id, ns1__gingkoPermission *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__gingkoPermission);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__gingkoPermission ** SOAP_FMAC4 soap_get_PointerTons1__gingkoPermission(struct soap *soap, ns1__gingkoPermission **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__gingkoPermission(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__gingkoPermission ** SOAP_FMAC4 soap_in_PointerTons1__gingkoPermission(struct soap *soap, const char *tag, ns1__gingkoPermission **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__gingkoPermission **)soap_malloc(soap, sizeof(ns1__gingkoPermission *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__gingkoPermission *)soap_instantiate_ns1__gingkoPermission(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__gingkoPermission ** p = (ns1__gingkoPermission **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__gingkoPermission, sizeof(ns1__gingkoPermission), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__gingkoPermissionPack(struct soap *soap, ns1__gingkoPermissionPack *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__gingkoPermissionPack))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__gingkoPermissionPack(struct soap *soap, ns1__gingkoPermissionPack *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__gingkoPermissionPack);
	if (soap_out_PointerTons1__gingkoPermissionPack(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__gingkoPermissionPack(struct soap *soap, const char *tag, int id, ns1__gingkoPermissionPack *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__gingkoPermissionPack);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__gingkoPermissionPack ** SOAP_FMAC4 soap_get_PointerTons1__gingkoPermissionPack(struct soap *soap, ns1__gingkoPermissionPack **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__gingkoPermissionPack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__gingkoPermissionPack ** SOAP_FMAC4 soap_in_PointerTons1__gingkoPermissionPack(struct soap *soap, const char *tag, ns1__gingkoPermissionPack **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__gingkoPermissionPack **)soap_malloc(soap, sizeof(ns1__gingkoPermissionPack *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__gingkoPermissionPack *)soap_instantiate_ns1__gingkoPermissionPack(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__gingkoPermissionPack ** p = (ns1__gingkoPermissionPack **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__gingkoPermissionPack, sizeof(ns1__gingkoPermissionPack), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__stringPack(struct soap *soap, ns1__stringPack *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__stringPack))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__stringPack(struct soap *soap, ns1__stringPack *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__stringPack);
	if (soap_out_PointerTons1__stringPack(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__stringPack(struct soap *soap, const char *tag, int id, ns1__stringPack *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__stringPack);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__stringPack ** SOAP_FMAC4 soap_get_PointerTons1__stringPack(struct soap *soap, ns1__stringPack **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__stringPack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__stringPack ** SOAP_FMAC4 soap_in_PointerTons1__stringPack(struct soap *soap, const char *tag, ns1__stringPack **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__stringPack **)soap_malloc(soap, sizeof(ns1__stringPack *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__stringPack *)soap_instantiate_ns1__stringPack(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__stringPack ** p = (ns1__stringPack **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__stringPack, sizeof(ns1__stringPack), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__gingkoVersionPack(struct soap *soap, ns1__gingkoVersionPack *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__gingkoVersionPack))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__gingkoVersionPack(struct soap *soap, ns1__gingkoVersionPack *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__gingkoVersionPack);
	if (soap_out_PointerTons1__gingkoVersionPack(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__gingkoVersionPack(struct soap *soap, const char *tag, int id, ns1__gingkoVersionPack *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__gingkoVersionPack);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__gingkoVersionPack ** SOAP_FMAC4 soap_get_PointerTons1__gingkoVersionPack(struct soap *soap, ns1__gingkoVersionPack **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__gingkoVersionPack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__gingkoVersionPack ** SOAP_FMAC4 soap_in_PointerTons1__gingkoVersionPack(struct soap *soap, const char *tag, ns1__gingkoVersionPack **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__gingkoVersionPack **)soap_malloc(soap, sizeof(ns1__gingkoVersionPack *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__gingkoVersionPack *)soap_instantiate_ns1__gingkoVersionPack(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__gingkoVersionPack ** p = (ns1__gingkoVersionPack **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__gingkoVersionPack, sizeof(ns1__gingkoVersionPack), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotime(struct soap *soap, time_t *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_time);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotime);
	if (soap_out_PointerTotime(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_time);
	if (id < 0)
		return soap->error;
	return soap_out_time(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTotime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTotime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_time(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_time, sizeof(time_t), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__soapPackStatusEnum(struct soap *soap, enum ns1__soapPackStatusEnum *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__soapPackStatusEnum);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__soapPackStatusEnum(struct soap *soap, enum ns1__soapPackStatusEnum *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__soapPackStatusEnum);
	if (soap_out_PointerTons1__soapPackStatusEnum(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__soapPackStatusEnum(struct soap *soap, const char *tag, int id, enum ns1__soapPackStatusEnum *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__soapPackStatusEnum);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__soapPackStatusEnum(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__soapPackStatusEnum ** SOAP_FMAC4 soap_get_PointerTons1__soapPackStatusEnum(struct soap *soap, enum ns1__soapPackStatusEnum **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__soapPackStatusEnum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum ns1__soapPackStatusEnum ** SOAP_FMAC4 soap_in_PointerTons1__soapPackStatusEnum(struct soap *soap, const char *tag, enum ns1__soapPackStatusEnum **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__soapPackStatusEnum **)soap_malloc(soap, sizeof(enum ns1__soapPackStatusEnum *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__soapPackStatusEnum(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__soapPackStatusEnum **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__soapPackStatusEnum, sizeof(enum ns1__soapPackStatusEnum), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__gingkoUser(struct soap *soap, ns1__gingkoUser *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__gingkoUser))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__gingkoUser(struct soap *soap, ns1__gingkoUser *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__gingkoUser);
	if (soap_out_PointerTons1__gingkoUser(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__gingkoUser(struct soap *soap, const char *tag, int id, ns1__gingkoUser *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__gingkoUser);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__gingkoUser ** SOAP_FMAC4 soap_get_PointerTons1__gingkoUser(struct soap *soap, ns1__gingkoUser **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__gingkoUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__gingkoUser ** SOAP_FMAC4 soap_in_PointerTons1__gingkoUser(struct soap *soap, const char *tag, ns1__gingkoUser **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__gingkoUser **)soap_malloc(soap, sizeof(ns1__gingkoUser *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__gingkoUser *)soap_instantiate_ns1__gingkoUser(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__gingkoUser ** p = (ns1__gingkoUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__gingkoUser, sizeof(ns1__gingkoUser), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__gingkoUserPack(struct soap *soap, ns1__gingkoUserPack *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__gingkoUserPack))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__gingkoUserPack(struct soap *soap, ns1__gingkoUserPack *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__gingkoUserPack);
	if (soap_out_PointerTons1__gingkoUserPack(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__gingkoUserPack(struct soap *soap, const char *tag, int id, ns1__gingkoUserPack *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__gingkoUserPack);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__gingkoUserPack ** SOAP_FMAC4 soap_get_PointerTons1__gingkoUserPack(struct soap *soap, ns1__gingkoUserPack **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__gingkoUserPack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__gingkoUserPack ** SOAP_FMAC4 soap_in_PointerTons1__gingkoUserPack(struct soap *soap, const char *tag, ns1__gingkoUserPack **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__gingkoUserPack **)soap_malloc(soap, sizeof(ns1__gingkoUserPack *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__gingkoUserPack *)soap_instantiate_ns1__gingkoUserPack(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__gingkoUserPack ** p = (ns1__gingkoUserPack **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__gingkoUserPack, sizeof(ns1__gingkoUserPack), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__wstring(struct soap *soap, std::wstring *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__wstring))
		soap_serialize_std__wstring(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__wstring(struct soap *soap, std::wstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__wstring);
	if (soap_out_PointerTostd__wstring(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__wstring(struct soap *soap, const char *tag, int id, std::wstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__wstring);
	if (id < 0)
		return soap->error;
	return soap_out_std__wstring(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_get_PointerTostd__wstring(struct soap *soap, std::wstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__wstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_in_PointerTostd__wstring(struct soap *soap, const char *tag, std::wstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::wstring **)soap_malloc(soap, sizeof(std::wstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__wstring(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::wstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__wstring, sizeof(std::wstring), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__gingkoUser(struct soap *soap, std::vector<ns1__gingkoUser * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__gingkoUser(struct soap *soap, const std::vector<ns1__gingkoUser * >*a)
{
	for (std::vector<ns1__gingkoUser * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__gingkoUser(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__gingkoUser(struct soap *soap, const char *tag, int id, const std::vector<ns1__gingkoUser * >*a, const char *type)
{
	for (std::vector<ns1__gingkoUser * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__gingkoUser(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__gingkoUser * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__gingkoUser(struct soap *soap, const char *tag, std::vector<ns1__gingkoUser * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__gingkoUser(soap, -1)))
		return NULL;
	ns1__gingkoUser *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__gingkoUser, SOAP_TYPE_std__vectorTemplateOfPointerTons1__gingkoUser, sizeof(ns1__gingkoUser), 1))
				break;
			if (!soap_in_PointerTons1__gingkoUser(soap, tag, NULL, "ns1:gingkoUser"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__gingkoUser(soap, tag, &n, "ns1:gingkoUser"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC3 std::vector<ns1__gingkoUser * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons1__gingkoUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__gingkoUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__gingkoUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns1__gingkoUser * >;
		if (size)
			*size = sizeof(std::vector<ns1__gingkoUser * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns1__gingkoUser * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__gingkoUser * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__gingkoUser * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__gingkoUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__gingkoUser * > %p -> %p\n", q, p));
	*(std::vector<ns1__gingkoUser * >*)p = *(std::vector<ns1__gingkoUser * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__gingkoPermission(struct soap *soap, std::vector<ns1__gingkoPermission * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__gingkoPermission(struct soap *soap, const std::vector<ns1__gingkoPermission * >*a)
{
	for (std::vector<ns1__gingkoPermission * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__gingkoPermission(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__gingkoPermission(struct soap *soap, const char *tag, int id, const std::vector<ns1__gingkoPermission * >*a, const char *type)
{
	for (std::vector<ns1__gingkoPermission * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__gingkoPermission(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__gingkoPermission * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__gingkoPermission(struct soap *soap, const char *tag, std::vector<ns1__gingkoPermission * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__gingkoPermission(soap, -1)))
		return NULL;
	ns1__gingkoPermission *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__gingkoPermission, SOAP_TYPE_std__vectorTemplateOfPointerTons1__gingkoPermission, sizeof(ns1__gingkoPermission), 1))
				break;
			if (!soap_in_PointerTons1__gingkoPermission(soap, tag, NULL, "ns1:gingkoPermission"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__gingkoPermission(soap, tag, &n, "ns1:gingkoPermission"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC3 std::vector<ns1__gingkoPermission * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons1__gingkoPermission(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__gingkoPermission(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__gingkoPermission, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns1__gingkoPermission * >;
		if (size)
			*size = sizeof(std::vector<ns1__gingkoPermission * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns1__gingkoPermission * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__gingkoPermission * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__gingkoPermission * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__gingkoPermission(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__gingkoPermission * > %p -> %p\n", q, p));
	*(std::vector<ns1__gingkoPermission * >*)p = *(std::vector<ns1__gingkoPermission * >*)q;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
