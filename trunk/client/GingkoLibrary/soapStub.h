/* soapStub.h
   Generated by gSOAP 2.7.13 from GingkoWebService.h
   Copyright(C) 2000-2009, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#ifndef soapStub_H
#define soapStub_H
#include <vector>
#include "stdsoap2.h"

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


#ifndef SOAP_TYPE_ns1__soapPackStatusEnum
#define SOAP_TYPE_ns1__soapPackStatusEnum (60)
/* ns1:soapPackStatusEnum */
enum ns1__soapPackStatusEnum {ns1__soapPackStatusEnum__SUCCESS = 0, ns1__soapPackStatusEnum__NOTFOUND = 1, ns1__soapPackStatusEnum__DISABLED = 2, ns1__soapPackStatusEnum__EXISTING = 3, ns1__soapPackStatusEnum__NOTAVAILABLE = 4, ns1__soapPackStatusEnum__DELETED = 5, ns1__soapPackStatusEnum__ERROR = 6};
#endif
typedef enum ns1__soapPackStatusEnum ns1__soapPackStatusEnum;

/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not redeclare here */

#endif

#if 0 /* volatile type: do not redeclare here */

#endif

#ifndef SOAP_TYPE_ns1__registerUser
#define SOAP_TYPE_ns1__registerUser (8)
/* ns1:registerUser */
class SOAP_CMAC ns1__registerUser
{
public:
	std::wstring *loginId;	/* optional element of type xsd:string */
	std::wstring *name;	/* optional element of type xsd:string */
	std::wstring *password;	/* optional element of type xsd:string */
	std::wstring *bindingId;	/* optional element of type xsd:string */
	std::wstring *bindPassword;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 8; } /* = unique id SOAP_TYPE_ns1__registerUser */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__registerUser() : loginId(NULL), name(NULL), password(NULL), bindingId(NULL), bindPassword(NULL), soap(NULL) { }
	virtual ~ns1__registerUser() { }
};
#endif

#ifndef SOAP_TYPE_ns1__registerUserResponse
#define SOAP_TYPE_ns1__registerUserResponse (9)
/* ns1:registerUserResponse */
class SOAP_CMAC ns1__registerUserResponse
{
public:
	class ns1__gingkoUserPack *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:gingkoUserPack */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 9; } /* = unique id SOAP_TYPE_ns1__registerUserResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__registerUserResponse() : return_(NULL), soap(NULL) { }
	virtual ~ns1__registerUserResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__gingkoUserPack
#define SOAP_TYPE_ns1__gingkoUserPack (10)
/* ns1:gingkoUserPack */
class SOAP_CMAC ns1__gingkoUserPack
{
public:
	class ns1__gingkoUser *gingkoUser;	/* optional element of type ns1:gingkoUser */
	std::wstring *message;	/* optional element of type xsd:string */
	enum ns1__soapPackStatusEnum *status;	/* optional element of type ns1:soapPackStatusEnum */
	std::wstring *token;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 10; } /* = unique id SOAP_TYPE_ns1__gingkoUserPack */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__gingkoUserPack() : gingkoUser(NULL), message(NULL), status(NULL), token(NULL), soap(NULL) { }
	virtual ~ns1__gingkoUserPack() { }
};
#endif

#ifndef SOAP_TYPE_ns1__gingkoUser
#define SOAP_TYPE_ns1__gingkoUser (11)
/* ns1:gingkoUser */
class SOAP_CMAC ns1__gingkoUser
{
public:
	std::wstring *bindingId;	/* optional element of type xsd:string */
	std::wstring *gingkoId;	/* optional element of type xsd:string */
	std::wstring *loginId;	/* optional element of type xsd:string */
	std::wstring *name;	/* optional element of type xsd:string */
	std::wstring *password;	/* optional element of type xsd:string */
	std::wstring *status;	/* optional element of type xsd:string */
	std::wstring *updatedBy;	/* optional element of type xsd:string */
	time_t *updatedTime;	/* optional element of type xsd:dateTime */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 11; } /* = unique id SOAP_TYPE_ns1__gingkoUser */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__gingkoUser() : bindingId(NULL), gingkoId(NULL), loginId(NULL), name(NULL), password(NULL), status(NULL), updatedBy(NULL), updatedTime(NULL), soap(NULL) { }
	virtual ~ns1__gingkoUser() { }
};
#endif

#ifndef SOAP_TYPE_ns1__userLogin
#define SOAP_TYPE_ns1__userLogin (12)
/* ns1:userLogin */
class SOAP_CMAC ns1__userLogin
{
public:
	std::wstring *loginId;	/* optional element of type xsd:string */
	std::wstring *password;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 12; } /* = unique id SOAP_TYPE_ns1__userLogin */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__userLogin() : loginId(NULL), password(NULL), soap(NULL) { }
	virtual ~ns1__userLogin() { }
};
#endif

#ifndef SOAP_TYPE_ns1__userLoginResponse
#define SOAP_TYPE_ns1__userLoginResponse (13)
/* ns1:userLoginResponse */
class SOAP_CMAC ns1__userLoginResponse
{
public:
	ns1__gingkoUserPack *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:gingkoUserPack */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 13; } /* = unique id SOAP_TYPE_ns1__userLoginResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__userLoginResponse() : return_(NULL), soap(NULL) { }
	virtual ~ns1__userLoginResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__gingkoVersion
#define SOAP_TYPE_ns1__gingkoVersion (14)
/* ns1:gingkoVersion */
class SOAP_CMAC ns1__gingkoVersion
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 14; } /* = unique id SOAP_TYPE_ns1__gingkoVersion */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__gingkoVersion() : soap(NULL) { }
	virtual ~ns1__gingkoVersion() { }
};
#endif

#ifndef SOAP_TYPE_ns1__gingkoVersionResponse
#define SOAP_TYPE_ns1__gingkoVersionResponse (15)
/* ns1:gingkoVersionResponse */
class SOAP_CMAC ns1__gingkoVersionResponse
{
public:
	class ns1__gingkoVersionPack *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:gingkoVersionPack */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 15; } /* = unique id SOAP_TYPE_ns1__gingkoVersionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__gingkoVersionResponse() : return_(NULL), soap(NULL) { }
	virtual ~ns1__gingkoVersionResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__gingkoVersionPack
#define SOAP_TYPE_ns1__gingkoVersionPack (16)
/* ns1:gingkoVersionPack */
class SOAP_CMAC ns1__gingkoVersionPack
{
public:
	std::wstring *version;	/* optional element of type xsd:string */
	int major;	/* required element of type xsd:int */
	int middle;	/* required element of type xsd:int */
	int minor;	/* required element of type xsd:int */
	std::wstring *servicePack;	/* optional element of type xsd:string */
	std::wstring *message;	/* optional element of type xsd:string */
	enum ns1__soapPackStatusEnum *status;	/* optional element of type ns1:soapPackStatusEnum */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 16; } /* = unique id SOAP_TYPE_ns1__gingkoVersionPack */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__gingkoVersionPack() : version(NULL), major(0), middle(0), minor(0), servicePack(NULL), message(NULL), status(NULL), soap(NULL) { }
	virtual ~ns1__gingkoVersionPack() { }
};
#endif

#ifndef SOAP_TYPE_ns1__newGingkoId
#define SOAP_TYPE_ns1__newGingkoId (17)
/* ns1:newGingkoId */
class SOAP_CMAC ns1__newGingkoId
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 17; } /* = unique id SOAP_TYPE_ns1__newGingkoId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__newGingkoId() : soap(NULL) { }
	virtual ~ns1__newGingkoId() { }
};
#endif

#ifndef SOAP_TYPE_ns1__newGingkoIdResponse
#define SOAP_TYPE_ns1__newGingkoIdResponse (18)
/* ns1:newGingkoIdResponse */
class SOAP_CMAC ns1__newGingkoIdResponse
{
public:
	class ns1__stringPack *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:stringPack */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 18; } /* = unique id SOAP_TYPE_ns1__newGingkoIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__newGingkoIdResponse() : return_(NULL), soap(NULL) { }
	virtual ~ns1__newGingkoIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__stringPack
#define SOAP_TYPE_ns1__stringPack (19)
/* ns1:stringPack */
class SOAP_CMAC ns1__stringPack
{
public:
	std::wstring *result;	/* optional element of type xsd:string */
	std::wstring *message;	/* optional element of type xsd:string */
	enum ns1__soapPackStatusEnum *status;	/* optional element of type ns1:soapPackStatusEnum */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 19; } /* = unique id SOAP_TYPE_ns1__stringPack */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__stringPack() : result(NULL), message(NULL), status(NULL), soap(NULL) { }
	virtual ~ns1__stringPack() { }
};
#endif

#ifndef SOAP_TYPE_ns1__checkToken
#define SOAP_TYPE_ns1__checkToken (20)
/* ns1:checkToken */
class SOAP_CMAC ns1__checkToken
{
public:
	std::wstring *token;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 20; } /* = unique id SOAP_TYPE_ns1__checkToken */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__checkToken() : token(NULL), soap(NULL) { }
	virtual ~ns1__checkToken() { }
};
#endif

#ifndef SOAP_TYPE_ns1__checkTokenResponse
#define SOAP_TYPE_ns1__checkTokenResponse (21)
/* ns1:checkTokenResponse */
class SOAP_CMAC ns1__checkTokenResponse
{
public:
	ns1__gingkoUserPack *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:gingkoUserPack */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 21; } /* = unique id SOAP_TYPE_ns1__checkTokenResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__checkTokenResponse() : return_(NULL), soap(NULL) { }
	virtual ~ns1__checkTokenResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__assignPermission
#define SOAP_TYPE_ns1__assignPermission (22)
/* ns1:assignPermission */
class SOAP_CMAC ns1__assignPermission
{
public:
	std::wstring *unitId;	/* optional element of type xsd:string */
	std::wstring *digitalId;	/* optional element of type xsd:string */
	std::wstring *loginId;	/* optional element of type xsd:string */
	std::wstring *gingkoId;	/* optional element of type xsd:string */
	bool isOwner;	/* required element of type xsd:boolean */
	bool isHolder;	/* required element of type xsd:boolean */
	bool readable;	/* required element of type xsd:boolean */
	bool writable;	/* required element of type xsd:boolean */
	bool printable;	/* required element of type xsd:boolean */
	bool deletable;	/* required element of type xsd:boolean */
	bool actived;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 22; } /* = unique id SOAP_TYPE_ns1__assignPermission */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__assignPermission() : unitId(NULL), digitalId(NULL), loginId(NULL), gingkoId(NULL), isOwner((bool)0), isHolder((bool)0), readable((bool)0), writable((bool)0), printable((bool)0), deletable((bool)0), actived((bool)0), soap(NULL) { }
	virtual ~ns1__assignPermission() { }
};
#endif

#ifndef SOAP_TYPE_ns1__assignPermissionResponse
#define SOAP_TYPE_ns1__assignPermissionResponse (23)
/* ns1:assignPermissionResponse */
class SOAP_CMAC ns1__assignPermissionResponse
{
public:
	class ns1__gingkoPermissionPack *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:gingkoPermissionPack */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 23; } /* = unique id SOAP_TYPE_ns1__assignPermissionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__assignPermissionResponse() : return_(NULL), soap(NULL) { }
	virtual ~ns1__assignPermissionResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__gingkoPermissionPack
#define SOAP_TYPE_ns1__gingkoPermissionPack (24)
/* ns1:gingkoPermissionPack */
class SOAP_CMAC ns1__gingkoPermissionPack
{
public:
	class ns1__gingkoPermission *permission;	/* optional element of type ns1:gingkoPermission */
	std::wstring *message;	/* optional element of type xsd:string */
	enum ns1__soapPackStatusEnum *status;	/* optional element of type ns1:soapPackStatusEnum */
	bool deleted;	/* required element of type xsd:boolean */
	std::wstring *privateKey;	/* optional element of type xsd:string */
	std::wstring *publicKey;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 24; } /* = unique id SOAP_TYPE_ns1__gingkoPermissionPack */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__gingkoPermissionPack() : permission(NULL), message(NULL), status(NULL), deleted((bool)0), privateKey(NULL), publicKey(NULL), soap(NULL) { }
	virtual ~ns1__gingkoPermissionPack() { }
};
#endif

#ifndef SOAP_TYPE_ns1__gingkoPermission
#define SOAP_TYPE_ns1__gingkoPermission (25)
/* ns1:gingkoPermission */
class SOAP_CMAC ns1__gingkoPermission
{
public:
	std::wstring *digitalId;	/* optional element of type xsd:string */
	std::wstring *gingkoId;	/* optional element of type xsd:string */
	std::wstring *loginId;	/* optional element of type xsd:string */
	std::wstring *userName;	/* optional element of type xsd:string */
	bool activated;	/* required element of type xsd:boolean */
	bool holder;	/* required element of type xsd:boolean */
	bool owner;	/* required element of type xsd:boolean */
	bool readable;	/* required element of type xsd:boolean */
	bool writable;	/* required element of type xsd:boolean */
	bool printable;	/* required element of type xsd:boolean */
	bool deletable;	/* required element of type xsd:boolean */
	std::wstring *assignedBy;	/* optional element of type xsd:string */
	std::wstring *assignedByName;	/* optional element of type xsd:string */
	time_t *updatedTime;	/* optional element of type xsd:dateTime */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 25; } /* = unique id SOAP_TYPE_ns1__gingkoPermission */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__gingkoPermission() : digitalId(NULL), gingkoId(NULL), loginId(NULL), userName(NULL), activated((bool)0), holder((bool)0), owner((bool)0), readable((bool)0), writable((bool)0), printable((bool)0), deletable((bool)0), assignedBy(NULL), assignedByName(NULL), updatedTime(NULL), soap(NULL) { }
	virtual ~ns1__gingkoPermission() { }
};
#endif

#ifndef SOAP_TYPE_ns1__requestPermission
#define SOAP_TYPE_ns1__requestPermission (26)
/* ns1:requestPermission */
class SOAP_CMAC ns1__requestPermission
{
public:
	std::wstring *unitId;	/* optional element of type xsd:string */
	std::wstring *digitalId;	/* optional element of type xsd:string */
	std::wstring *gingkoId;	/* optional element of type xsd:string */
	bool isOwner;	/* required element of type xsd:boolean */
	bool isHolder;	/* required element of type xsd:boolean */
	bool readable;	/* required element of type xsd:boolean */
	bool writable;	/* required element of type xsd:boolean */
	bool printable;	/* required element of type xsd:boolean */
	bool deletable;	/* required element of type xsd:boolean */
	std::wstring *message;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 26; } /* = unique id SOAP_TYPE_ns1__requestPermission */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__requestPermission() : unitId(NULL), digitalId(NULL), gingkoId(NULL), isOwner((bool)0), isHolder((bool)0), readable((bool)0), writable((bool)0), printable((bool)0), deletable((bool)0), message(NULL), soap(NULL) { }
	virtual ~ns1__requestPermission() { }
};
#endif

#ifndef SOAP_TYPE_ns1__requestPermissionResponse
#define SOAP_TYPE_ns1__requestPermissionResponse (27)
/* ns1:requestPermissionResponse */
class SOAP_CMAC ns1__requestPermissionResponse
{
public:
	ns1__gingkoPermissionPack *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:gingkoPermissionPack */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 27; } /* = unique id SOAP_TYPE_ns1__requestPermissionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__requestPermissionResponse() : return_(NULL), soap(NULL) { }
	virtual ~ns1__requestPermissionResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__bindingGingkoUser
#define SOAP_TYPE_ns1__bindingGingkoUser (28)
/* ns1:bindingGingkoUser */
class SOAP_CMAC ns1__bindingGingkoUser
{
public:
	std::wstring *loginId;	/* optional element of type xsd:string */
	std::wstring *thePassword;	/* optional element of type xsd:string */
	std::wstring *theDisplayName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 28; } /* = unique id SOAP_TYPE_ns1__bindingGingkoUser */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__bindingGingkoUser() : loginId(NULL), thePassword(NULL), theDisplayName(NULL), soap(NULL) { }
	virtual ~ns1__bindingGingkoUser() { }
};
#endif

#ifndef SOAP_TYPE_ns1__changePassword
#define SOAP_TYPE_ns1__changePassword (29)
/* ns1:changePassword */
class SOAP_CMAC ns1__changePassword
{
public:
	std::wstring *loginId;	/* optional element of type xsd:string */
	std::wstring *oldPassword;	/* optional element of type xsd:string */
	std::wstring *newPassword;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 29; } /* = unique id SOAP_TYPE_ns1__changePassword */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__changePassword() : loginId(NULL), oldPassword(NULL), newPassword(NULL), soap(NULL) { }
	virtual ~ns1__changePassword() { }
};
#endif

#ifndef SOAP_TYPE_ns1__changePasswordResponse
#define SOAP_TYPE_ns1__changePasswordResponse (30)
/* ns1:changePasswordResponse */
class SOAP_CMAC ns1__changePasswordResponse
{
public:
	ns1__gingkoUserPack *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:gingkoUserPack */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 30; } /* = unique id SOAP_TYPE_ns1__changePasswordResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__changePasswordResponse() : return_(NULL), soap(NULL) { }
	virtual ~ns1__changePasswordResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__findUserByGingkoId
#define SOAP_TYPE_ns1__findUserByGingkoId (31)
/* ns1:findUserByGingkoId */
class SOAP_CMAC ns1__findUserByGingkoId
{
public:
	std::wstring *gingkoId;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 31; } /* = unique id SOAP_TYPE_ns1__findUserByGingkoId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__findUserByGingkoId() : gingkoId(NULL), soap(NULL) { }
	virtual ~ns1__findUserByGingkoId() { }
};
#endif

#ifndef SOAP_TYPE_ns1__findUserByGingkoIdResponse
#define SOAP_TYPE_ns1__findUserByGingkoIdResponse (32)
/* ns1:findUserByGingkoIdResponse */
class SOAP_CMAC ns1__findUserByGingkoIdResponse
{
public:
	ns1__gingkoUserPack *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:gingkoUserPack */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 32; } /* = unique id SOAP_TYPE_ns1__findUserByGingkoIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__findUserByGingkoIdResponse() : return_(NULL), soap(NULL) { }
	virtual ~ns1__findUserByGingkoIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__findUserByLoginId
#define SOAP_TYPE_ns1__findUserByLoginId (33)
/* ns1:findUserByLoginId */
class SOAP_CMAC ns1__findUserByLoginId
{
public:
	std::wstring *loginId;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 33; } /* = unique id SOAP_TYPE_ns1__findUserByLoginId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__findUserByLoginId() : loginId(NULL), soap(NULL) { }
	virtual ~ns1__findUserByLoginId() { }
};
#endif

#ifndef SOAP_TYPE_ns1__findUserByLoginIdResponse
#define SOAP_TYPE_ns1__findUserByLoginIdResponse (34)
/* ns1:findUserByLoginIdResponse */
class SOAP_CMAC ns1__findUserByLoginIdResponse
{
public:
	ns1__gingkoUserPack *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:gingkoUserPack */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 34; } /* = unique id SOAP_TYPE_ns1__findUserByLoginIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__findUserByLoginIdResponse() : return_(NULL), soap(NULL) { }
	virtual ~ns1__findUserByLoginIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__bindingGingkoUserResponse
#define SOAP_TYPE_ns1__bindingGingkoUserResponse (35)
/* ns1:bindingGingkoUserResponse */
class SOAP_CMAC ns1__bindingGingkoUserResponse
{
public:
	ns1__gingkoUserPack *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:gingkoUserPack */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 35; } /* = unique id SOAP_TYPE_ns1__bindingGingkoUserResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__bindingGingkoUserResponse() : return_(NULL), soap(NULL) { }
	virtual ~ns1__bindingGingkoUserResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__findDigitalInfo
#define SOAP_TYPE_ns1__findDigitalInfo (36)
/* ns1:findDigitalInfo */
class SOAP_CMAC ns1__findDigitalInfo
{
public:
	std::wstring *unitId;	/* optional element of type xsd:string */
	std::wstring *digitalId;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 36; } /* = unique id SOAP_TYPE_ns1__findDigitalInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__findDigitalInfo() : unitId(NULL), digitalId(NULL), soap(NULL) { }
	virtual ~ns1__findDigitalInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns1__updateDigitalInfo
#define SOAP_TYPE_ns1__updateDigitalInfo (37)
/* ns1:updateDigitalInfo */
class SOAP_CMAC ns1__updateDigitalInfo
{
public:
	std::wstring *digitalId;	/* optional element of type xsd:string */
	std::wstring *author;	/* optional element of type xsd:string */
	std::wstring *description;	/* optional element of type xsd:string */
	std::wstring *title;	/* optional element of type xsd:string */
	std::wstring *keyword;	/* optional element of type xsd:string */
	std::wstring *status;	/* optional element of type xsd:string */
	std::wstring *securityType;	/* optional element of type xsd:string */
	std::wstring *permissionType;	/* optional element of type xsd:string */
	std::wstring *limitationType;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 37; } /* = unique id SOAP_TYPE_ns1__updateDigitalInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__updateDigitalInfo() : digitalId(NULL), author(NULL), description(NULL), title(NULL), keyword(NULL), status(NULL), securityType(NULL), permissionType(NULL), limitationType(NULL), soap(NULL) { }
	virtual ~ns1__updateDigitalInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns1__findAssignedPermission
#define SOAP_TYPE_ns1__findAssignedPermission (38)
/* ns1:findAssignedPermission */
class SOAP_CMAC ns1__findAssignedPermission
{
public:
	std::wstring *unitId;	/* optional element of type xsd:string */
	std::wstring *digitalId;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 38; } /* = unique id SOAP_TYPE_ns1__findAssignedPermission */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__findAssignedPermission() : unitId(NULL), digitalId(NULL), soap(NULL) { }
	virtual ~ns1__findAssignedPermission() { }
};
#endif

#ifndef SOAP_TYPE_ns1__createDigitalInfoResponse
#define SOAP_TYPE_ns1__createDigitalInfoResponse (39)
/* ns1:createDigitalInfoResponse */
class SOAP_CMAC ns1__createDigitalInfoResponse
{
public:
	class ns1__gingkoDigitalPack *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:gingkoDigitalPack */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 39; } /* = unique id SOAP_TYPE_ns1__createDigitalInfoResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__createDigitalInfoResponse() : return_(NULL), soap(NULL) { }
	virtual ~ns1__createDigitalInfoResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__gingkoDigitalPack
#define SOAP_TYPE_ns1__gingkoDigitalPack (40)
/* ns1:gingkoDigitalPack */
class SOAP_CMAC ns1__gingkoDigitalPack
{
public:
	class ns1__digitalContent *digitalContent;	/* optional element of type ns1:digitalContent */
	std::wstring *message;	/* optional element of type xsd:string */
	enum ns1__soapPackStatusEnum *status;	/* optional element of type ns1:soapPackStatusEnum */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 40; } /* = unique id SOAP_TYPE_ns1__gingkoDigitalPack */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__gingkoDigitalPack() : digitalContent(NULL), message(NULL), status(NULL), soap(NULL) { }
	virtual ~ns1__gingkoDigitalPack() { }
};
#endif

#ifndef SOAP_TYPE_ns1__digitalContent
#define SOAP_TYPE_ns1__digitalContent (41)
/* ns1:digitalContent */
class SOAP_CMAC ns1__digitalContent
{
public:
	std::wstring *author;	/* optional element of type xsd:string */
	std::wstring *description;	/* optional element of type xsd:string */
	std::wstring *digitalId;	/* optional element of type xsd:string */
	std::wstring *fileHash;	/* optional element of type xsd:string */
	std::wstring *title;	/* optional element of type xsd:string */
	std::wstring *keyword;	/* optional element of type xsd:string */
	std::wstring *owner;	/* optional element of type xsd:string */
	std::wstring *publicKey;	/* optional element of type xsd:string */
	std::wstring *privateKey;	/* optional element of type xsd:string */
	std::wstring *status;	/* optional element of type xsd:string */
	std::wstring *securityType;	/* optional element of type xsd:string */
	std::wstring *permissionType;	/* optional element of type xsd:string */
	std::wstring *limitationType;	/* optional element of type xsd:string */
	std::wstring *updatedBy;	/* optional element of type xsd:string */
	time_t *updatedTime;	/* optional element of type xsd:dateTime */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 41; } /* = unique id SOAP_TYPE_ns1__digitalContent */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__digitalContent() : author(NULL), description(NULL), digitalId(NULL), fileHash(NULL), title(NULL), keyword(NULL), owner(NULL), publicKey(NULL), privateKey(NULL), status(NULL), securityType(NULL), permissionType(NULL), limitationType(NULL), updatedBy(NULL), updatedTime(NULL), soap(NULL) { }
	virtual ~ns1__digitalContent() { }
};
#endif

#ifndef SOAP_TYPE_ns1__deleteDigitalInfo
#define SOAP_TYPE_ns1__deleteDigitalInfo (42)
/* ns1:deleteDigitalInfo */
class SOAP_CMAC ns1__deleteDigitalInfo
{
public:
	std::wstring *unitId;	/* optional element of type xsd:string */
	std::wstring *digitalId;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 42; } /* = unique id SOAP_TYPE_ns1__deleteDigitalInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__deleteDigitalInfo() : unitId(NULL), digitalId(NULL), soap(NULL) { }
	virtual ~ns1__deleteDigitalInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns1__updateDigitalInfoResponse
#define SOAP_TYPE_ns1__updateDigitalInfoResponse (43)
/* ns1:updateDigitalInfoResponse */
class SOAP_CMAC ns1__updateDigitalInfoResponse
{
public:
	ns1__gingkoDigitalPack *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:gingkoDigitalPack */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 43; } /* = unique id SOAP_TYPE_ns1__updateDigitalInfoResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__updateDigitalInfoResponse() : return_(NULL), soap(NULL) { }
	virtual ~ns1__updateDigitalInfoResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__findDigitalPermissionResponse
#define SOAP_TYPE_ns1__findDigitalPermissionResponse (44)
/* ns1:findDigitalPermissionResponse */
class SOAP_CMAC ns1__findDigitalPermissionResponse
{
public:
	ns1__gingkoPermissionPack *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:gingkoPermissionPack */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 44; } /* = unique id SOAP_TYPE_ns1__findDigitalPermissionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__findDigitalPermissionResponse() : return_(NULL), soap(NULL) { }
	virtual ~ns1__findDigitalPermissionResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__gingkoPermissionListPack
#define SOAP_TYPE_ns1__gingkoPermissionListPack (45)
/* ns1:gingkoPermissionListPack */
class SOAP_CMAC ns1__gingkoPermissionListPack
{
public:
	std::vector<ns1__gingkoPermission * >resultsList;	/* optional element of type ns1:gingkoPermission */
	std::wstring *message;	/* optional element of type xsd:string */
	enum ns1__soapPackStatusEnum *status;	/* optional element of type ns1:soapPackStatusEnum */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 45; } /* = unique id SOAP_TYPE_ns1__gingkoPermissionListPack */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__gingkoPermissionListPack() : message(NULL), status(NULL), soap(NULL) { }
	virtual ~ns1__gingkoPermissionListPack() { }
};
#endif

#ifndef SOAP_TYPE_ns1__deleteDigitalInfoResponse
#define SOAP_TYPE_ns1__deleteDigitalInfoResponse (46)
/* ns1:deleteDigitalInfoResponse */
class SOAP_CMAC ns1__deleteDigitalInfoResponse
{
public:
	ns1__gingkoDigitalPack *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:gingkoDigitalPack */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 46; } /* = unique id SOAP_TYPE_ns1__deleteDigitalInfoResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__deleteDigitalInfoResponse() : return_(NULL), soap(NULL) { }
	virtual ~ns1__deleteDigitalInfoResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__findAssignedPermissionResponse
#define SOAP_TYPE_ns1__findAssignedPermissionResponse (47)
/* ns1:findAssignedPermissionResponse */
class SOAP_CMAC ns1__findAssignedPermissionResponse
{
public:
	ns1__gingkoPermissionListPack *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:gingkoPermissionListPack */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 47; } /* = unique id SOAP_TYPE_ns1__findAssignedPermissionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__findAssignedPermissionResponse() : return_(NULL), soap(NULL) { }
	virtual ~ns1__findAssignedPermissionResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__findDigitalInfoResponse
#define SOAP_TYPE_ns1__findDigitalInfoResponse (48)
/* ns1:findDigitalInfoResponse */
class SOAP_CMAC ns1__findDigitalInfoResponse
{
public:
	ns1__gingkoDigitalPack *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:gingkoDigitalPack */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 48; } /* = unique id SOAP_TYPE_ns1__findDigitalInfoResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__findDigitalInfoResponse() : return_(NULL), soap(NULL) { }
	virtual ~ns1__findDigitalInfoResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__createDigitalInfo
#define SOAP_TYPE_ns1__createDigitalInfo (49)
/* ns1:createDigitalInfo */
class SOAP_CMAC ns1__createDigitalInfo
{
public:
	std::wstring *author;	/* optional element of type xsd:string */
	std::wstring *description;	/* optional element of type xsd:string */
	std::wstring *digitalId;	/* optional element of type xsd:string */
	std::wstring *fileHash;	/* optional element of type xsd:string */
	std::wstring *title;	/* optional element of type xsd:string */
	std::wstring *keyword;	/* optional element of type xsd:string */
	std::wstring *owner;	/* optional element of type xsd:string */
	std::wstring *status;	/* optional element of type xsd:string */
	std::wstring *securityType;	/* optional element of type xsd:string */
	std::wstring *permissionType;	/* optional element of type xsd:string */
	std::wstring *limitationType;	/* optional element of type xsd:string */
	std::wstring *publicKey;	/* optional element of type xsd:string */
	std::wstring *privateKey;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 49; } /* = unique id SOAP_TYPE_ns1__createDigitalInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__createDigitalInfo() : author(NULL), description(NULL), digitalId(NULL), fileHash(NULL), title(NULL), keyword(NULL), owner(NULL), status(NULL), securityType(NULL), permissionType(NULL), limitationType(NULL), publicKey(NULL), privateKey(NULL), soap(NULL) { }
	virtual ~ns1__createDigitalInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns1__findDigitalPermission
#define SOAP_TYPE_ns1__findDigitalPermission (50)
/* ns1:findDigitalPermission */
class SOAP_CMAC ns1__findDigitalPermission
{
public:
	std::wstring *unitId;	/* optional element of type xsd:string */
	std::wstring *digitalId;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 50; } /* = unique id SOAP_TYPE_ns1__findDigitalPermission */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__findDigitalPermission() : unitId(NULL), digitalId(NULL), soap(NULL) { }
	virtual ~ns1__findDigitalPermission() { }
};
#endif

#ifndef SOAP_TYPE_ns1__findGingkoUnitInfo
#define SOAP_TYPE_ns1__findGingkoUnitInfo (51)
/* ns1:findGingkoUnitInfo */
class SOAP_CMAC ns1__findGingkoUnitInfo
{
public:
	std::wstring *unitId;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 51; } /* = unique id SOAP_TYPE_ns1__findGingkoUnitInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__findGingkoUnitInfo() : unitId(NULL), soap(NULL) { }
	virtual ~ns1__findGingkoUnitInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns1__findGingkoUnitInfoResponse
#define SOAP_TYPE_ns1__findGingkoUnitInfoResponse (52)
/* ns1:findGingkoUnitInfoResponse */
class SOAP_CMAC ns1__findGingkoUnitInfoResponse
{
public:
	class ns1__gingkoUnitPack *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:gingkoUnitPack */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 52; } /* = unique id SOAP_TYPE_ns1__findGingkoUnitInfoResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__findGingkoUnitInfoResponse() : return_(NULL), soap(NULL) { }
	virtual ~ns1__findGingkoUnitInfoResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__gingkoUnitPack
#define SOAP_TYPE_ns1__gingkoUnitPack (53)
/* ns1:gingkoUnitPack */
class SOAP_CMAC ns1__gingkoUnitPack
{
public:
	class ns1__companyUnit *gingkoUnit;	/* optional element of type ns1:companyUnit */
	std::wstring *message;	/* optional element of type xsd:string */
	enum ns1__soapPackStatusEnum *status;	/* optional element of type ns1:soapPackStatusEnum */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 53; } /* = unique id SOAP_TYPE_ns1__gingkoUnitPack */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__gingkoUnitPack() : gingkoUnit(NULL), message(NULL), status(NULL), soap(NULL) { }
	virtual ~ns1__gingkoUnitPack() { }
};
#endif

#ifndef SOAP_TYPE_ns1__companyUnit
#define SOAP_TYPE_ns1__companyUnit (54)
/* ns1:companyUnit */
class SOAP_CMAC ns1__companyUnit
{
public:
	std::wstring *unitId;	/* optional element of type xsd:string */
	std::wstring *name;	/* optional element of type xsd:string */
	std::wstring *description;	/* optional element of type xsd:string */
	std::wstring *address;	/* optional element of type xsd:string */
	std::wstring *serverUrl;	/* optional element of type xsd:string */
	std::wstring *domains;	/* optional element of type xsd:string */
	std::wstring *level;	/* optional element of type xsd:string */
	std::wstring *type;	/* optional element of type xsd:string */
	std::wstring *parentId;	/* optional element of type xsd:string */
	std::wstring *status;	/* optional element of type xsd:string */
	time_t *updatedTime;	/* optional element of type xsd:dateTime */
	std::wstring *updatedBy;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 54; } /* = unique id SOAP_TYPE_ns1__companyUnit */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__companyUnit() : unitId(NULL), name(NULL), description(NULL), address(NULL), serverUrl(NULL), domains(NULL), level(NULL), type(NULL), parentId(NULL), status(NULL), updatedTime(NULL), updatedBy(NULL), soap(NULL) { }
	virtual ~ns1__companyUnit() { }
};
#endif

#ifndef SOAP_TYPE_ns1__registerThisUnit
#define SOAP_TYPE_ns1__registerThisUnit (55)
/* ns1:registerThisUnit */
class SOAP_CMAC ns1__registerThisUnit
{
public:
	std::wstring *unitId;	/* optional element of type xsd:string */
	std::wstring *parentId;	/* optional element of type xsd:string */
	std::wstring *unitServerUrl;	/* optional element of type xsd:string */
	std::wstring *unitType;	/* optional element of type xsd:string */
	std::wstring *unitLevel;	/* optional element of type xsd:string */
	std::wstring *status;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 55; } /* = unique id SOAP_TYPE_ns1__registerThisUnit */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__registerThisUnit() : unitId(NULL), parentId(NULL), unitServerUrl(NULL), unitType(NULL), unitLevel(NULL), status(NULL), soap(NULL) { }
	virtual ~ns1__registerThisUnit() { }
};
#endif

#ifndef SOAP_TYPE_ns1__registerThisUnitResponse
#define SOAP_TYPE_ns1__registerThisUnitResponse (56)
/* ns1:registerThisUnitResponse */
class SOAP_CMAC ns1__registerThisUnitResponse
{
public:
	ns1__gingkoUnitPack *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:gingkoUnitPack */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 56; } /* = unique id SOAP_TYPE_ns1__registerThisUnitResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__registerThisUnitResponse() : return_(NULL), soap(NULL) { }
	virtual ~ns1__registerThisUnitResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__searchUsers
#define SOAP_TYPE_ns1__searchUsers (57)
/* ns1:searchUsers */
class SOAP_CMAC ns1__searchUsers
{
public:
	std::wstring *theName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 57; } /* = unique id SOAP_TYPE_ns1__searchUsers */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__searchUsers() : theName(NULL), soap(NULL) { }
	virtual ~ns1__searchUsers() { }
};
#endif

#ifndef SOAP_TYPE_ns1__searchUsersResponse
#define SOAP_TYPE_ns1__searchUsersResponse (58)
/* ns1:searchUsersResponse */
class SOAP_CMAC ns1__searchUsersResponse
{
public:
	class ns1__gingkoUserListPack *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:gingkoUserListPack */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 58; } /* = unique id SOAP_TYPE_ns1__searchUsersResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__searchUsersResponse() : return_(NULL), soap(NULL) { }
	virtual ~ns1__searchUsersResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__gingkoUserListPack
#define SOAP_TYPE_ns1__gingkoUserListPack (59)
/* ns1:gingkoUserListPack */
class SOAP_CMAC ns1__gingkoUserListPack
{
public:
	std::vector<ns1__gingkoUser * >users;	/* optional element of type ns1:gingkoUser */
	std::wstring *message;	/* optional element of type xsd:string */
	enum ns1__soapPackStatusEnum *status;	/* optional element of type ns1:soapPackStatusEnum */
	int count;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 59; } /* = unique id SOAP_TYPE_ns1__gingkoUserListPack */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__gingkoUserListPack() : message(NULL), status(NULL), count(0), soap(NULL) { }
	virtual ~ns1__gingkoUserListPack() { }
};
#endif

#ifndef SOAP_TYPE___ns1__registerUser
#define SOAP_TYPE___ns1__registerUser (85)
/* Operation wrapper: */
struct __ns1__registerUser
{
public:
	ns1__registerUser *ns1__registerUser_;	/* optional element of type ns1:registerUser */
};
#endif

#ifndef SOAP_TYPE___ns1__userLogin
#define SOAP_TYPE___ns1__userLogin (89)
/* Operation wrapper: */
struct __ns1__userLogin
{
public:
	ns1__userLogin *ns1__userLogin_;	/* optional element of type ns1:userLogin */
};
#endif

#ifndef SOAP_TYPE___ns1__gingkoVersion
#define SOAP_TYPE___ns1__gingkoVersion (93)
/* Operation wrapper: */
struct __ns1__gingkoVersion
{
public:
	ns1__gingkoVersion *ns1__gingkoVersion_;	/* optional element of type ns1:gingkoVersion */
};
#endif

#ifndef SOAP_TYPE___ns1__newGingkoId
#define SOAP_TYPE___ns1__newGingkoId (97)
/* Operation wrapper: */
struct __ns1__newGingkoId
{
public:
	ns1__newGingkoId *ns1__newGingkoId_;	/* optional element of type ns1:newGingkoId */
};
#endif

#ifndef SOAP_TYPE___ns1__checkToken
#define SOAP_TYPE___ns1__checkToken (101)
/* Operation wrapper: */
struct __ns1__checkToken
{
public:
	ns1__checkToken *ns1__checkToken_;	/* optional element of type ns1:checkToken */
};
#endif

#ifndef SOAP_TYPE___ns1__registerThisUnit
#define SOAP_TYPE___ns1__registerThisUnit (105)
/* Operation wrapper: */
struct __ns1__registerThisUnit
{
public:
	ns1__registerThisUnit *ns1__registerThisUnit_;	/* optional element of type ns1:registerThisUnit */
};
#endif

#ifndef SOAP_TYPE___ns1__findGingkoUnitInfo
#define SOAP_TYPE___ns1__findGingkoUnitInfo (109)
/* Operation wrapper: */
struct __ns1__findGingkoUnitInfo
{
public:
	ns1__findGingkoUnitInfo *ns1__findGingkoUnitInfo_;	/* optional element of type ns1:findGingkoUnitInfo */
};
#endif

#ifndef SOAP_TYPE___ns1__bindingGingkoUser
#define SOAP_TYPE___ns1__bindingGingkoUser (113)
/* Operation wrapper: */
struct __ns1__bindingGingkoUser
{
public:
	ns1__bindingGingkoUser *ns1__bindingGingkoUser_;	/* optional element of type ns1:bindingGingkoUser */
};
#endif

#ifndef SOAP_TYPE___ns1__findUserByLoginId
#define SOAP_TYPE___ns1__findUserByLoginId (117)
/* Operation wrapper: */
struct __ns1__findUserByLoginId
{
public:
	ns1__findUserByLoginId *ns1__findUserByLoginId_;	/* optional element of type ns1:findUserByLoginId */
};
#endif

#ifndef SOAP_TYPE___ns1__searchUsers
#define SOAP_TYPE___ns1__searchUsers (121)
/* Operation wrapper: */
struct __ns1__searchUsers
{
public:
	ns1__searchUsers *ns1__searchUsers_;	/* optional element of type ns1:searchUsers */
};
#endif

#ifndef SOAP_TYPE___ns1__findUserByGingkoId
#define SOAP_TYPE___ns1__findUserByGingkoId (125)
/* Operation wrapper: */
struct __ns1__findUserByGingkoId
{
public:
	ns1__findUserByGingkoId *ns1__findUserByGingkoId_;	/* optional element of type ns1:findUserByGingkoId */
};
#endif

#ifndef SOAP_TYPE___ns1__changePassword
#define SOAP_TYPE___ns1__changePassword (129)
/* Operation wrapper: */
struct __ns1__changePassword
{
public:
	ns1__changePassword *ns1__changePassword_;	/* optional element of type ns1:changePassword */
};
#endif

#ifndef SOAP_TYPE___ns1__requestPermission
#define SOAP_TYPE___ns1__requestPermission (133)
/* Operation wrapper: */
struct __ns1__requestPermission
{
public:
	ns1__requestPermission *ns1__requestPermission_;	/* optional element of type ns1:requestPermission */
};
#endif

#ifndef SOAP_TYPE___ns1__deleteDigitalInfo
#define SOAP_TYPE___ns1__deleteDigitalInfo (137)
/* Operation wrapper: */
struct __ns1__deleteDigitalInfo
{
public:
	ns1__deleteDigitalInfo *ns1__deleteDigitalInfo_;	/* optional element of type ns1:deleteDigitalInfo */
};
#endif

#ifndef SOAP_TYPE___ns1__findDigitalInfo
#define SOAP_TYPE___ns1__findDigitalInfo (141)
/* Operation wrapper: */
struct __ns1__findDigitalInfo
{
public:
	ns1__findDigitalInfo *ns1__findDigitalInfo_;	/* optional element of type ns1:findDigitalInfo */
};
#endif

#ifndef SOAP_TYPE___ns1__findAssignedPermission
#define SOAP_TYPE___ns1__findAssignedPermission (145)
/* Operation wrapper: */
struct __ns1__findAssignedPermission
{
public:
	ns1__findAssignedPermission *ns1__findAssignedPermission_;	/* optional element of type ns1:findAssignedPermission */
};
#endif

#ifndef SOAP_TYPE___ns1__assignPermission
#define SOAP_TYPE___ns1__assignPermission (149)
/* Operation wrapper: */
struct __ns1__assignPermission
{
public:
	ns1__assignPermission *ns1__assignPermission_;	/* optional element of type ns1:assignPermission */
};
#endif

#ifndef SOAP_TYPE___ns1__findDigitalPermission
#define SOAP_TYPE___ns1__findDigitalPermission (153)
/* Operation wrapper: */
struct __ns1__findDigitalPermission
{
public:
	ns1__findDigitalPermission *ns1__findDigitalPermission_;	/* optional element of type ns1:findDigitalPermission */
};
#endif

#ifndef SOAP_TYPE___ns1__updateDigitalInfo
#define SOAP_TYPE___ns1__updateDigitalInfo (157)
/* Operation wrapper: */
struct __ns1__updateDigitalInfo
{
public:
	ns1__updateDigitalInfo *ns1__updateDigitalInfo_;	/* optional element of type ns1:updateDigitalInfo */
};
#endif

#ifndef SOAP_TYPE___ns1__createDigitalInfo
#define SOAP_TYPE___ns1__createDigitalInfo (161)
/* Operation wrapper: */
struct __ns1__createDigitalInfo
{
public:
	ns1__createDigitalInfo *ns1__createDigitalInfo_;	/* optional element of type ns1:createDigitalInfo */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (162)
/* SOAP Header: */
struct SOAP_ENV__Header
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (163)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (165)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
	char *__any;
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (168)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (169)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
};
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Stubs                                                                      *
 *                                                                            *
\******************************************************************************/


SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__registerUser(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__registerUser *ns1__registerUser_, ns1__registerUserResponse *ns1__registerUserResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__userLogin(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__userLogin *ns1__userLogin_, ns1__userLoginResponse *ns1__userLoginResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__gingkoVersion(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__gingkoVersion *ns1__gingkoVersion_, ns1__gingkoVersionResponse *ns1__gingkoVersionResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__newGingkoId(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__newGingkoId *ns1__newGingkoId_, ns1__newGingkoIdResponse *ns1__newGingkoIdResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__checkToken(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__checkToken *ns1__checkToken_, ns1__checkTokenResponse *ns1__checkTokenResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__registerThisUnit(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__registerThisUnit *ns1__registerThisUnit_, ns1__registerThisUnitResponse *ns1__registerThisUnitResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__findGingkoUnitInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__findGingkoUnitInfo *ns1__findGingkoUnitInfo_, ns1__findGingkoUnitInfoResponse *ns1__findGingkoUnitInfoResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__bindingGingkoUser(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__bindingGingkoUser *ns1__bindingGingkoUser_, ns1__bindingGingkoUserResponse *ns1__bindingGingkoUserResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__findUserByLoginId(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__findUserByLoginId *ns1__findUserByLoginId_, ns1__findUserByLoginIdResponse *ns1__findUserByLoginIdResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__searchUsers(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__searchUsers *ns1__searchUsers_, ns1__searchUsersResponse *ns1__searchUsersResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__findUserByGingkoId(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__findUserByGingkoId *ns1__findUserByGingkoId_, ns1__findUserByGingkoIdResponse *ns1__findUserByGingkoIdResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__changePassword(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__changePassword *ns1__changePassword_, ns1__changePasswordResponse *ns1__changePasswordResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__requestPermission(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__requestPermission *ns1__requestPermission_, ns1__requestPermissionResponse *ns1__requestPermissionResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__deleteDigitalInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__deleteDigitalInfo *ns1__deleteDigitalInfo_, ns1__deleteDigitalInfoResponse *ns1__deleteDigitalInfoResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__findDigitalInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__findDigitalInfo *ns1__findDigitalInfo_, ns1__findDigitalInfoResponse *ns1__findDigitalInfoResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__findAssignedPermission(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__findAssignedPermission *ns1__findAssignedPermission_, ns1__findAssignedPermissionResponse *ns1__findAssignedPermissionResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__assignPermission(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__assignPermission *ns1__assignPermission_, ns1__assignPermissionResponse *ns1__assignPermissionResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__findDigitalPermission(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__findDigitalPermission *ns1__findDigitalPermission_, ns1__findDigitalPermissionResponse *ns1__findDigitalPermissionResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__updateDigitalInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__updateDigitalInfo *ns1__updateDigitalInfo_, ns1__updateDigitalInfoResponse *ns1__updateDigitalInfoResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__createDigitalInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__createDigitalInfo *ns1__createDigitalInfo_, ns1__createDigitalInfoResponse *ns1__createDigitalInfoResponse_);

#endif

/* End of soapStub.h */
